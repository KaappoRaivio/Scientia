{"ast":null,"code":"import { isInteger } from './number';\nimport { isNumber } from './is';\nimport { format } from './string';\nimport { DimensionError } from '../error/DimensionError';\nimport { IndexError } from '../error/IndexError';\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\n\nexport function arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\n\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\nexport function validateIndex(index, length) {\n  if (!isNumber(index) || !isInteger(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new IndexError(index, length);\n  }\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\nexport function resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\n\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var newArray;\n\n  function product(arr) {\n    return arr.reduce(function (prev, curr) {\n      return prev * curr;\n    });\n  }\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, product(arraySize(array)), '!=');\n  }\n\n  var totalSize = 1;\n\n  for (var sizeIndex = 0; sizeIndex < sizes.length; sizeIndex++) {\n    totalSize *= sizes[sizeIndex];\n  }\n\n  if (flatArray.length !== totalSize) {\n    throw new DimensionError(product(sizes), product(arraySize(array)), '!=');\n  }\n\n  try {\n    newArray = _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(product(sizes), product(arraySize(array)), '!=');\n    }\n\n    throw e;\n  }\n\n  return newArray;\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\n\nexport function squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\n\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\n\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, function (entry) {\n    return regexp.test(entry);\n  });\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return string\n */\n\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\n * Return the last item from an array\n * @param array\n * @returns {*}\n */\n\nexport function last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n */\n\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/utils/array.js"],"names":["isInteger","isNumber","format","DimensionError","IndexError","arraySize","x","s","Array","isArray","push","length","_validate","array","size","dim","i","len","dimNext","child","validate","isScalar","validateIndex","index","TypeError","resize","defaultValue","Error","forEach","value","_defaultValue","undefined","_resize","elem","oldLen","newLen","minLen","Math","min","reshape","sizes","flatArray","flatten","newArray","product","arr","reduce","prev","curr","totalSize","sizeIndex","_reshape","e","tmpArray","tmpArray2","slice","squeeze","shift","dims","_squeeze","ii","next","unsqueeze","outer","unshift","_unsqueeze","d","flat","callback","map","prototype","call","filter","filterRegExp","regexp","entry","test","join","separator","identify","a","b","count","identifier","generalize","getArrayDataType","typeOf","type","item","itemType","last","initial","contains","indexOf"],"mappings":"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","sourcesContent":["import { isInteger } from './number';\nimport { isNumber } from './is';\nimport { format } from './string';\nimport { DimensionError } from '../error/DimensionError';\nimport { IndexError } from '../error/IndexError';\n/**\n * Calculate the size of a multi dimensional array.\n * This function checks the size of the first entry, it does not validate\n * whether all dimensions match. (use function `validate` for that)\n * @param {Array} x\n * @Return {Number[]} size\n */\n\nexport function arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\n * Recursively validate whether each element in a multi dimensional array\n * has a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @param {number} dim   Current dimension\n * @throws DimensionError\n * @private\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\n * Validate whether each element in a multi dimensional array has\n * a size corresponding to the provided size array.\n * @param {Array} array    Array to be validated\n * @param {number[]} size  Array with the size of each dimension\n * @throws DimensionError\n */\n\n\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\n * Test whether index is an integer number with index >= 0 and index < length\n * when length is provided\n * @param {number} index    Zero-based index\n * @param {number} [length] Length of the array\n */\n\nexport function validateIndex(index, length) {\n  if (!isNumber(index) || !isInteger(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new IndexError(index, length);\n  }\n}\n/**\n * Resize a multi dimensional array. The resized array is returned.\n * @param {Array} array         Array to be resized\n * @param {Array.<number>} size Array with the size of each dimension\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\n *                              zero by default. Specify for example `null`,\n *                              to clearly see entries that are not explicitly\n *                              set.\n * @return {Array} array         The resized array\n */\n\nexport function resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\n * Recursively resize a multi dimensional array\n * @param {Array} array         Array to be resized\n * @param {number[]} size       Array with the size of each dimension\n * @param {number} dim          Current dimension\n * @param {*} [defaultValue]    Value to be filled in in new entries,\n *                              undefined by default.\n * @private\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\n * Re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n *\n * @throws {DimensionError}       If the product of the new dimension sizes does\n *                                not equal that of the old ones\n */\n\n\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var newArray;\n\n  function product(arr) {\n    return arr.reduce(function (prev, curr) {\n      return prev * curr;\n    });\n  }\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, product(arraySize(array)), '!=');\n  }\n\n  var totalSize = 1;\n\n  for (var sizeIndex = 0; sizeIndex < sizes.length; sizeIndex++) {\n    totalSize *= sizes[sizeIndex];\n  }\n\n  if (flatArray.length !== totalSize) {\n    throw new DimensionError(product(sizes), product(arraySize(array)), '!=');\n  }\n\n  try {\n    newArray = _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(product(sizes), product(arraySize(array)), '!=');\n    }\n\n    throw e;\n  }\n\n  return newArray;\n}\n/**\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\n * @param {Array} array           Array to be reshaped\n * @param {Array.<number>} sizes  List of sizes for each dimension\n * @returns {Array}               Array whose data has been formatted to fit the\n *                                specified dimensions\n */\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\n * Squeeze a multi dimensional array\n * @param {Array} array\n * @param {Array} [size]\n * @returns {Array} returns the array itself\n */\n\n\nexport function squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\n * Recursively squeeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\n * Unsqueeze a multi dimensional array: add dimensions when missing\n *\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\n *\n * @param {Array} array\n * @param {number} dims       Desired number of dimensions of the array\n * @param {number} [outer]    Number of outer dimensions to be added\n * @param {Array} [size] Current size of array.\n * @returns {Array} returns the array itself\n * @private\n */\n\n\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\n * Recursively unsqueeze a multi dimensional array\n * @param {Array} array\n * @param {number} dims Required number of dimensions\n * @param {number} dim  Current dimension\n * @returns {Array | *} Returns the squeezed array\n * @private\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\n * Flatten a multi dimensional array, put all elements in a one dimensional\n * array\n * @param {Array} array   A multi dimensional array\n * @return {Array}        The flattened array (1 dimensional)\n */\n\n\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\n * A safe map\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\n * A safe forEach\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\n * A safe filter\n * @param {Array} array\n * @param {function} callback\n */\n\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\n * Filter values in a callback given a regular expression\n * @param {Array} array\n * @param {RegExp} regexp\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, function (entry) {\n    return regexp.test(entry);\n  });\n}\n/**\n * A safe join\n * @param {Array} array\n * @param {string} separator\n */\n\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\n * Assign a numeric identifier to every element of a sorted array\n * @param {Array} a  An array\n * @return {Array} An array of objects containing the original value and its identifier\n */\n\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\n * Remove the numeric identifier from the elements\n * @param {array} a  An array\n * @return {array} An array of values without identifiers\n */\n\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\n * Check the datatype of a given object\n * This is a low level implementation that should only be used by\n * parent Matrix classes such as SparseMatrix or DenseMatrix\n * This method does not validate Array Matrix shape\n * @param {Array} array\n * @param {function} typeOf   Callback function to use to determine the type of a value\n * @return string\n */\n\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\n * Return the last item from an array\n * @param array\n * @returns {*}\n */\n\nexport function last(array) {\n  return array[array.length - 1];\n}\n/**\n * Get all but the last element of array.\n */\n\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\n * Test whether an array or string contains an item\n * @param {Array | string} array\n * @param {*} item\n * @return {boolean}\n */\n\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { factory } from '../../../utils/factory';\nimport { createCsSpsolve } from './csSpsolve';\nvar name = 'csLu';\nvar dependencies = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createCsLu = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var abs = _ref.abs,\n      divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSpsolve = createCsSpsolve({\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract\n  });\n  /**\n   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization\n   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L\n   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so\n   * L * U = A(p, q), where p is the inverse of pinv.\n   *\n   * @param {Matrix}  m               The A Matrix to factorize\n   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing\n   *                                  column ordering q\n   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Number}                 The numeric LU factorization of A or null\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csLu(m, s, tol) {\n    // validate input\n    if (!m) {\n      return null;\n    } // m arrays\n\n\n    var size = m._size; // columns\n\n    var n = size[1]; // symbolic analysis result\n\n    var q;\n    var lnz = 100;\n    var unz = 100; // update symbolic analysis parameters\n\n    if (s) {\n      q = s.q;\n      lnz = s.lnz || lnz;\n      unz = s.unz || unz;\n    } // L arrays\n\n\n    var lvalues = []; // (lnz)\n\n    var lindex = []; // (lnz)\n\n    var lptr = []; // (n + 1)\n    // L\n\n    var L = new SparseMatrix({\n      values: lvalues,\n      index: lindex,\n      ptr: lptr,\n      size: [n, n]\n    }); // U arrays\n\n    var uvalues = []; // (unz)\n\n    var uindex = []; // (unz)\n\n    var uptr = []; // (n + 1)\n    // U\n\n    var U = new SparseMatrix({\n      values: uvalues,\n      index: uindex,\n      ptr: uptr,\n      size: [n, n]\n    }); // inverse of permutation vector\n\n    var pinv = []; // (n)\n    // vars\n\n    var i, p; // allocate arrays\n\n    var x = []; // (n)\n\n    var xi = []; // (2 * n)\n    // initialize variables\n\n    for (i = 0; i < n; i++) {\n      // clear workspace\n      x[i] = 0; // no rows pivotal yet\n\n      pinv[i] = -1; // no cols of L yet\n\n      lptr[i + 1] = 0;\n    } // reset number of nonzero elements in L and U\n\n\n    lnz = 0;\n    unz = 0; // compute L(:,k) and U(:,k)\n\n    for (var k = 0; k < n; k++) {\n      // update ptr\n      lptr[k] = lnz;\n      uptr[k] = unz; // apply column permutations if needed\n\n      var col = q ? q[k] : k; // solve triangular system, x = L\\A(:,col)\n\n      var top = csSpsolve(L, m, col, xi, x, pinv, 1); // find pivot\n\n      var ipiv = -1;\n      var a = -1; // loop xi[] from top -> n\n\n      for (p = top; p < n; p++) {\n        // x[i] is nonzero\n        i = xi[p]; // check row i is not yet pivotal\n\n        if (pinv[i] < 0) {\n          // absolute value of x[i]\n          var xabs = abs(x[i]); // check absoulte value is greater than pivot value\n\n          if (larger(xabs, a)) {\n            // largest pivot candidate so far\n            a = xabs;\n            ipiv = i;\n          }\n        } else {\n          // x(i) is the entry U(pinv[i],k)\n          uindex[unz] = pinv[i];\n          uvalues[unz++] = x[i];\n        }\n      } // validate we found a valid pivot\n\n\n      if (ipiv === -1 || a <= 0) {\n        return null;\n      } // update actual pivot column, give preference to diagonal value\n\n\n      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {\n        ipiv = col;\n      } // the chosen pivot\n\n\n      var pivot = x[ipiv]; // last entry in U(:,k) is U(k,k)\n\n      uindex[unz] = k;\n      uvalues[unz++] = pivot; // ipiv is the kth pivot row\n\n      pinv[ipiv] = k; // first entry in L(:,k) is L(k,k) = 1\n\n      lindex[lnz] = ipiv;\n      lvalues[lnz++] = 1; // L(k+1:n,k) = x / pivot\n\n      for (p = top; p < n; p++) {\n        // row\n        i = xi[p]; // check x(i) is an entry in L(:,k)\n\n        if (pinv[i] < 0) {\n          // save unpermuted row in L\n          lindex[lnz] = i; // scale pivot column\n\n          lvalues[lnz++] = divideScalar(x[i], pivot);\n        } // x[0..n-1] = 0 for next k\n\n\n        x[i] = 0;\n      }\n    } // update ptr\n\n\n    lptr[n] = lnz;\n    uptr[n] = unz; // fix row indices of L for final pinv\n\n    for (p = 0; p < lnz; p++) {\n      lindex[p] = pinv[lindex[p]];\n    } // trim arrays\n\n\n    lvalues.splice(lnz, lvalues.length - lnz);\n    lindex.splice(lnz, lindex.length - lnz);\n    uvalues.splice(unz, uvalues.length - unz);\n    uindex.splice(unz, uindex.length - unz); // return LU factor\n\n    return {\n      L: L,\n      U: U,\n      pinv: pinv\n    };\n  };\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/sparse/csLu.js"],"names":["factory","createCsSpsolve","name","dependencies","createCsLu","_ref","abs","divideScalar","multiply","subtract","larger","largerEq","SparseMatrix","csSpsolve","csLu","m","s","tol","size","_size","n","q","lnz","unz","lvalues","lindex","lptr","L","values","index","ptr","uvalues","uindex","uptr","U","pinv","i","p","x","xi","k","col","top","ipiv","a","xabs","pivot","splice","length"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory';\nimport { createCsSpsolve } from './csSpsolve';\nvar name = 'csLu';\nvar dependencies = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createCsLu = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var abs = _ref.abs,\n      divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSpsolve = createCsSpsolve({\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract\n  });\n  /**\n   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization\n   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L\n   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so\n   * L * U = A(p, q), where p is the inverse of pinv.\n   *\n   * @param {Matrix}  m               The A Matrix to factorize\n   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing\n   *                                  column ordering q\n   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Number}                 The numeric LU factorization of A or null\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csLu(m, s, tol) {\n    // validate input\n    if (!m) {\n      return null;\n    } // m arrays\n\n\n    var size = m._size; // columns\n\n    var n = size[1]; // symbolic analysis result\n\n    var q;\n    var lnz = 100;\n    var unz = 100; // update symbolic analysis parameters\n\n    if (s) {\n      q = s.q;\n      lnz = s.lnz || lnz;\n      unz = s.unz || unz;\n    } // L arrays\n\n\n    var lvalues = []; // (lnz)\n\n    var lindex = []; // (lnz)\n\n    var lptr = []; // (n + 1)\n    // L\n\n    var L = new SparseMatrix({\n      values: lvalues,\n      index: lindex,\n      ptr: lptr,\n      size: [n, n]\n    }); // U arrays\n\n    var uvalues = []; // (unz)\n\n    var uindex = []; // (unz)\n\n    var uptr = []; // (n + 1)\n    // U\n\n    var U = new SparseMatrix({\n      values: uvalues,\n      index: uindex,\n      ptr: uptr,\n      size: [n, n]\n    }); // inverse of permutation vector\n\n    var pinv = []; // (n)\n    // vars\n\n    var i, p; // allocate arrays\n\n    var x = []; // (n)\n\n    var xi = []; // (2 * n)\n    // initialize variables\n\n    for (i = 0; i < n; i++) {\n      // clear workspace\n      x[i] = 0; // no rows pivotal yet\n\n      pinv[i] = -1; // no cols of L yet\n\n      lptr[i + 1] = 0;\n    } // reset number of nonzero elements in L and U\n\n\n    lnz = 0;\n    unz = 0; // compute L(:,k) and U(:,k)\n\n    for (var k = 0; k < n; k++) {\n      // update ptr\n      lptr[k] = lnz;\n      uptr[k] = unz; // apply column permutations if needed\n\n      var col = q ? q[k] : k; // solve triangular system, x = L\\A(:,col)\n\n      var top = csSpsolve(L, m, col, xi, x, pinv, 1); // find pivot\n\n      var ipiv = -1;\n      var a = -1; // loop xi[] from top -> n\n\n      for (p = top; p < n; p++) {\n        // x[i] is nonzero\n        i = xi[p]; // check row i is not yet pivotal\n\n        if (pinv[i] < 0) {\n          // absolute value of x[i]\n          var xabs = abs(x[i]); // check absoulte value is greater than pivot value\n\n          if (larger(xabs, a)) {\n            // largest pivot candidate so far\n            a = xabs;\n            ipiv = i;\n          }\n        } else {\n          // x(i) is the entry U(pinv[i],k)\n          uindex[unz] = pinv[i];\n          uvalues[unz++] = x[i];\n        }\n      } // validate we found a valid pivot\n\n\n      if (ipiv === -1 || a <= 0) {\n        return null;\n      } // update actual pivot column, give preference to diagonal value\n\n\n      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {\n        ipiv = col;\n      } // the chosen pivot\n\n\n      var pivot = x[ipiv]; // last entry in U(:,k) is U(k,k)\n\n      uindex[unz] = k;\n      uvalues[unz++] = pivot; // ipiv is the kth pivot row\n\n      pinv[ipiv] = k; // first entry in L(:,k) is L(k,k) = 1\n\n      lindex[lnz] = ipiv;\n      lvalues[lnz++] = 1; // L(k+1:n,k) = x / pivot\n\n      for (p = top; p < n; p++) {\n        // row\n        i = xi[p]; // check x(i) is an entry in L(:,k)\n\n        if (pinv[i] < 0) {\n          // save unpermuted row in L\n          lindex[lnz] = i; // scale pivot column\n\n          lvalues[lnz++] = divideScalar(x[i], pivot);\n        } // x[0..n-1] = 0 for next k\n\n\n        x[i] = 0;\n      }\n    } // update ptr\n\n\n    lptr[n] = lnz;\n    uptr[n] = unz; // fix row indices of L for final pinv\n\n    for (p = 0; p < lnz; p++) {\n      lindex[p] = pinv[lindex[p]];\n    } // trim arrays\n\n\n    lvalues.splice(lnz, lvalues.length - lnz);\n    lindex.splice(lnz, lindex.length - lnz);\n    uvalues.splice(unz, uvalues.length - unz);\n    uindex.splice(unz, uindex.length - unz); // return LU factor\n\n    return {\n      L: L,\n      U: U,\n      pinv: pinv\n    };\n  };\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { isBigNumber, isString, typeOf } from './is';\nimport { format as formatNumber } from './number';\nimport { format as formatBigNumber } from './bignumber/formatter';\n/**\n * Check if a text ends with a certain string.\n * @param {string} text\n * @param {string} search\n */\n\nexport function endsWith(text, search) {\n  var start = text.length - search.length;\n  var end = text.length;\n  return text.substring(start, end) === search;\n}\n/**\n * Format a value of any type into a string.\n *\n * Usage:\n *     math.format(value)\n *     math.format(value, precision)\n *\n * When value is a function:\n *\n * - When the function has a property `syntax`, it returns this\n *   syntax description.\n * - In other cases, a string `'function'` is returned.\n *\n * When `value` is an Object:\n *\n * - When the object contains a property `format` being a function, this\n *   function is invoked as `value.format(options)` and the result is returned.\n * - When the object has its own `toString` method, this method is invoked\n *   and the result is returned.\n * - In other cases the function will loop over all object properties and\n *   return JSON object notation like '{\"a\": 2, \"b\": 3}'.\n *\n * Example usage:\n *     math.format(2/7)                // '0.2857142857142857'\n *     math.format(math.pi, 3)         // '3.14'\n *     math.format(new Complex(2, 3))  // '2 + 3i'\n *     math.format('hello')            // '\"hello\"'\n *\n * @param {*} value             Value to be stringified\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @return {string} str\n */\n\nexport function format(value, options) {\n  if (typeof value === 'number') {\n    return formatNumber(value, options);\n  }\n\n  if (isBigNumber(value)) {\n    return formatBigNumber(value, options);\n  } // note: we use unsafe duck-typing here to check for Fractions, this is\n  // ok here since we're only invoking toString or concatenating its values\n\n\n  if (looksLikeFraction(value)) {\n    if (!options || options.fraction !== 'decimal') {\n      // output as ratio, like '1/3'\n      return value.s * value.n + '/' + value.d;\n    } else {\n      // output as decimal, like '0.(3)'\n      return value.toString();\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return formatArray(value, options);\n  }\n\n  if (isString(value)) {\n    return '\"' + value + '\"';\n  }\n\n  if (typeof value === 'function') {\n    return value.syntax ? String(value.syntax) : 'function';\n  }\n\n  if (value && _typeof(value) === 'object') {\n    if (typeof value.format === 'function') {\n      return value.format(options);\n    } else if (value && value.toString(options) !== {}.toString()) {\n      // this object has a non-native toString method, use that one\n      return value.toString(options);\n    } else {\n      var entries = Object.keys(value).map(function (key) {\n        return '\"' + key + '\": ' + format(value[key], options);\n      });\n      return '{' + entries.join(', ') + '}';\n    }\n  }\n\n  return String(value);\n}\n/**\n * Stringify a value into a string enclosed in double quotes.\n * Unescaped double quotes and backslashes inside the value are escaped.\n * @param {*} value\n * @return {string}\n */\n\nexport function stringify(value) {\n  var text = String(value);\n  var escaped = '';\n  var i = 0;\n\n  while (i < text.length) {\n    var c = text.charAt(i);\n\n    if (c === '\\\\') {\n      escaped += c;\n      i++;\n      c = text.charAt(i);\n\n      if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) === -1) {\n        escaped += '\\\\'; // no valid escape character -> escape it\n      }\n\n      escaped += c;\n    } else if (c === '\"') {\n      escaped += '\\\\\"';\n    } else {\n      escaped += c;\n    }\n\n    i++;\n  }\n\n  return '\"' + escaped + '\"';\n}\n/**\n * Escape special HTML characters\n * @param {*} value\n * @return {string}\n */\n\nexport function escape(value) {\n  var text = String(value);\n  text = text.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return text;\n}\n/**\n * Recursively format an n-dimensional matrix\n * Example output: \"[[1, 2], [3, 4]]\"\n * @param {Array} array\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @returns {string} str\n */\n\nfunction formatArray(array, options) {\n  if (Array.isArray(array)) {\n    var str = '[';\n    var len = array.length;\n\n    for (var i = 0; i < len; i++) {\n      if (i !== 0) {\n        str += ', ';\n      }\n\n      str += formatArray(array[i], options);\n    }\n\n    str += ']';\n    return str;\n  } else {\n    return format(array, options);\n  }\n}\n/**\n * Check whether a value looks like a Fraction (unsafe duck-type check)\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction looksLikeFraction(value) {\n  return value && _typeof(value) === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;\n}\n/**\n * Compare two strings\n * @param {string} x\n * @param {string} y\n * @returns {number}\n */\n\n\nexport function compareText(x, y) {\n  // we don't want to convert numbers to string, only accept string input\n  if (!isString(x)) {\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf(x) + ', index: 0)');\n  }\n\n  if (!isString(y)) {\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf(y) + ', index: 1)');\n  }\n\n  return x === y ? 0 : x > y ? 1 : -1;\n}","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/utils/string.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","isBigNumber","isString","typeOf","format","formatNumber","formatBigNumber","endsWith","text","search","start","length","end","substring","value","options","looksLikeFraction","fraction","s","n","d","toString","Array","isArray","formatArray","syntax","String","entries","Object","keys","map","key","join","stringify","escaped","i","c","charAt","indexOf","escape","replace","array","str","len","compareText","x","y","TypeError"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { isBigNumber, isString, typeOf } from './is';\nimport { format as formatNumber } from './number';\nimport { format as formatBigNumber } from './bignumber/formatter';\n/**\n * Check if a text ends with a certain string.\n * @param {string} text\n * @param {string} search\n */\n\nexport function endsWith(text, search) {\n  var start = text.length - search.length;\n  var end = text.length;\n  return text.substring(start, end) === search;\n}\n/**\n * Format a value of any type into a string.\n *\n * Usage:\n *     math.format(value)\n *     math.format(value, precision)\n *\n * When value is a function:\n *\n * - When the function has a property `syntax`, it returns this\n *   syntax description.\n * - In other cases, a string `'function'` is returned.\n *\n * When `value` is an Object:\n *\n * - When the object contains a property `format` being a function, this\n *   function is invoked as `value.format(options)` and the result is returned.\n * - When the object has its own `toString` method, this method is invoked\n *   and the result is returned.\n * - In other cases the function will loop over all object properties and\n *   return JSON object notation like '{\"a\": 2, \"b\": 3}'.\n *\n * Example usage:\n *     math.format(2/7)                // '0.2857142857142857'\n *     math.format(math.pi, 3)         // '3.14'\n *     math.format(new Complex(2, 3))  // '2 + 3i'\n *     math.format('hello')            // '\"hello\"'\n *\n * @param {*} value             Value to be stringified\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @return {string} str\n */\n\nexport function format(value, options) {\n  if (typeof value === 'number') {\n    return formatNumber(value, options);\n  }\n\n  if (isBigNumber(value)) {\n    return formatBigNumber(value, options);\n  } // note: we use unsafe duck-typing here to check for Fractions, this is\n  // ok here since we're only invoking toString or concatenating its values\n\n\n  if (looksLikeFraction(value)) {\n    if (!options || options.fraction !== 'decimal') {\n      // output as ratio, like '1/3'\n      return value.s * value.n + '/' + value.d;\n    } else {\n      // output as decimal, like '0.(3)'\n      return value.toString();\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return formatArray(value, options);\n  }\n\n  if (isString(value)) {\n    return '\"' + value + '\"';\n  }\n\n  if (typeof value === 'function') {\n    return value.syntax ? String(value.syntax) : 'function';\n  }\n\n  if (value && _typeof(value) === 'object') {\n    if (typeof value.format === 'function') {\n      return value.format(options);\n    } else if (value && value.toString(options) !== {}.toString()) {\n      // this object has a non-native toString method, use that one\n      return value.toString(options);\n    } else {\n      var entries = Object.keys(value).map(function (key) {\n        return '\"' + key + '\": ' + format(value[key], options);\n      });\n      return '{' + entries.join(', ') + '}';\n    }\n  }\n\n  return String(value);\n}\n/**\n * Stringify a value into a string enclosed in double quotes.\n * Unescaped double quotes and backslashes inside the value are escaped.\n * @param {*} value\n * @return {string}\n */\n\nexport function stringify(value) {\n  var text = String(value);\n  var escaped = '';\n  var i = 0;\n\n  while (i < text.length) {\n    var c = text.charAt(i);\n\n    if (c === '\\\\') {\n      escaped += c;\n      i++;\n      c = text.charAt(i);\n\n      if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) === -1) {\n        escaped += '\\\\'; // no valid escape character -> escape it\n      }\n\n      escaped += c;\n    } else if (c === '\"') {\n      escaped += '\\\\\"';\n    } else {\n      escaped += c;\n    }\n\n    i++;\n  }\n\n  return '\"' + escaped + '\"';\n}\n/**\n * Escape special HTML characters\n * @param {*} value\n * @return {string}\n */\n\nexport function escape(value) {\n  var text = String(value);\n  text = text.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return text;\n}\n/**\n * Recursively format an n-dimensional matrix\n * Example output: \"[[1, 2], [3, 4]]\"\n * @param {Array} array\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @returns {string} str\n */\n\nfunction formatArray(array, options) {\n  if (Array.isArray(array)) {\n    var str = '[';\n    var len = array.length;\n\n    for (var i = 0; i < len; i++) {\n      if (i !== 0) {\n        str += ', ';\n      }\n\n      str += formatArray(array[i], options);\n    }\n\n    str += ']';\n    return str;\n  } else {\n    return format(array, options);\n  }\n}\n/**\n * Check whether a value looks like a Fraction (unsafe duck-type check)\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction looksLikeFraction(value) {\n  return value && _typeof(value) === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;\n}\n/**\n * Compare two strings\n * @param {string} x\n * @param {string} y\n * @returns {number}\n */\n\n\nexport function compareText(x, y) {\n  // we don't want to convert numbers to string, only accept string input\n  if (!isString(x)) {\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf(x) + ', index: 0)');\n  }\n\n  if (!isString(y)) {\n    throw new TypeError('Unexpected type of argument in function compareText ' + '(expected: string or Array or Matrix, actual: ' + typeOf(y) + ', index: 1)');\n  }\n\n  return x === y ? 0 : x > y ? 1 : -1;\n}"]},"metadata":{},"sourceType":"module"}
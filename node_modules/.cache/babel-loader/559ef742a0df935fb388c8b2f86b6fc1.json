{"ast":null,"code":"import { isCollection, isMatrix } from './is';\nimport { IndexError } from '../error/IndexError';\nimport { arraySize } from './array';\n/**\n * Test whether an array contains collections\n * @param {Array} array\n * @returns {boolean} Returns true when the array contains one or multiple\n *                    collections (Arrays or Matrices). Returns false otherwise.\n */\n\nexport function containsCollections(array) {\n  for (var i = 0; i < array.length; i++) {\n    if (isCollection(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Recursively loop over all elements in a given multi dimensional array\n * and invoke the callback on each of the elements.\n * @param {Array | Matrix} array\n * @param {Function} callback     The callback method is invoked with one\n *                                parameter: the current element in the array\n */\n\nexport function deepForEach(array, callback) {\n  if (isMatrix(array)) {\n    array = array.valueOf();\n  }\n\n  for (var i = 0, ii = array.length; i < ii; i++) {\n    var value = array[i];\n\n    if (Array.isArray(value)) {\n      deepForEach(value, callback);\n    } else {\n      callback(value);\n    }\n  }\n}\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\n\nexport function deepMap(array, callback, skipZeros) {\n  if (array && typeof array.map === 'function') {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  } else {\n    return callback(array);\n  }\n}\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\nexport function reduce(mat, dim, callback) {\n  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new IndexError(dim, size.length);\n  }\n\n  if (isMatrix(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n}\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n} // TODO: document function scatter\n\n\nexport function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr; // vars\n\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\n\n  if (x) {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i); // x(i) = A, check we need to call function this time\n\n        if (update) {\n          // copy value to workspace calling callback function\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\n\n          u[i] = mark;\n        } else {\n          // copy value to workspace\n          x[i] = avalues[k];\n        }\n      } else {\n        // i exists in C already\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\n\n        u[i] = mark;\n      }\n    }\n  } else {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i);\n      } else {\n        // indicate function was called on current row\n        u[i] = mark;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/utils/collection.js"],"names":["isCollection","isMatrix","IndexError","arraySize","containsCollections","array","i","length","deepForEach","callback","valueOf","ii","value","Array","isArray","deepMap","skipZeros","map","x","reduce","mat","dim","size","create","_reduce","ret","val","tran","_switch","I","J","j","tmp","push","scatter","a","w","u","mark","cindex","f","inverse","update","avalues","_values","aindex","_index","aptr","_ptr","k","k0","k1"],"mappings":"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","sourcesContent":["import { isCollection, isMatrix } from './is';\nimport { IndexError } from '../error/IndexError';\nimport { arraySize } from './array';\n/**\n * Test whether an array contains collections\n * @param {Array} array\n * @returns {boolean} Returns true when the array contains one or multiple\n *                    collections (Arrays or Matrices). Returns false otherwise.\n */\n\nexport function containsCollections(array) {\n  for (var i = 0; i < array.length; i++) {\n    if (isCollection(array[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Recursively loop over all elements in a given multi dimensional array\n * and invoke the callback on each of the elements.\n * @param {Array | Matrix} array\n * @param {Function} callback     The callback method is invoked with one\n *                                parameter: the current element in the array\n */\n\nexport function deepForEach(array, callback) {\n  if (isMatrix(array)) {\n    array = array.valueOf();\n  }\n\n  for (var i = 0, ii = array.length; i < ii; i++) {\n    var value = array[i];\n\n    if (Array.isArray(value)) {\n      deepForEach(value, callback);\n    } else {\n      callback(value);\n    }\n  }\n}\n/**\n * Execute the callback function element wise for each element in array and any\n * nested array\n * Returns an array with the results\n * @param {Array | Matrix} array\n * @param {Function} callback   The callback is called with two parameters:\n *                              value1 and value2, which contain the current\n *                              element of both arrays.\n * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n *\n * @return {Array | Matrix} res\n */\n\nexport function deepMap(array, callback, skipZeros) {\n  if (array && typeof array.map === 'function') {\n    // TODO: replace array.map with a for loop to improve performance\n    return array.map(function (x) {\n      return deepMap(x, callback, skipZeros);\n    });\n  } else {\n    return callback(array);\n  }\n}\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\nexport function reduce(mat, dim, callback) {\n  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new IndexError(dim, size.length);\n  }\n\n  if (isMatrix(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n}\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n} // TODO: document function scatter\n\n\nexport function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr; // vars\n\n  var k, k0, k1, i; // check we need to process values (pattern matrix)\n\n  if (x) {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i); // x(i) = A, check we need to call function this time\n\n        if (update) {\n          // copy value to workspace calling callback function\n          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]); // function was called on current row\n\n          u[i] = mark;\n        } else {\n          // copy value to workspace\n          x[i] = avalues[k];\n        }\n      } else {\n        // i exists in C already\n        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]); // function was called on current row\n\n        u[i] = mark;\n      }\n    }\n  } else {\n    // values in j\n    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {\n      // row\n      i = aindex[k]; // check value exists in current j\n\n      if (w[i] !== mark) {\n        // i is new entry in j\n        w[i] = mark; // add i to pattern of C\n\n        cindex.push(i);\n      } else {\n        // indicate function was called on current row\n        u[i] = mark;\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}
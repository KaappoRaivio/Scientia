{"ast":null,"code":"import { deepMap } from '../../utils/collection';\nimport { factory } from '../../utils/factory';\nimport { gammaG, gammaNumber, gammaP } from '../../plain/number';\nvar name = 'gamma';\nvar dependencies = ['typed', 'config', 'multiplyScalar', 'pow', 'BigNumber', 'Complex'];\nexport var createGamma = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      multiplyScalar = _ref.multiplyScalar,\n      pow = _ref.pow,\n      _BigNumber = _ref.BigNumber,\n      _Complex = _ref.Complex;\n  /**\n   * Compute the gamma function of a value using Lanczos approximation for\n   * small values, and an extended Stirling approximation for large values.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.gamma(n)\n   *\n   * Examples:\n   *\n   *    math.gamma(5)       // returns 24\n   *    math.gamma(-0.5)    // returns -3.5449077018110335\n   *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i\n   *\n   * See also:\n   *\n   *    combinations, factorial, permutations\n   *\n   * @param {number | Array | Matrix} n   A real or complex number\n   * @return {number | Array | Matrix}    The gamma of `n`\n   */\n\n  var gamma = typed(name, {\n    number: gammaNumber,\n    Complex: function Complex(n) {\n      if (n.im === 0) {\n        return gamma(n.re);\n      }\n\n      n = new _Complex(n.re - 1, n.im);\n      var x = new _Complex(gammaP[0], 0);\n\n      for (var i = 1; i < gammaP.length; ++i) {\n        var real = n.re + i; // x += p[i]/(n+i)\n\n        var den = real * real + n.im * n.im;\n\n        if (den !== 0) {\n          x.re += gammaP[i] * real / den;\n          x.im += -(gammaP[i] * n.im) / den;\n        } else {\n          x.re = gammaP[i] < 0 ? -Infinity : Infinity;\n        }\n      }\n\n      var t = new _Complex(n.re + gammaG + 0.5, n.im);\n      var twoPiSqrt = Math.sqrt(2 * Math.PI);\n      n.re += 0.5;\n      var result = pow(t, n);\n\n      if (result.im === 0) {\n        // sqrt(2*PI)*result\n        result.re *= twoPiSqrt;\n      } else if (result.re === 0) {\n        result.im *= twoPiSqrt;\n      } else {\n        result.re *= twoPiSqrt;\n        result.im *= twoPiSqrt;\n      }\n\n      var r = Math.exp(-t.re); // exp(-t)\n\n      t.re = r * Math.cos(-t.im);\n      t.im = r * Math.sin(-t.im);\n      return multiplyScalar(multiplyScalar(result, t), x);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n.isInteger()) {\n        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));\n      }\n\n      if (!n.isFinite()) {\n        return new _BigNumber(n.isNegative() ? NaN : Infinity);\n      }\n\n      throw new Error('Integer BigNumber expected');\n    },\n    'Array | Matrix': function ArrayMatrix(n) {\n      return deepMap(n, gamma);\n    }\n  });\n  /**\n   * Calculate factorial for a BigNumber\n   * @param {BigNumber} n\n   * @returns {BigNumber} Returns the factorial of n\n   */\n\n  function bigFactorial(n) {\n    if (n < 8) {\n      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);\n    }\n\n    var precision = config.precision + (Math.log(n.toNumber()) | 0);\n\n    var Big = _BigNumber.clone({\n      precision: precision\n    });\n\n    if (n % 2 === 1) {\n      return n.times(bigFactorial(new _BigNumber(n - 1)));\n    }\n\n    var p = n;\n    var prod = new Big(n);\n    var sum = n.toNumber();\n\n    while (p > 2) {\n      p -= 2;\n      sum += p;\n      prod = prod.times(sum);\n    }\n\n    return new _BigNumber(prod.toPrecision(_BigNumber.precision));\n  }\n\n  return gamma;\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/probability/gamma.js"],"names":["deepMap","factory","gammaG","gammaNumber","gammaP","name","dependencies","createGamma","_ref","typed","config","multiplyScalar","pow","_BigNumber","BigNumber","_Complex","Complex","gamma","number","n","im","re","x","i","length","real","den","Infinity","t","twoPiSqrt","Math","sqrt","PI","result","r","exp","cos","sin","isInteger","isNegative","isZero","bigFactorial","minus","isFinite","NaN","Error","ArrayMatrix","precision","log","toNumber","Big","clone","times","p","prod","sum","toPrecision"],"mappings":"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","sourcesContent":["import { deepMap } from '../../utils/collection';\nimport { factory } from '../../utils/factory';\nimport { gammaG, gammaNumber, gammaP } from '../../plain/number';\nvar name = 'gamma';\nvar dependencies = ['typed', 'config', 'multiplyScalar', 'pow', 'BigNumber', 'Complex'];\nexport var createGamma = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      multiplyScalar = _ref.multiplyScalar,\n      pow = _ref.pow,\n      _BigNumber = _ref.BigNumber,\n      _Complex = _ref.Complex;\n\n  /**\n   * Compute the gamma function of a value using Lanczos approximation for\n   * small values, and an extended Stirling approximation for large values.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.gamma(n)\n   *\n   * Examples:\n   *\n   *    math.gamma(5)       // returns 24\n   *    math.gamma(-0.5)    // returns -3.5449077018110335\n   *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i\n   *\n   * See also:\n   *\n   *    combinations, factorial, permutations\n   *\n   * @param {number | Array | Matrix} n   A real or complex number\n   * @return {number | Array | Matrix}    The gamma of `n`\n   */\n  var gamma = typed(name, {\n    number: gammaNumber,\n    Complex: function Complex(n) {\n      if (n.im === 0) {\n        return gamma(n.re);\n      }\n\n      n = new _Complex(n.re - 1, n.im);\n      var x = new _Complex(gammaP[0], 0);\n\n      for (var i = 1; i < gammaP.length; ++i) {\n        var real = n.re + i; // x += p[i]/(n+i)\n\n        var den = real * real + n.im * n.im;\n\n        if (den !== 0) {\n          x.re += gammaP[i] * real / den;\n          x.im += -(gammaP[i] * n.im) / den;\n        } else {\n          x.re = gammaP[i] < 0 ? -Infinity : Infinity;\n        }\n      }\n\n      var t = new _Complex(n.re + gammaG + 0.5, n.im);\n      var twoPiSqrt = Math.sqrt(2 * Math.PI);\n      n.re += 0.5;\n      var result = pow(t, n);\n\n      if (result.im === 0) {\n        // sqrt(2*PI)*result\n        result.re *= twoPiSqrt;\n      } else if (result.re === 0) {\n        result.im *= twoPiSqrt;\n      } else {\n        result.re *= twoPiSqrt;\n        result.im *= twoPiSqrt;\n      }\n\n      var r = Math.exp(-t.re); // exp(-t)\n\n      t.re = r * Math.cos(-t.im);\n      t.im = r * Math.sin(-t.im);\n      return multiplyScalar(multiplyScalar(result, t), x);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n.isInteger()) {\n        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));\n      }\n\n      if (!n.isFinite()) {\n        return new _BigNumber(n.isNegative() ? NaN : Infinity);\n      }\n\n      throw new Error('Integer BigNumber expected');\n    },\n    'Array | Matrix': function ArrayMatrix(n) {\n      return deepMap(n, gamma);\n    }\n  });\n  /**\n   * Calculate factorial for a BigNumber\n   * @param {BigNumber} n\n   * @returns {BigNumber} Returns the factorial of n\n   */\n\n  function bigFactorial(n) {\n    if (n < 8) {\n      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);\n    }\n\n    var precision = config.precision + (Math.log(n.toNumber()) | 0);\n\n    var Big = _BigNumber.clone({\n      precision: precision\n    });\n\n    if (n % 2 === 1) {\n      return n.times(bigFactorial(new _BigNumber(n - 1)));\n    }\n\n    var p = n;\n    var prod = new Big(n);\n    var sum = n.toNumber();\n\n    while (p > 2) {\n      p -= 2;\n      sum += p;\n      prod = prod.times(sum);\n    }\n\n    return new _BigNumber(prod.toPrecision(_BigNumber.precision));\n  }\n\n  return gamma;\n});"]},"metadata":{},"sourceType":"module"}
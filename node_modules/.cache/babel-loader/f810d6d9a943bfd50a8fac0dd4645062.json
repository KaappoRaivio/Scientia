{"ast":null,"code":"import { factory } from '../../utils/factory';\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'dotDivide', 'log', 'isNumeric'];\nexport var createKldivergence = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divide = _ref.divide,\n      sum = _ref.sum,\n      multiply = _ref.multiply,\n      dotDivide = _ref.dotDivide,\n      log = _ref.log,\n      isNumeric = _ref.isNumeric;\n  /**\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\n     *\n     * Syntax:\n     *\n     *     math.kldivergence(x, y)\n     *\n     * Examples:\n     *\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\n     *\n     *\n     * @param  {Array | Matrix} q    First vector\n     * @param  {Array | Matrix} p    Second vector\n     * @return {number}              Returns distance between q and p\n     */\n\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    } // Before calculation, apply normalization\n\n\n    var sumq = sum(q);\n\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n\n    var sump = sum(p);\n\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));\n\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/probability/kldivergence.js"],"names":["factory","name","dependencies","createKldivergence","_ref","typed","matrix","divide","sum","multiply","dotDivide","log","isNumeric","ArrayArray","q","p","_kldiv","MatrixArray","ArrayMatrix","MatrixMatrix","plength","size","length","qlength","Error","sumq","sump","qnorm","pnorm","result","Number","NaN"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory';\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'dotDivide', 'log', 'isNumeric'];\nexport var createKldivergence = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divide = _ref.divide,\n      sum = _ref.sum,\n      multiply = _ref.multiply,\n      dotDivide = _ref.dotDivide,\n      log = _ref.log,\n      isNumeric = _ref.isNumeric;\n\n  /**\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\n     *\n     * Syntax:\n     *\n     *     math.kldivergence(x, y)\n     *\n     * Examples:\n     *\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\n     *\n     *\n     * @param  {Array | Matrix} q    First vector\n     * @param  {Array | Matrix} p    Second vector\n     * @return {number}              Returns distance between q and p\n     */\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    } // Before calculation, apply normalization\n\n\n    var sumq = sum(q);\n\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n\n    var sump = sum(p);\n\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));\n\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { isMatrix } from '../../utils/is';\nimport { clone } from '../../utils/object';\nimport { format } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      unaryMinus = _ref.unaryMinus,\n      lup = _ref.lup;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var det = decomp.U[0][0];\n\n      for (var _i = 1; _i < rows; _i++) {\n        det = multiply(det, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\n    }\n  }\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/matrix/det.js"],"names":["isMatrix","clone","format","factory","name","dependencies","createDet","_ref","typed","matrix","subtract","multiply","unaryMinus","lup","any","x","det","size","Array","isArray","length","valueOf","RangeError","rows","cols","_det","decomp","U","_i","evenCycles","i","visited","j","cycleLen","p"],"mappings":"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","sourcesContent":["import { isMatrix } from '../../utils/is';\nimport { clone } from '../../utils/object';\nimport { format } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      unaryMinus = _ref.unaryMinus,\n      lup = _ref.lup;\n\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var det = decomp.U[0][0];\n\n      for (var _i = 1; _i < rows; _i++) {\n        det = multiply(det, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\n    }\n  }\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { factory } from '../../utils/factory';\nimport { deepMap } from '../../utils/collection';\nimport { nearlyEqual } from '../../utils/number';\nimport { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual';\nvar name = 'floor';\nvar dependencies = ['typed', 'config', 'round'];\nexport var createFloor = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      round = _ref.round;\n  /**\n   * Round a value towards minus infinity.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.floor(x)\n   *\n   * Examples:\n   *\n   *    math.floor(3.2)              // returns number 3\n   *    math.floor(3.8)              // returns number 3\n   *    math.floor(-4.2)             // returns number -5\n   *    math.floor(-4.7)             // returns number -5\n   *\n   *    const c = math.complex(3.2, -2.7)\n   *    math.floor(c)                // returns Complex 3 - 3i\n   *\n   *    math.floor([3.2, 3.8, -4.7]) // returns Array [3, 3, -5]\n   *\n   * See also:\n   *\n   *    ceil, fix, round\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value\n   */\n\n  var floor = typed('floor', {\n    number: function number(x) {\n      if (nearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return Math.floor(x);\n      }\n    },\n    Complex: function Complex(x) {\n      return x.floor();\n    },\n    BigNumber: function BigNumber(x) {\n      if (bigNearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return x.floor();\n      }\n    },\n    Fraction: function Fraction(x) {\n      return x.floor();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since floor(0) = 0\n      return deepMap(x, floor, true);\n    }\n  });\n  return floor;\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/arithmetic/floor.js"],"names":["factory","deepMap","nearlyEqual","bigNearlyEqual","name","dependencies","createFloor","_ref","typed","config","round","floor","number","x","epsilon","Math","Complex","BigNumber","Fraction","ArrayMatrix"],"mappings":"AAAA,SAASA,OAAT,QAAwB,qBAAxB;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,WAAT,QAA4B,oBAA5B;AACA,SAASA,WAAW,IAAIC,cAAxB,QAA8C,mCAA9C;AACA,IAAIC,IAAI,GAAG,OAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,OAApB,CAAnB;AACA,OAAO,IAAIC,WAAW,GAAG,eAAeN,OAAO,CAACI,IAAD,EAAOC,YAAP,EAAqB,UAAUE,IAAV,EAAgB;AAClF,MAAIC,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAA,MACIC,MAAM,GAAGF,IAAI,CAACE,MADlB;AAAA,MAEIC,KAAK,GAAGH,IAAI,CAACG,KAFjB;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,MAAIC,KAAK,GAAGH,KAAK,CAAC,OAAD,EAAU;AACzBI,IAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,CAAhB,EAAmB;AACzB,UAAIX,WAAW,CAACW,CAAD,EAAIH,KAAK,CAACG,CAAD,CAAT,EAAcJ,MAAM,CAACK,OAArB,CAAf,EAA8C;AAC5C,eAAOJ,KAAK,CAACG,CAAD,CAAZ;AACD,OAFD,MAEO;AACL,eAAOE,IAAI,CAACJ,KAAL,CAAWE,CAAX,CAAP;AACD;AACF,KAPwB;AAQzBG,IAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBH,CAAjB,EAAoB;AAC3B,aAAOA,CAAC,CAACF,KAAF,EAAP;AACD,KAVwB;AAWzBM,IAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBJ,CAAnB,EAAsB;AAC/B,UAAIV,cAAc,CAACU,CAAD,EAAIH,KAAK,CAACG,CAAD,CAAT,EAAcJ,MAAM,CAACK,OAArB,CAAlB,EAAiD;AAC/C,eAAOJ,KAAK,CAACG,CAAD,CAAZ;AACD,OAFD,MAEO;AACL,eAAOA,CAAC,CAACF,KAAF,EAAP;AACD;AACF,KAjBwB;AAkBzBO,IAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkBL,CAAlB,EAAqB;AAC7B,aAAOA,CAAC,CAACF,KAAF,EAAP;AACD,KApBwB;AAqBzB,sBAAkB,SAASQ,WAAT,CAAqBN,CAArB,EAAwB;AACxC;AACA,aAAOZ,OAAO,CAACY,CAAD,EAAIF,KAAJ,EAAW,IAAX,CAAd;AACD;AAxBwB,GAAV,CAAjB;AA0BA,SAAOA,KAAP;AACD,CA3D8C,CAAxC","sourcesContent":["import { factory } from '../../utils/factory';\nimport { deepMap } from '../../utils/collection';\nimport { nearlyEqual } from '../../utils/number';\nimport { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual';\nvar name = 'floor';\nvar dependencies = ['typed', 'config', 'round'];\nexport var createFloor = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      round = _ref.round;\n\n  /**\n   * Round a value towards minus infinity.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.floor(x)\n   *\n   * Examples:\n   *\n   *    math.floor(3.2)              // returns number 3\n   *    math.floor(3.8)              // returns number 3\n   *    math.floor(-4.2)             // returns number -5\n   *    math.floor(-4.7)             // returns number -5\n   *\n   *    const c = math.complex(3.2, -2.7)\n   *    math.floor(c)                // returns Complex 3 - 3i\n   *\n   *    math.floor([3.2, 3.8, -4.7]) // returns Array [3, 3, -5]\n   *\n   * See also:\n   *\n   *    ceil, fix, round\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value\n   */\n  var floor = typed('floor', {\n    number: function number(x) {\n      if (nearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return Math.floor(x);\n      }\n    },\n    Complex: function Complex(x) {\n      return x.floor();\n    },\n    BigNumber: function BigNumber(x) {\n      if (bigNearlyEqual(x, round(x), config.epsilon)) {\n        return round(x);\n      } else {\n        return x.floor();\n      }\n    },\n    Fraction: function Fraction(x) {\n      return x.floor();\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      // deep map collection, skip zeros since floor(0) = 0\n      return deepMap(x, floor, true);\n    }\n  });\n  return floor;\n});"]},"metadata":{},"sourceType":"module"}
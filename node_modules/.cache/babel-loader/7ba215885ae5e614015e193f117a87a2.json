{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { isAccessorNode, isFunctionAssignmentNode, isIndexNode, isNode, isSymbolNode } from '../../utils/is';\nimport { escape } from '../../utils/string';\nimport { hasOwnProperty } from '../../utils/object';\nimport { map } from '../../utils/array';\nimport { getSafeProperty, validateSafeMethod } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nimport { defaultTemplate, latexFunctions } from '../../utils/latex';\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nexport var createFunctionNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Node = _ref.Node,\n      SymbolNode = _ref.SymbolNode;\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!isNode(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    }); // TODO: deprecated since v3, remove some day\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = map(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (isSymbolNode(this.fn)) {\n      // we can statically determine whether the function has an rawArgs property\n      var _name = this.fn.name;\n      var fn = _name in math ? getSafeProperty(math, _name) : undefined;\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          return (_name in scope ? getSafeProperty(scope, _name) : fn)(rawArgs, math, _extends({}, scope, args));\n        };\n      } else {\n        // \"regular\" evaluation\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalFunctionNode(scope, args, context) {\n            return (_name in scope ? getSafeProperty(scope, _name) : fn)(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalFunctionNode(scope, args, context) {\n            return (_name in scope ? getSafeProperty(scope, _name) : fn)(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalFunctionNode(scope, args, context) {\n            return (_name in scope ? getSafeProperty(scope, _name) : fn).apply(null, map(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n    } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        validateSafeMethod(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n        return isRaw ? object[prop](_rawArgs, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : object[prop].apply(object, map(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n        var isRaw = fn && fn.rawArgs;\n        return isRaw ? fn(_rawArgs2, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : fn.apply(fn, map(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && _typeof(options.handler) === 'object' && hasOwnProperty(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = isFunctionAssignmentNode(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = new RegExp('\\\\$(?:\\\\{([a-z_][a-z_0-9]*)(?:\\\\[([0-9]+)\\\\])?\\\\}|\\\\$)', 'ig');\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch (_typeof(property)) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if (isNode(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if (isNode(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if (isNode(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && _typeof(options.handler) === 'object' && hasOwnProperty(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (latexFunctions[this.name]) {\n      latexConverter = latexFunctions[this.name];\n    } // toTex property on the function itself\n\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || _typeof(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch (_typeof(latexConverter)) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch (_typeof(latexConverter[args.length])) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/expression/node/FunctionNode.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","apply","isAccessorNode","isFunctionAssignmentNode","isIndexNode","isNode","isSymbolNode","escape","map","getSafeProperty","validateSafeMethod","factory","defaultTemplate","latexFunctions","name","dependencies","createFunctionNode","_ref","math","Node","SymbolNode","FunctionNode","fn","args","SyntaxError","TypeError","Array","isArray","every","defineProperty","get","bind","set","Error","deprecated","type","isFunctionNode","_compile","argNames","evalArgs","arg","_name","undefined","isRaw","rawArgs","evalFunctionNode","scope","context","evalArg0","_evalArg","evalArg1","evalArg","index","isObjectProperty","evalObject","object","prop","getObjectProperty","_rawArgs","evalFn","_rawArgs2","forEach","callback","_ifNode","clone","slice","nodeToString","toString","options","customString","handler","_toString","join","toJSON","mathjs","fromJSON","json","toHTML","expandTemplate","template","node","latex","regex","RegExp","inputPos","match","exec","substring","property","ReferenceError","toTex","nodeToTex","customTex","_toTex","latexConverter","customToTex","getIdentifier","isClass"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { isAccessorNode, isFunctionAssignmentNode, isIndexNode, isNode, isSymbolNode } from '../../utils/is';\nimport { escape } from '../../utils/string';\nimport { hasOwnProperty } from '../../utils/object';\nimport { map } from '../../utils/array';\nimport { getSafeProperty, validateSafeMethod } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nimport { defaultTemplate, latexFunctions } from '../../utils/latex';\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nexport var createFunctionNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Node = _ref.Node,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!isNode(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    }); // TODO: deprecated since v3, remove some day\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = map(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (isSymbolNode(this.fn)) {\n      // we can statically determine whether the function has an rawArgs property\n      var _name = this.fn.name;\n      var fn = _name in math ? getSafeProperty(math, _name) : undefined;\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          return (_name in scope ? getSafeProperty(scope, _name) : fn)(rawArgs, math, _extends({}, scope, args));\n        };\n      } else {\n        // \"regular\" evaluation\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalFunctionNode(scope, args, context) {\n            return (_name in scope ? getSafeProperty(scope, _name) : fn)(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalFunctionNode(scope, args, context) {\n            return (_name in scope ? getSafeProperty(scope, _name) : fn)(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalFunctionNode(scope, args, context) {\n            return (_name in scope ? getSafeProperty(scope, _name) : fn).apply(null, map(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n    } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        validateSafeMethod(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n        return isRaw ? object[prop](_rawArgs, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : object[prop].apply(object, map(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n        var isRaw = fn && fn.rawArgs;\n        return isRaw ? fn(_rawArgs2, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : fn.apply(fn, map(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && _typeof(options.handler) === 'object' && hasOwnProperty(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = isFunctionAssignmentNode(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = new RegExp('\\\\$(?:\\\\{([a-z_][a-z_0-9]*)(?:\\\\[([0-9]+)\\\\])?\\\\}|\\\\$)', 'ig');\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch (_typeof(property)) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if (isNode(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if (isNode(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if (isNode(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && _typeof(options.handler) === 'object' && hasOwnProperty(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (latexFunctions[this.name]) {\n      latexConverter = latexFunctions[this.name];\n    } // toTex property on the function itself\n\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || _typeof(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch (_typeof(latexConverter)) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch (_typeof(latexConverter[args.length])) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // allocate result\n\n  var parent = []; // (n)\n  // allocate workspace\n\n  var w = []; // (n + (ata ? m : 0))\n\n  var ancestor = 0; // first n entries in w\n\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n\n  return parent;\n}","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/sparse/csEtree.js"],"names":["csEtree","a","ata","aindex","_index","aptr","_ptr","asize","_size","m","n","parent","w","ancestor","prev","i","inext","k","p0","p1","p","r"],"mappings":"AAAA;;;;;;;;;AASA,OAAO,SAASA,OAAT,CAAiBC,CAAjB,EAAoBC,GAApB,EAAyB;AAC9B;AACA,MAAI,CAACD,CAAL,EAAQ;AACN,WAAO,IAAP;AACD,GAJ6B,CAI5B;;;AAGF,MAAIE,MAAM,GAAGF,CAAC,CAACG,MAAf;AACA,MAAIC,IAAI,GAAGJ,CAAC,CAACK,IAAb;AACA,MAAIC,KAAK,GAAGN,CAAC,CAACO,KAAd,CAT8B,CAST;;AAErB,MAAIC,CAAC,GAAGF,KAAK,CAAC,CAAD,CAAb;AACA,MAAIG,CAAC,GAAGH,KAAK,CAAC,CAAD,CAAb,CAZ8B,CAYZ;;AAElB,MAAII,MAAM,GAAG,EAAb,CAd8B,CAcb;AACjB;;AAEA,MAAIC,CAAC,GAAG,EAAR,CAjB8B,CAiBlB;;AAEZ,MAAIC,QAAQ,GAAG,CAAf,CAnB8B,CAmBZ;;AAElB,MAAIC,IAAI,GAAGJ,CAAX,CArB8B,CAqBhB;;AAEd,MAAIK,CAAJ,EAAOC,KAAP,CAvB8B,CAuBhB;;AAEd,MAAId,GAAJ,EAAS;AACP;AACA,SAAKa,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGN,CAAhB,EAAmBM,CAAC,EAApB,EAAwB;AACtBH,MAAAA,CAAC,CAACE,IAAI,GAAGC,CAAR,CAAD,GAAc,CAAC,CAAf;AACD;AACF,GA9B6B,CA8B5B;;;AAGF,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;AAC1B;AACAN,IAAAA,MAAM,CAACM,CAAD,CAAN,GAAY,CAAC,CAAb,CAF0B,CAEV;;AAEhBL,IAAAA,CAAC,CAACC,QAAQ,GAAGI,CAAZ,CAAD,GAAkB,CAAC,CAAnB,CAJ0B,CAIJ;;AAEtB,SAAK,IAAIC,EAAE,GAAGb,IAAI,CAACY,CAAD,CAAb,EAAkBE,EAAE,GAAGd,IAAI,CAACY,CAAC,GAAG,CAAL,CAA3B,EAAoCG,CAAC,GAAGF,EAA7C,EAAiDE,CAAC,GAAGD,EAArD,EAAyDC,CAAC,EAA1D,EAA8D;AAC5D;AACA,UAAIC,CAAC,GAAGlB,MAAM,CAACiB,CAAD,CAAd,CAF4D,CAEzC;;AAEnBL,MAAAA,CAAC,GAAGb,GAAG,GAAGU,CAAC,CAACE,IAAI,GAAGO,CAAR,CAAJ,GAAiBA,CAAxB,CAJ4D,CAIjC;;AAE3B,aAAON,CAAC,KAAK,CAAC,CAAP,IAAYA,CAAC,GAAGE,CAAvB,EAA0BF,CAAC,GAAGC,KAA9B,EAAqC;AACnC;AACAA,QAAAA,KAAK,GAAGJ,CAAC,CAACC,QAAQ,GAAGE,CAAZ,CAAT,CAFmC,CAEV;;AAEzBH,QAAAA,CAAC,CAACC,QAAQ,GAAGE,CAAZ,CAAD,GAAkBE,CAAlB,CAJmC,CAId;;AAErB,YAAID,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChBL,UAAAA,MAAM,CAACI,CAAD,CAAN,GAAYE,CAAZ;AACD;AACF;;AAED,UAAIf,GAAJ,EAAS;AACPU,QAAAA,CAAC,CAACE,IAAI,GAAGO,CAAR,CAAD,GAAcJ,CAAd;AACD;AACF;AACF;;AAED,SAAON,MAAP;AACD","sourcesContent":["/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // allocate result\n\n  var parent = []; // (n)\n  // allocate workspace\n\n  var w = []; // (n + (ata ? m : 0))\n\n  var ancestor = 0; // first n entries in w\n\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n\n  return parent;\n}"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { isMatrix } from '../../utils/is';\nimport { arraySize } from '../../utils/array';\nimport { isInteger } from '../../utils/number';\nimport { factory } from '../../utils/factory';\nvar name = 'diag';\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nexport var createDiag = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      DenseMatrix = _ref.DenseMatrix,\n      SparseMatrix = _ref.SparseMatrix;\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    Array: function Array(x) {\n      return _diag(x, 0, arraySize(x), null);\n    },\n    'Array, number': function ArrayNumber(x, k) {\n      return _diag(x, k, arraySize(x), null);\n    },\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\n      return _diag(x, k.toNumber(), arraySize(x), null);\n    },\n    'Array, string': function ArrayString(x, format) {\n      return _diag(x, 0, arraySize(x), format);\n    },\n    'Array, number, string': function ArrayNumberString(x, k, format) {\n      return _diag(x, k, arraySize(x), format);\n    },\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), arraySize(x), format);\n    },\n    Matrix: function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function MatrixNumber(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function MatrixString(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n\n  function _diag(x, k, size, format) {\n    if (!isInteger(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper];\n\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    } // create diagonal matrix\n\n\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if (isMatrix(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n\n        return dm;\n      }\n\n      return dm.valueOf();\n    } // vector size\n\n\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    var vector = []; // loop diagonal\n\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n\n    return format !== null ? matrix(vector) : vector;\n  }\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/matrix/diag.js"],"names":["isMatrix","arraySize","isInteger","factory","name","dependencies","createDiag","_ref","typed","matrix","DenseMatrix","SparseMatrix","Array","x","_diag","ArrayNumber","k","ArrayBigNumber","toNumber","ArrayString","format","ArrayNumberString","ArrayBigNumberString","Matrix","size","storage","MatrixNumber","MatrixBigNumber","MatrixString","MatrixNumberString","MatrixBigNumberString","TypeError","kSuper","kSub","length","_createDiagonalMatrix","_getDiagonal","RangeError","l","ms","concat","m","diagonal","valueOf","s","dm","n","Math","min","vector","i"],"mappings":"AAAA,SAASA,QAAT,QAAyB,gBAAzB;AACA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,SAAT,QAA0B,oBAA1B;AACA,SAASC,OAAT,QAAwB,qBAAxB;AACA,IAAIC,IAAI,GAAG,MAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,aAApB,EAAmC,cAAnC,CAAnB;AACA,OAAO,IAAIC,UAAU,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,UAAUE,IAAV,EAAgB;AACjF,MAAIC,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAA,MACIC,MAAM,GAAGF,IAAI,CAACE,MADlB;AAAA,MAEIC,WAAW,GAAGH,IAAI,CAACG,WAFvB;AAAA,MAGIC,YAAY,GAAGJ,IAAI,CAACI,YAHxB;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,SAAOH,KAAK,CAACJ,IAAD,EAAO;AACjB;AACAQ,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,CAAf,EAAkB;AACvB,aAAOC,KAAK,CAACD,CAAD,EAAI,CAAJ,EAAOZ,SAAS,CAACY,CAAD,CAAhB,EAAqB,IAArB,CAAZ;AACD,KAJgB;AAKjB,qBAAiB,SAASE,WAAT,CAAqBF,CAArB,EAAwBG,CAAxB,EAA2B;AAC1C,aAAOF,KAAK,CAACD,CAAD,EAAIG,CAAJ,EAAOf,SAAS,CAACY,CAAD,CAAhB,EAAqB,IAArB,CAAZ;AACD,KAPgB;AAQjB,wBAAoB,SAASI,cAAT,CAAwBJ,CAAxB,EAA2BG,CAA3B,EAA8B;AAChD,aAAOF,KAAK,CAACD,CAAD,EAAIG,CAAC,CAACE,QAAF,EAAJ,EAAkBjB,SAAS,CAACY,CAAD,CAA3B,EAAgC,IAAhC,CAAZ;AACD,KAVgB;AAWjB,qBAAiB,SAASM,WAAT,CAAqBN,CAArB,EAAwBO,MAAxB,EAAgC;AAC/C,aAAON,KAAK,CAACD,CAAD,EAAI,CAAJ,EAAOZ,SAAS,CAACY,CAAD,CAAhB,EAAqBO,MAArB,CAAZ;AACD,KAbgB;AAcjB,6BAAyB,SAASC,iBAAT,CAA2BR,CAA3B,EAA8BG,CAA9B,EAAiCI,MAAjC,EAAyC;AAChE,aAAON,KAAK,CAACD,CAAD,EAAIG,CAAJ,EAAOf,SAAS,CAACY,CAAD,CAAhB,EAAqBO,MAArB,CAAZ;AACD,KAhBgB;AAiBjB,gCAA4B,SAASE,oBAAT,CAA8BT,CAA9B,EAAiCG,CAAjC,EAAoCI,MAApC,EAA4C;AACtE,aAAON,KAAK,CAACD,CAAD,EAAIG,CAAC,CAACE,QAAF,EAAJ,EAAkBjB,SAAS,CAACY,CAAD,CAA3B,EAAgCO,MAAhC,CAAZ;AACD,KAnBgB;AAoBjBG,IAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBV,CAAhB,EAAmB;AACzB,aAAOC,KAAK,CAACD,CAAD,EAAI,CAAJ,EAAOA,CAAC,CAACW,IAAF,EAAP,EAAiBX,CAAC,CAACY,OAAF,EAAjB,CAAZ;AACD,KAtBgB;AAuBjB,sBAAkB,SAASC,YAAT,CAAsBb,CAAtB,EAAyBG,CAAzB,EAA4B;AAC5C,aAAOF,KAAK,CAACD,CAAD,EAAIG,CAAJ,EAAOH,CAAC,CAACW,IAAF,EAAP,EAAiBX,CAAC,CAACY,OAAF,EAAjB,CAAZ;AACD,KAzBgB;AA0BjB,yBAAqB,SAASE,eAAT,CAAyBd,CAAzB,EAA4BG,CAA5B,EAA+B;AAClD,aAAOF,KAAK,CAACD,CAAD,EAAIG,CAAC,CAACE,QAAF,EAAJ,EAAkBL,CAAC,CAACW,IAAF,EAAlB,EAA4BX,CAAC,CAACY,OAAF,EAA5B,CAAZ;AACD,KA5BgB;AA6BjB,sBAAkB,SAASG,YAAT,CAAsBf,CAAtB,EAAyBO,MAAzB,EAAiC;AACjD,aAAON,KAAK,CAACD,CAAD,EAAI,CAAJ,EAAOA,CAAC,CAACW,IAAF,EAAP,EAAiBJ,MAAjB,CAAZ;AACD,KA/BgB;AAgCjB,8BAA0B,SAASS,kBAAT,CAA4BhB,CAA5B,EAA+BG,CAA/B,EAAkCI,MAAlC,EAA0C;AAClE,aAAON,KAAK,CAACD,CAAD,EAAIG,CAAJ,EAAOH,CAAC,CAACW,IAAF,EAAP,EAAiBJ,MAAjB,CAAZ;AACD,KAlCgB;AAmCjB,iCAA6B,SAASU,qBAAT,CAA+BjB,CAA/B,EAAkCG,CAAlC,EAAqCI,MAArC,EAA6C;AACxE,aAAON,KAAK,CAACD,CAAD,EAAIG,CAAC,CAACE,QAAF,EAAJ,EAAkBL,CAAC,CAACW,IAAF,EAAlB,EAA4BJ,MAA5B,CAAZ;AACD;AArCgB,GAAP,CAAZ;AAuCA;;;;;;;;;;AAUA,WAASN,KAAT,CAAeD,CAAf,EAAkBG,CAAlB,EAAqBQ,IAArB,EAA2BJ,MAA3B,EAAmC;AACjC,QAAI,CAAClB,SAAS,CAACc,CAAD,CAAd,EAAmB;AACjB,YAAM,IAAIe,SAAJ,CAAc,sDAAd,CAAN;AACD;;AAED,QAAIC,MAAM,GAAGhB,CAAC,GAAG,CAAJ,GAAQA,CAAR,GAAY,CAAzB;AACA,QAAIiB,IAAI,GAAGjB,CAAC,GAAG,CAAJ,GAAQ,CAACA,CAAT,GAAa,CAAxB,CANiC,CAMN;;AAE3B,YAAQQ,IAAI,CAACU,MAAb;AACE,WAAK,CAAL;AACE,eAAOC,qBAAqB,CAACtB,CAAD,EAAIG,CAAJ,EAAOI,MAAP,EAAeI,IAAI,CAAC,CAAD,CAAnB,EAAwBS,IAAxB,EAA8BD,MAA9B,CAA5B;;AAEF,WAAK,CAAL;AACE,eAAOI,YAAY,CAACvB,CAAD,EAAIG,CAAJ,EAAOI,MAAP,EAAeI,IAAf,EAAqBS,IAArB,EAA2BD,MAA3B,CAAnB;AALJ;;AAQA,UAAM,IAAIK,UAAJ,CAAe,gDAAf,CAAN;AACD;;AAED,WAASF,qBAAT,CAA+BtB,CAA/B,EAAkCG,CAAlC,EAAqCI,MAArC,EAA6CkB,CAA7C,EAAgDL,IAAhD,EAAsDD,MAAtD,EAA8D;AAC5D;AACA,QAAIO,EAAE,GAAG,CAACD,CAAC,GAAGL,IAAL,EAAWK,CAAC,GAAGN,MAAf,CAAT;;AAEA,QAAIZ,MAAM,IAAIA,MAAM,KAAK,QAArB,IAAiCA,MAAM,KAAK,OAAhD,EAAyD;AACvD,YAAM,IAAIW,SAAJ,CAAc,uBAAuBS,MAAvB,CAA8BpB,MAA9B,EAAsC,IAAtC,CAAd,CAAN;AACD,KAN2D,CAM1D;;;AAGF,QAAIqB,CAAC,GAAGrB,MAAM,KAAK,QAAX,GAAsBT,YAAY,CAAC+B,QAAb,CAAsBH,EAAtB,EAA0B1B,CAA1B,EAA6BG,CAA7B,CAAtB,GAAwDN,WAAW,CAACgC,QAAZ,CAAqBH,EAArB,EAAyB1B,CAAzB,EAA4BG,CAA5B,CAAhE,CAT4D,CASoC;;AAEhG,WAAOI,MAAM,KAAK,IAAX,GAAkBqB,CAAlB,GAAsBA,CAAC,CAACE,OAAF,EAA7B;AACD;;AAED,WAASP,YAAT,CAAsBvB,CAAtB,EAAyBG,CAAzB,EAA4BI,MAA5B,EAAoCwB,CAApC,EAAuCX,IAAvC,EAA6CD,MAA7C,EAAqD;AACnD;AACA,QAAIhC,QAAQ,CAACa,CAAD,CAAZ,EAAiB;AACf;AACA,UAAIgC,EAAE,GAAGhC,CAAC,CAAC6B,QAAF,CAAW1B,CAAX,CAAT,CAFe,CAES;;AAExB,UAAII,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA,YAAIA,MAAM,KAAKyB,EAAE,CAACpB,OAAH,EAAf,EAA6B;AAC3B,iBAAOhB,MAAM,CAACoC,EAAD,EAAKzB,MAAL,CAAb;AACD;;AAED,eAAOyB,EAAP;AACD;;AAED,aAAOA,EAAE,CAACF,OAAH,EAAP;AACD,KAhBkD,CAgBjD;;;AAGF,QAAIG,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASJ,CAAC,CAAC,CAAD,CAAD,GAAOX,IAAhB,EAAsBW,CAAC,CAAC,CAAD,CAAD,GAAOZ,MAA7B,CAAR,CAnBmD,CAmBL;;AAE9C,QAAIiB,MAAM,GAAG,EAAb,CArBmD,CAqBlC;;AAEjB,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAApB,EAAuBI,CAAC,EAAxB,EAA4B;AAC1BD,MAAAA,MAAM,CAACC,CAAD,CAAN,GAAYrC,CAAC,CAACqC,CAAC,GAAGjB,IAAL,CAAD,CAAYiB,CAAC,GAAGlB,MAAhB,CAAZ;AACD,KAzBkD,CAyBjD;;;AAGF,WAAOZ,MAAM,KAAK,IAAX,GAAkBX,MAAM,CAACwC,MAAD,CAAxB,GAAmCA,MAA1C;AACD;AACF,CA3J6C,CAAvC","sourcesContent":["import { isMatrix } from '../../utils/is';\nimport { arraySize } from '../../utils/array';\nimport { isInteger } from '../../utils/number';\nimport { factory } from '../../utils/factory';\nvar name = 'diag';\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nexport var createDiag = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      DenseMatrix = _ref.DenseMatrix,\n      SparseMatrix = _ref.SparseMatrix;\n\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    Array: function Array(x) {\n      return _diag(x, 0, arraySize(x), null);\n    },\n    'Array, number': function ArrayNumber(x, k) {\n      return _diag(x, k, arraySize(x), null);\n    },\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\n      return _diag(x, k.toNumber(), arraySize(x), null);\n    },\n    'Array, string': function ArrayString(x, format) {\n      return _diag(x, 0, arraySize(x), format);\n    },\n    'Array, number, string': function ArrayNumberString(x, k, format) {\n      return _diag(x, k, arraySize(x), format);\n    },\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), arraySize(x), format);\n    },\n    Matrix: function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function MatrixNumber(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function MatrixString(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n\n  function _diag(x, k, size, format) {\n    if (!isInteger(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper];\n\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    } // create diagonal matrix\n\n\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if (isMatrix(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n\n        return dm;\n      }\n\n      return dm.valueOf();\n    } // vector size\n\n\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    var vector = []; // loop diagonal\n\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n\n    return format !== null ? matrix(vector) : vector;\n  }\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { isInteger } from '../../../utils/number';\nimport { factory } from '../../../utils/factory';\nimport { createCsSqr } from '../sparse/csSqr';\nimport { createCsLu } from '../sparse/csLu';\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createSlu = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose,\n      divideScalar = _ref.divideScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSqr = createCsSqr({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csLu = createCsLu({\n    abs: abs,\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract,\n    larger: larger,\n    largerEq: largerEq,\n    SparseMatrix: SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!isInteger(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/algebra/decomposition/slu.js"],"names":["isInteger","factory","createCsSqr","createCsLu","name","dependencies","createSlu","_ref","typed","abs","add","multiply","transpose","divideScalar","subtract","larger","largerEq","SparseMatrix","csSqr","csLu","SparseMatrixNumberNumber","a","order","threshold","Error","s","f","L","U","p","pinv","q","toString"],"mappings":"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","sourcesContent":["import { isInteger } from '../../../utils/number';\nimport { factory } from '../../../utils/factory';\nimport { createCsSqr } from '../sparse/csSqr';\nimport { createCsLu } from '../sparse/csLu';\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createSlu = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose,\n      divideScalar = _ref.divideScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSqr = createCsSqr({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csLu = createCsLu({\n    abs: abs,\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract,\n    larger: larger,\n    largerEq: largerEq,\n    SparseMatrix: SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!isInteger(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});"]},"metadata":{},"sourceType":"module"}
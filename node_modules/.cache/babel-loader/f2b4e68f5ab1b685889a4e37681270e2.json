{"ast":null,"code":"import { isArray, isBigNumber, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is';\nimport { arraySize, getArrayDataType, reshape, resize, unsqueeze, validate, validateIndex } from '../../utils/array';\nimport { format } from '../../utils/string';\nimport { isInteger } from '../../utils/number';\nimport { clone, deepStrictEqual } from '../../utils/object';\nimport { DimensionError } from '../../error/DimensionError';\nimport { factory } from '../../utils/factory';\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   */\n\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = clone(data._data);\n        this._size = clone(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size; // verify the dimensions of the array\n\n      validate(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data); // get the dimensions of the array\n\n      this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array\n\n      validate(this._data, this._size); // data type unknown\n\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n\n  DenseMatrix.prototype = new Matrix();\n  /**\n   * Create a new DenseMatrix\n   */\n\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  DenseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._data, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  DenseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check index\n\n\n    for (var x = 0; x < index.length; x++) {\n      validateIndex(index[x], this._size[x]);\n    }\n\n    var data = this._data;\n\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    }\n\n    return data;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n\n\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length < this._size.length) {\n      throw new DimensionError(index.length, this._size.length, '<');\n    }\n\n    var i, ii, indexI; // enlarge matrix when needed\n\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n\n    _fit(this, size, defaultValue); // traverse over the dimensions\n\n\n    var data = this._data;\n\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    } // set new value\n\n\n    indexI = index[index.length - 1];\n    validateIndex(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n\n\n  function _get(matrix, index) {\n    if (!isIndex(index)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = index.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n\n      if (size.length !== matrix._size.length) {\n        throw new DimensionError(size.length, matrix._size.length);\n      } // validate if any of the ranges in the index is out of range\n\n\n      var min = index.min();\n      var max = index.max();\n\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        validateIndex(min[i], matrix._size[i]);\n        validateIndex(max[i], matrix._size[i]);\n      } // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n\n\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n\n\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n\n\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = arraySize(submatrix);\n    }\n\n    if (isScalar) {\n      // set a scalar\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // enlarge matrix when needed\n\n\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n\n      _fit(matrix, size, defaultValue); // insert the sub matrix\n\n\n      var dims = iSize.length;\n      var dim = 0;\n\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n\n    return matrix;\n  }\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n\n\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isArray(size)) {\n      throw new TypeError('Array expected');\n    } // matrix to resize\n\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, size, defaultValue);\n  };\n\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data; // go deep\n\n      while (isArray(v)) {\n        v = v[0];\n      }\n\n      return v;\n    } // resize matrix\n\n\n    matrix._size = size.slice(0); // copy the array\n\n    matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = reshape(m._data, size);\n    m._size = size.slice(0);\n    return m;\n  };\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n\n\n  function _fit(matrix, size, defaultValue) {\n    var // copy the array\n    newSize = matrix._size.slice(0);\n\n    var changed = false; // add dimensions when needed\n\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    } // enlarge size when needed\n\n\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n\n\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: clone(this._data),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n\n\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n\n\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        return callback(value, index, me);\n      }\n    }; // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n\n\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n\n\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n\n    recurse(this._data, []);\n  };\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.toArray = function () {\n    return clone(this._data);\n  };\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.format = function (options) {\n    return format(this._data, options);\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.toString = function () {\n    return format(this._data);\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n\n\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix with the diagonal values.\n   */\n\n\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\n\n    var data = []; // loop rows\n\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                     The matrix size.\n   * @param {number | Matrix | Array } value The values for the diagonal.\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]          The default value for non-diagonal\n   * @param {string} [datatype]              The datatype for the diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // discover default value if needed\n\n\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    } // empty array\n\n\n    var data = []; // check we need to resize array\n\n    if (size.length > 0) {\n      // resize array\n      data = resize(data, size, defaultValue); // fill diagonal\n\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   * @param {Array} data     Matrix data\n   */\n\n\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n\n\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n\n      if (isArray(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n\n    return data;\n  }\n\n  return DenseMatrix;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/type/matrix/DenseMatrix.js"],"names":["isArray","isBigNumber","isIndex","isMatrix","isNumber","isString","typeOf","arraySize","getArrayDataType","reshape","resize","unsqueeze","validate","validateIndex","format","isInteger","clone","deepStrictEqual","DimensionError","factory","name","dependencies","createDenseMatrixClass","_ref","Matrix","DenseMatrix","data","datatype","SyntaxError","Error","type","_data","_size","_datatype","toArray","size","preprocess","TypeError","prototype","createDenseMatrix","isDenseMatrix","getDataType","storage","create","subset","index","replacement","defaultValue","arguments","length","_get","_set","get","x","i","ii","indexI","set","value","map","_fit","matrix","isScalar","min","max","_getSubmatrix","dims","dim","last","range","dimension","valueOf","child","submatrix","iSize","sSize","outer","_setSubmatrix","forEach","dataIndex","subIndex","copy","m","_resize","v","slice","newSize","changed","push","callback","me","recurse","concat","undefined","options","toString","toJSON","mathjs","diagonal","k","toNumber","kSuper","kSub","rows","columns","n","Math","s","_value","ms","mul","d","fromJSON","json","swapRows","j","_swapRows","vi","elem","isClass"],"mappings":"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","sourcesContent":["import { isArray, isBigNumber, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is';\nimport { arraySize, getArrayDataType, reshape, resize, unsqueeze, validate, validateIndex } from '../../utils/array';\nimport { format } from '../../utils/string';\nimport { isInteger } from '../../utils/number';\nimport { clone, deepStrictEqual } from '../../utils/object';\nimport { DimensionError } from '../../error/DimensionError';\nimport { factory } from '../../utils/factory';\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   */\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = clone(data._data);\n        this._size = clone(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size; // verify the dimensions of the array\n\n      validate(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data); // get the dimensions of the array\n\n      this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array\n\n      validate(this._data, this._size); // data type unknown\n\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n\n  DenseMatrix.prototype = new Matrix();\n  /**\n   * Create a new DenseMatrix\n   */\n\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  DenseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._data, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  DenseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check index\n\n\n    for (var x = 0; x < index.length; x++) {\n      validateIndex(index[x], this._size[x]);\n    }\n\n    var data = this._data;\n\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    }\n\n    return data;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n\n\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length < this._size.length) {\n      throw new DimensionError(index.length, this._size.length, '<');\n    }\n\n    var i, ii, indexI; // enlarge matrix when needed\n\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n\n    _fit(this, size, defaultValue); // traverse over the dimensions\n\n\n    var data = this._data;\n\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    } // set new value\n\n\n    indexI = index[index.length - 1];\n    validateIndex(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n\n\n  function _get(matrix, index) {\n    if (!isIndex(index)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = index.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n\n      if (size.length !== matrix._size.length) {\n        throw new DimensionError(size.length, matrix._size.length);\n      } // validate if any of the ranges in the index is out of range\n\n\n      var min = index.min();\n      var max = index.max();\n\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        validateIndex(min[i], matrix._size[i]);\n        validateIndex(max[i], matrix._size[i]);\n      } // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n\n\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n\n\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n\n\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = arraySize(submatrix);\n    }\n\n    if (isScalar) {\n      // set a scalar\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // enlarge matrix when needed\n\n\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n\n      _fit(matrix, size, defaultValue); // insert the sub matrix\n\n\n      var dims = iSize.length;\n      var dim = 0;\n\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n\n    return matrix;\n  }\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n\n\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isArray(size)) {\n      throw new TypeError('Array expected');\n    } // matrix to resize\n\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, size, defaultValue);\n  };\n\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data; // go deep\n\n      while (isArray(v)) {\n        v = v[0];\n      }\n\n      return v;\n    } // resize matrix\n\n\n    matrix._size = size.slice(0); // copy the array\n\n    matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = reshape(m._data, size);\n    m._size = size.slice(0);\n    return m;\n  };\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n\n\n  function _fit(matrix, size, defaultValue) {\n    var // copy the array\n    newSize = matrix._size.slice(0);\n\n    var changed = false; // add dimensions when needed\n\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    } // enlarge size when needed\n\n\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n\n\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: clone(this._data),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n\n\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n\n\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        return callback(value, index, me);\n      }\n    }; // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n\n\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n\n\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n\n    recurse(this._data, []);\n  };\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.toArray = function () {\n    return clone(this._data);\n  };\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.format = function (options) {\n    return format(this._data, options);\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.toString = function () {\n    return format(this._data);\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n\n\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix with the diagonal values.\n   */\n\n\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\n\n    var data = []; // loop rows\n\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                     The matrix size.\n   * @param {number | Matrix | Array } value The values for the diagonal.\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]          The default value for non-diagonal\n   * @param {string} [datatype]              The datatype for the diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // discover default value if needed\n\n\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    } // empty array\n\n\n    var data = []; // check we need to resize array\n\n    if (size.length > 0) {\n      // resize array\n      data = resize(data, size, defaultValue); // fill diagonal\n\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   * @param {Array} data     Matrix data\n   */\n\n\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n\n\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n\n      if (isArray(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n\n    return data;\n  }\n\n  return DenseMatrix;\n}, {\n  isClass: true\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import Bezier from \"bezier\";\nimport { mod } from \"mathjs\";\n\nclass Interpolator {\n  constructor(angle) {\n    this.previousData = 0;\n    this.currentData = 0;\n\n    if (angle === undefined) {\n      angle = false;\n    }\n\n    this.angle = angle;\n    this.dataPoints = [[new Date().getTime(), 0], [new Date().getTime() + 1000, 0]];\n  }\n\n  addDataPoint(timeStamp, data) {\n    this.dataPoints.push([timeStamp, data]);\n\n    while (this.dataPoints.length > 20) {\n      this.dataPoints.shift();\n    }\n  }\n\n  interpolate(timeStamp) {\n    let latest = this.dataPoints[this.dataPoints.length - 1][0];\n    let diff = timeStamp - latest;\n    let averageDiff = this.getAverageDeltaTime();\n    let progress = diff / averageDiff;\n    return this.getLatestPairSlope()(progress);\n  }\n\n  getAverageDeltaTime() {\n    let previous = this.dataPoints[0][0];\n    let diffs = [];\n\n    for (let i = 1; i < this.dataPoints.length; i++) {\n      let current = this.dataPoints[i][0];\n      let diff = current - previous;\n      diffs.push(diff);\n      previous = current;\n    }\n\n    return diffs.reduce((a, b) => a + b, 0) / diffs.length;\n  }\n\n  deltaAngle(a, b) {\n    let diff = a - b;\n    return (diff + Math.PI) % (2 * Math.PI) - Math.PI;\n  }\n\n  normalizeAngle(a) {\n    if (a >= Math.PI) {\n      return a - 2 * Math.PI;\n    } else {\n      return a;\n    }\n  }\n\n  getLatestPairSlope() {\n    let latest = this.dataPoints[this.dataPoints.length - 1];\n    let other = this.dataPoints[this.dataPoints.length - 2]; // let bezier = new Bezier()\n\n    return x => {\n      let deltaX = latest[0] - other[0];\n      let deltaY = 0;\n      let shorten = false;\n\n      if (this.angle) {\n        let delta1 = this.deltaAngle(latest[1], other[1]);\n        let delta2 = -this.deltaAngle(other[1], latest[1]);\n        shorten = delta1 === delta2;\n        console.log(delta1, delta2);\n        deltaY = Math.abs(delta1) < Math.abs(delta2) ? delta1 : delta2;\n      } else {\n        deltaY = latest[1] - other[1];\n      }\n\n      let k = deltaY / deltaX * 2000;\n      let b = other[1];\n\n      if (this.angle) {\n        let y = mod(k * x + b, 2 * Math.PI);\n        let t = mod(latest[1], 2 * Math.PI); // if (shorten) {\n        // return this.magicTruthTable(k, y, t)(y, t)\n        // } else {\n        // console.log(\"moi\")\n        // return k > 0 ? Math.min(y, t) : Math.max(y, t)\n\n        y = this.normalizeAngle(y);\n        t = this.normalizeAngle(t);\n        return k > 0 ? Math.min(y, t) : Math.max(y, t); // }\n      } else {\n        return k > 0 ? Math.min(k * x + b, latest[1]) : Math.max(k * x + b, latest[1]);\n      }\n    };\n  }\n\n  magicTruthTable(k, y, t) {\n    let cond = [k > 0, y < Math.PI, t > Math.PI].map(k => k ? \"1\" : \"0\").join(\"\");\n    const table = {\n      \"000\": Math.min,\n      \"001\": Math.max,\n      \"010\": Math.min,\n      \"011\": Math.min,\n      \"100\": Math.max,\n      \"101\": Math.max,\n      \"110\": Math.min,\n      \"111\": Math.max\n    };\n    return table[cond];\n  }\n\n}\n\nexport default Interpolator;","map":{"version":3,"sources":["/home/kaappo/git/kments/src/components/misc/interpolate.js"],"names":["Bezier","mod","Interpolator","constructor","angle","previousData","currentData","undefined","dataPoints","Date","getTime","addDataPoint","timeStamp","data","push","length","shift","interpolate","latest","diff","averageDiff","getAverageDeltaTime","progress","getLatestPairSlope","previous","diffs","i","current","reduce","a","b","deltaAngle","Math","PI","normalizeAngle","other","x","deltaX","deltaY","shorten","delta1","delta2","console","log","abs","k","y","t","min","max","magicTruthTable","cond","map","join","table"],"mappings":"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","sourcesContent":["import Bezier from \"bezier\";\nimport { mod } from \"mathjs\";\n\n\nclass Interpolator {\n    constructor (angle) {\n        this.previousData = 0;\n        this.currentData = 0;\n\n        if (angle === undefined) {\n            angle = false;\n        }\n\n        this.angle = angle;\n\n\n        this.dataPoints = [\n            [new Date().getTime(), 0],\n            [new Date().getTime() + 1000, 0]\n        ];\n    }\n\n    addDataPoint (timeStamp, data) {\n        this.dataPoints.push([timeStamp, data]);\n        while (this.dataPoints.length > 20) {\n            this.dataPoints.shift();\n        }\n        \n    }\n\n    interpolate (timeStamp) {\n        let latest = this.dataPoints[this.dataPoints.length - 1][0];\n        let diff = timeStamp - latest;\n\n        let averageDiff = this.getAverageDeltaTime();\n\n        let progress = diff / averageDiff;\n        return this.getLatestPairSlope()(progress)\n    }\n\n    getAverageDeltaTime () {\n        let previous = this.dataPoints[0][0];\n        let diffs = [];\n\n        for (let i = 1; i < this.dataPoints.length; i++) {\n            let current = this.dataPoints[i][0];\n            \n            let diff = current - previous;\n            diffs.push(diff);\n\n            previous = current;\n        }\n        return diffs.reduce((a, b) => a + b, 0) / diffs.length;\n    }\n\n    deltaAngle (a, b) {\n        let diff = a - b;\n        return (diff + Math.PI) % (2 * Math.PI) - Math.PI\n    }\n\n    normalizeAngle (a) {\n        if (a >= Math.PI) {\n            return a - 2 * Math.PI;\n        } else {\n            return a;\n        }\n    }\n\n    getLatestPairSlope () {\n        let latest = this.dataPoints[this.dataPoints.length - 1]\n        let other = this.dataPoints[this.dataPoints.length - 2]\n\n        // let bezier = new Bezier()\n\n        return (x) => {\n            let deltaX = latest[0] - other[0];\n            \n            let deltaY = 0;\n            let shorten = false;\n\n            if (this.angle) {\n                let delta1 = this.deltaAngle(latest[1], other[1])\n                let delta2 = -this.deltaAngle(other[1], latest[1])\n                \n                shorten = delta1 === delta2;\n\n                console.log(delta1, delta2)\n                deltaY = Math.abs(delta1) < Math.abs(delta2) ? delta1 : delta2\n            } else {\n                deltaY = latest[1] - other[1];\n            }\n\n            let k = deltaY / deltaX * 2000;\n            let b = other[1];\n\n            if (this.angle) {\n                let y = mod(k*x + b, 2 * Math.PI);\n                let t = mod(latest[1], 2 * Math.PI);\n                \n                // if (shorten) {\n                    // return this.magicTruthTable(k, y, t)(y, t)\n                // } else {\n                    // console.log(\"moi\")\n                // return k > 0 ? Math.min(y, t) : Math.max(y, t)\n                y = this.normalizeAngle(y);\n                t = this.normalizeAngle(t);\n                return k > 0 ? Math.min(y, t) : Math.max(y, t)\n                // }\n            } else {\n                return k > 0 ? Math.min(k * x + b, latest[1]) : Math.max(k * x + b, latest[1])\n            }\n        }\n    }\n\n    magicTruthTable (k, y, t) {\n        let cond = [k > 0, y < Math.PI, t > Math.PI].map(k => k ? \"1\" : \"0\").join(\"\");\n        \n        const table = {\n            \"000\": Math.min,\n            \"001\": Math.max,\n            \"010\": Math.min,\n            \"011\": Math.min,\n            \"100\": Math.max,\n            \"101\": Math.max,\n            \"110\": Math.min,\n            \"111\": Math.max,\n        };\n\n        return table[cond];\n    }\n}\n\nexport default Interpolator;"]},"metadata":{},"sourceType":"module"}
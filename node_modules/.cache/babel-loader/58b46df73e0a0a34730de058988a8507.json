{"ast":null,"code":"/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n})(this, function () {\n  function ok() {\n    return true;\n  }\n\n  function notOk() {\n    return false;\n  }\n\n  function undef() {\n    return undefined;\n  }\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n  // create a new instance of typed-function\n\n\n  function create() {\n    // data type tests\n    var _types = [{\n      name: 'number',\n      test: function (x) {\n        return typeof x === 'number';\n      }\n    }, {\n      name: 'string',\n      test: function (x) {\n        return typeof x === 'string';\n      }\n    }, {\n      name: 'boolean',\n      test: function (x) {\n        return typeof x === 'boolean';\n      }\n    }, {\n      name: 'Function',\n      test: function (x) {\n        return typeof x === 'function';\n      }\n    }, {\n      name: 'Array',\n      test: Array.isArray\n    }, {\n      name: 'Date',\n      test: function (x) {\n        return x instanceof Date;\n      }\n    }, {\n      name: 'RegExp',\n      test: function (x) {\n        return x instanceof RegExp;\n      }\n    }, {\n      name: 'Object',\n      test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object;\n      }\n    }, {\n      name: 'null',\n      test: function (x) {\n        return x === null;\n      }\n    }, {\n      name: 'undefined',\n      test: function (x) {\n        return x === undefined;\n      }\n    }];\n    var anyType = {\n      name: 'any',\n      test: ok\n    }; // types which need to be ignored\n\n    var _ignore = []; // type conversions\n\n    var _conversions = []; // This is a temporary object, will be replaced with a typed function at the end\n\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n\n    function findTypeByName(typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') {\n        // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n      throw new TypeError('Unknown type \"' + typeName + '\"' + (hint ? '. Did you mean \"' + hint.name + '\"?' : ''));\n    }\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n\n\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n\n\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n\n\n    function find(fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      } // normalize input\n\n\n      var arr;\n\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      } else if (Array.isArray(signature)) {\n        arr = signature;\n      } else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(','); // find an exact match\n\n      var match = fn.signatures[str];\n\n      if (match) {\n        return match;\n      } // TODO: extend find to match non-exact signatures\n\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n\n\n    function convert(value, type) {\n      var from = findTypeName(value); // check conversion is needed\n\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n\n\n    function stringifyParams(params) {\n      return params.map(function (param) {\n        var typeNames = param.types.map(getTypeName);\n        return (param.restParam ? '...' : '') + typeNames.join('|');\n      }).join(',');\n    }\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n\n\n    function parseParam(param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';\n      var typeNames = types.split('|').map(trim).filter(notEmpty).filter(notIgnore);\n      var matchingConversions = filterConversions(conversions, typeNames);\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n\n\n    function parseSignature(signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature.split(',').map(trim).map(function (param, index, array) {\n          var parsedParam = parseParam(param, conversions);\n\n          if (parsedParam.restParam && index !== array.length - 1) {\n            throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' + 'only allowed for the last parameter');\n          }\n\n          return parsedParam;\n        });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n\n\n    function hasRestParam(params) {\n      var param = last(params);\n      return param ? param.restParam : false;\n    }\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n\n\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n\n\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      } else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      } else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        };\n      } else {\n        // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        });\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n      }\n    }\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n\n\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n\n          return testRestParam(args) && args.length >= varIndex + 1;\n        };\n      } else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        } else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        } else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        } else {\n          // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n\n\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;\n    }\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n\n\n    function getExpectedTypeNames(signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];\n      return types.map(getTypeName);\n    }\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n\n\n    function getTypeName(type) {\n      return type.name;\n    }\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n\n\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n\n\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n      return typeNames.indexOf('any') !== -1 ? ['any'] : typeNames;\n    }\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n\n\n    function createError(name, args, signatures) {\n      var err, expected;\n\n      var _name = name || 'unnamed'; // test for wrong type at some index\n\n\n      var matchingSignatures = signatures;\n      var index;\n\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n            err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            };\n            return err;\n          }\n        } else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      } // test for too few arguments\n\n\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        };\n        return err;\n      } // test for too many arguments\n\n\n      var maxLength = Math.max.apply(null, lengths);\n\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        };\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') + '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      };\n      return err;\n    }\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n\n\n    function getLowestTypeIndex(param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n\n\n    function getLowestConversionIndex(param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n\n\n    function compareParams(param1, param2) {\n      var c; // compare having a rest parameter or not\n\n      c = param1.restParam - param2.restParam;\n\n      if (c !== 0) {\n        return c;\n      } // compare having conversions or not\n\n\n      c = hasConversions(param1) - hasConversions(param2);\n\n      if (c !== 0) {\n        return c;\n      } // compare the index of the types\n\n\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n\n      if (c !== 0) {\n        return c;\n      } // compare the index of any conversion\n\n\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n\n\n    function compareSignatures(signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c; // compare whether the params have conversions at all or not\n\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);\n\n      if (c !== 0) {\n        return c;\n      } // next compare whether the params have conversions one by one\n\n\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n\n        if (c !== 0) {\n          return c;\n        }\n      } // compare the types of the params one by one\n\n\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n\n        if (c !== 0) {\n          return c;\n        }\n      } // compare the number of params\n\n\n      return signature1.params.length - signature2.params.length;\n    }\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n\n\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n\n\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn; // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion);\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(null, args);\n        };\n      }\n\n      var fnPreprocess = fnConvert;\n\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams() {\n          return fnConvert.apply(null, slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        };\n      }\n\n      return fnPreprocess;\n    }\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n\n\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      }); // create optimized conversion functions depending on the number of conversions\n\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          };\n\n        case 1:\n          test0 = tests[0];\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg);\n            }\n\n            return arg;\n          };\n\n        case 2:\n          test0 = tests[0];\n          test1 = tests[1];\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg);\n            }\n\n            if (test1(arg)) {\n              return conversion1(arg);\n            }\n\n            return arg;\n          };\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n\n            return arg;\n          };\n      }\n    }\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n\n\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n      return signaturesMap;\n    }\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n\n\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index];\n          var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;\n          var typeGroups;\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType);\n            typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];\n          } else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type];\n            });\n          } // recurse over the groups with types\n\n\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n        } else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: typeIndex === params.length - 1 && hasRestParam(params)\n            };\n          });\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n\n\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n      return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;\n    }\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n\n\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      } // parse the signatures, and check for conflicts\n\n\n      var parsedSignatures = [];\n      Object.keys(signaturesMap).map(function (signature) {\n        return parseSignature(signature, signaturesMap[signature], typed.conversions);\n      }).filter(notNull).forEach(function (parsedSignature) {\n        // check whether this parameter conflicts with already parsed signatures\n        var conflictingSignature = findInArray(parsedSignatures, function (s) {\n          return hasConflictingParams(s, parsedSignature);\n        });\n\n        if (conflictingSignature) {\n          throw new TypeError('Conflicting signatures \"' + stringifyParams(conflictingSignature.params) + '\" and \"' + stringifyParams(parsedSignature.params) + '\".');\n        }\n\n        parsedSignatures.push(parsedSignature);\n      }); // split and filter the types of the signatures, and then order them\n\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n      signatures.sort(compareSignatures); // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5; // compile the tests\n\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk; // compile the functions\n\n      var fns = signatures.map(function (signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn);\n      });\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1; // simple and generic, but also slow\n\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(null, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }; // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n\n\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) {\n          return fn0.apply(null, arguments);\n        }\n\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) {\n          return fn1.apply(null, arguments);\n        }\n\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) {\n          return fn2.apply(null, arguments);\n        }\n\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) {\n          return fn3.apply(null, arguments);\n        }\n\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) {\n          return fn4.apply(null, arguments);\n        }\n\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) {\n          return fn5.apply(null, arguments);\n        }\n\n        return generic.apply(null, arguments);\n      }; // attach name the typed function\n\n\n      try {\n        Object.defineProperty(fn, 'name', {\n          value: name\n        });\n      } catch (err) {} // old browsers do not support Object.defineProperty and some don't support setting the name property\n      // the function name is not essential for the functioning, it's mostly useful for debugging,\n      // so it's fine to have unnamed functions.\n      // attach signatures to the function\n\n\n      fn.signatures = createSignaturesMap(signatures);\n      return fn;\n    }\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n\n\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n\n\n    function trim(str) {\n      return str.trim();\n    }\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n\n\n    function notEmpty(str) {\n      return !!str;\n    }\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n\n\n    function notNull(value) {\n      return value !== null;\n    }\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n\n\n    function isInvalidParam(param) {\n      return param.types.length === 0;\n    }\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n\n\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n\n\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n\n\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n\n\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n\n\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n\n\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n\n\n    function uniq(arr) {\n      var entries = {};\n\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n\n      return Object.keys(entries);\n    }\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n\n\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n\n\n    function getName(fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i]; // check whether the names are the same when defined\n\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          } else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    } // extract and merge all signatures of a list with typed functions\n\n\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {\n            signature: _signature\n          };\n          throw err; // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i]; // test whether this is a typed-function\n\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        } else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        } else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {\n            index: i\n          };\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return;\n          }\n        }\n      }\n\n      typed.types.push(type);\n    }; // add a conversion\n\n\n    typed.addConversion = function (conversion) {\n      if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/typed-function/typed-function.js"],"names":["root","factory","define","amd","exports","module","typed","ok","notOk","undef","undefined","create","_types","name","test","x","Array","isArray","Date","RegExp","constructor","Object","anyType","_ignore","_conversions","types","conversions","ignore","findTypeByName","typeName","entry","findInArray","hint","toLowerCase","TypeError","findTypeIndex","type","indexOf","findTypeName","value","find","fn","signature","signatures","arr","split","i","length","trim","str","join","match","convert","from","conversion","to","Error","stringifyParams","params","map","param","typeNames","getTypeName","restParam","parseParam","slice","filter","notEmpty","notIgnore","matchingConversions","filterConversions","exactTypes","typeIndex","conversionIndex","convertibleTypes","concat","parseSignature","index","array","parsedParam","SyntaxError","some","isInvalidParam","hasRestParam","last","hasConversions","compileTest","test0","test1","or","tests","compileTests","initial","varIndex","lastTest","testRestParam","args","testArgs","getParamAtIndex","getExpectedTypeNames","excludeConversions","isExactType","mergeExpectedParams","uniq","flatMap","createError","err","expected","_name","matchingSignatures","nextMatchingDefs","actualType","data","category","actual","lengths","Infinity","Math","min","apply","maxLength","max","expectedLength","getLowestTypeIndex","getLowestConversionIndex","compareParams","param1","param2","c","compareSignatures","signature1","signature2","len","matches","forEach","keys","compileArgsPreprocessing","fnConvert","compiledConversions","compileArgConversion","convertArgs","arguments","fnPreprocess","offset","preprocessRestParams","conversion0","conversion1","push","convertArg","arg","createSignaturesMap","signaturesMap","splitParams","ignoreConversionTypes","_splitParams","filteredTypes","typeGroups","typeGroup","splittedParams","hasConflictingParams","ii","typesNames1","typesNames2","hasOverlap","len1","len2","restParam1","restParam2","createTypedFunction","parsedSignatures","notNull","parsedSignature","conflictingSignature","s","sort","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fns","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","generic","arg0","arg1","defineProperty","start","end","prototype","call","contains","item","array1","array2","entries","callback","getName","extractSignatures","validateUnique","_signature","_fn","hasOwnProperty","addType","beforeObjectTest","splice","addConversion"],"mappings":"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","sourcesContent":["/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(null, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(null,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn)\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(null, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(null, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(null, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(null, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(null, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(null, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(null, arguments); }\n\n        return generic.apply(null, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));"]},"metadata":{},"sourceType":"script"}
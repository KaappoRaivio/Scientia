{"ast":null,"code":"import { isNode, isSymbolNode } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nimport { getPrecedence } from '../operators';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!isNode(start)) throw new TypeError('Node expected');\n    if (!isNode(end)) throw new TypeError('Node expected');\n    if (step && !isNode(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return isSymbolNode(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate an RangeNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RangeNode}\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/node/RangeNode.js"],"names":["isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","RangeNode","start","end","step","SyntaxError","TypeError","arguments","length","Error","prototype","type","isRangeNode","needsEnd","endSymbols","filter","node","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","calculateNecessaryParentheses","parenthesis","precedence","parens","startPrecedence","stepPrecedence","endPrecedence","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"mappings":"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","sourcesContent":["import { isNode, isSymbolNode } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nimport { getPrecedence } from '../operators';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!isNode(start)) throw new TypeError('Node expected');\n    if (!isNode(end)) throw new TypeError('Node expected');\n    if (step && !isNode(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return isSymbolNode(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate an RangeNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RangeNode}\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
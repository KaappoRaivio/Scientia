{"ast":null,"code":"/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../../utils/is';\nimport typedFunction from 'typed-function';\nimport { digits } from '../../utils/number';\nimport { factory } from '../../utils/factory'; // returns a new instance of typed-function\n\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = typedFunction.create;\n  return typedFunction;\n};\n\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nexport var createTyped = /* #__PURE__ */factory('typed', dependencies, function createTyped(_ref) {\n  var BigNumber = _ref.BigNumber,\n      Complex = _ref.Complex,\n      DenseMatrix = _ref.DenseMatrix,\n      Fraction = _ref.Fraction; // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: isNumber\n  }, {\n    name: 'Complex',\n    test: isComplex\n  }, {\n    name: 'BigNumber',\n    test: isBigNumber\n  }, {\n    name: 'Fraction',\n    test: isFraction\n  }, {\n    name: 'Unit',\n    test: isUnit\n  }, {\n    name: 'string',\n    test: isString\n  }, {\n    name: 'Chain',\n    test: isChain\n  }, {\n    name: 'Array',\n    test: isArray\n  }, {\n    name: 'Matrix',\n    test: isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: isSparseMatrix\n  }, {\n    name: 'Range',\n    test: isRange\n  }, {\n    name: 'Index',\n    test: isIndex\n  }, {\n    name: 'boolean',\n    test: isBoolean\n  }, {\n    name: 'ResultSet',\n    test: isResultSet\n  }, {\n    name: 'Help',\n    test: isHelp\n  }, {\n    name: 'function',\n    test: isFunction\n  }, {\n    name: 'Date',\n    test: isDate\n  }, {\n    name: 'RegExp',\n    test: isRegExp\n  }, {\n    name: 'null',\n    test: isNull\n  }, {\n    name: 'undefined',\n    test: isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: isIndexNode\n  }, {\n    name: 'Node',\n    test: isNode\n  }, {\n    name: 'ObjectNode',\n    test: isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: isSymbolNode\n  }, {\n    name: 'Object',\n    test: isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n\n      if (digits(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      var f = new Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\n\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\n\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\n\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\n\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/core/function/typed.js"],"names":["isAccessorNode","isArray","isArrayNode","isAssignmentNode","isBigNumber","isBlockNode","isBoolean","isChain","isComplex","isConditionalNode","isConstantNode","isDate","isDenseMatrix","isFraction","isFunction","isFunctionAssignmentNode","isFunctionNode","isHelp","isIndex","isIndexNode","isMatrix","isNode","isNull","isNumber","isObject","isObjectNode","isOperatorNode","isParenthesisNode","isRange","isRangeNode","isRegExp","isResultSet","isSparseMatrix","isString","isSymbolNode","isUndefined","isUnit","typedFunction","digits","factory","_createTyped2","_createTyped","create","dependencies","createTyped","_ref","BigNumber","Complex","DenseMatrix","Fraction","typed","types","name","test","conversions","from","to","convert","x","throwNoBignumber","TypeError","throwNoComplex","toNumber","valueOf","throwNoFraction","f","n","Number","isNaN","Error","err","String","array","throwNoMatrix","matrix","concat"],"mappings":"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","sourcesContent":["/**\n * Create a typed-function which checks the types of the arguments and\n * can match them against multiple provided signatures. The typed-function\n * automatically converts inputs in order to find a matching signature.\n * Typed functions throw informative errors in case of wrong input arguments.\n *\n * See the library [typed-function](https://github.com/josdejong/typed-function)\n * for detailed documentation.\n *\n * Syntax:\n *\n *     math.typed(name, signatures) : function\n *     math.typed(signatures) : function\n *\n * Examples:\n *\n *     // create a typed function with multiple types per argument (type union)\n *     const fn2 = typed({\n *       'number | boolean': function (b) {\n *         return 'b is a number or boolean'\n *       },\n *       'string, number | boolean': function (a, b) {\n *         return 'a is a string, b is a number or boolean'\n *       }\n *     })\n *\n *     // create a typed function with an any type argument\n *     const log = typed({\n *       'string, any': function (event, data) {\n *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))\n *       }\n *     })\n *\n * @param {string} [name]                          Optional name for the typed-function\n * @param {Object<string, function>} signatures   Object with one or multiple function signatures\n * @returns {function} The created typed-function.\n */\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../../utils/is';\nimport typedFunction from 'typed-function';\nimport { digits } from '../../utils/number';\nimport { factory } from '../../utils/factory'; // returns a new instance of typed-function\n\nvar _createTyped2 = function _createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped2 = typedFunction.create;\n  return typedFunction;\n};\n\nvar dependencies = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];\n/**\n * Factory function for creating a new typed instance\n * @param {Object} dependencies   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\n\nexport var createTyped = /* #__PURE__ */factory('typed', dependencies, function createTyped(_ref) {\n  var BigNumber = _ref.BigNumber,\n      Complex = _ref.Complex,\n      DenseMatrix = _ref.DenseMatrix,\n      Fraction = _ref.Fraction;\n\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n  // get a new instance of typed-function\n  var typed = _createTyped2(); // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n\n\n  typed.types = [{\n    name: 'number',\n    test: isNumber\n  }, {\n    name: 'Complex',\n    test: isComplex\n  }, {\n    name: 'BigNumber',\n    test: isBigNumber\n  }, {\n    name: 'Fraction',\n    test: isFraction\n  }, {\n    name: 'Unit',\n    test: isUnit\n  }, {\n    name: 'string',\n    test: isString\n  }, {\n    name: 'Chain',\n    test: isChain\n  }, {\n    name: 'Array',\n    test: isArray\n  }, {\n    name: 'Matrix',\n    test: isMatrix\n  }, {\n    name: 'DenseMatrix',\n    test: isDenseMatrix\n  }, {\n    name: 'SparseMatrix',\n    test: isSparseMatrix\n  }, {\n    name: 'Range',\n    test: isRange\n  }, {\n    name: 'Index',\n    test: isIndex\n  }, {\n    name: 'boolean',\n    test: isBoolean\n  }, {\n    name: 'ResultSet',\n    test: isResultSet\n  }, {\n    name: 'Help',\n    test: isHelp\n  }, {\n    name: 'function',\n    test: isFunction\n  }, {\n    name: 'Date',\n    test: isDate\n  }, {\n    name: 'RegExp',\n    test: isRegExp\n  }, {\n    name: 'null',\n    test: isNull\n  }, {\n    name: 'undefined',\n    test: isUndefined\n  }, {\n    name: 'AccessorNode',\n    test: isAccessorNode\n  }, {\n    name: 'ArrayNode',\n    test: isArrayNode\n  }, {\n    name: 'AssignmentNode',\n    test: isAssignmentNode\n  }, {\n    name: 'BlockNode',\n    test: isBlockNode\n  }, {\n    name: 'ConditionalNode',\n    test: isConditionalNode\n  }, {\n    name: 'ConstantNode',\n    test: isConstantNode\n  }, {\n    name: 'FunctionNode',\n    test: isFunctionNode\n  }, {\n    name: 'FunctionAssignmentNode',\n    test: isFunctionAssignmentNode\n  }, {\n    name: 'IndexNode',\n    test: isIndexNode\n  }, {\n    name: 'Node',\n    test: isNode\n  }, {\n    name: 'ObjectNode',\n    test: isObjectNode\n  }, {\n    name: 'OperatorNode',\n    test: isOperatorNode\n  }, {\n    name: 'ParenthesisNode',\n    test: isParenthesisNode\n  }, {\n    name: 'RangeNode',\n    test: isRangeNode\n  }, {\n    name: 'SymbolNode',\n    test: isSymbolNode\n  }, {\n    name: 'Object',\n    test: isObject\n  } // order 'Object' last, it matches on other classes too\n  ];\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      } // note: conversion from number to BigNumber can fail if x has >15 digits\n\n\n      if (digits(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n\n      return new BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      return new Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      var f = new Fraction(x);\n\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n\n      return f;\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      try {\n        return new BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      try {\n        return new Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      if (!Complex) {\n        throwNoComplex(x);\n      }\n\n      try {\n        return new Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      if (!BigNumber) {\n        throwNoBignumber(x);\n      }\n\n      return new BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      if (!Fraction) {\n        throwNoFraction(x);\n      }\n\n      return new Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return String(x);\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      if (!DenseMatrix) {\n        throwNoMatrix();\n      }\n\n      return new DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n  return typed;\n});\n\nfunction throwNoBignumber(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a BigNumber: no class 'BigNumber' provided\"));\n}\n\nfunction throwNoComplex(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Complex number: no class 'Complex' provided\"));\n}\n\nfunction throwNoMatrix() {\n  throw new Error('Cannot convert array into a Matrix: no class \\'DenseMatrix\\' provided');\n}\n\nfunction throwNoFraction(x) {\n  throw new Error(\"Cannot convert value \".concat(x, \" into a Fraction, no class 'Fraction' provided.\"));\n}"]},"metadata":{},"sourceType":"module"}
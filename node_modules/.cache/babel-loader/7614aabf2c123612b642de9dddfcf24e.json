{"ast":null,"code":"import { isMatrix } from '../../utils/is';\nimport { arraySize } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nimport { format } from '../../utils/string';\nvar name = 'inv';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\nexport var createInv = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      addScalar = _ref.addScalar,\n      multiply = _ref.multiply,\n      unaryMinus = _ref.unaryMinus,\n      det = _ref.det,\n      identity = _ref.identity,\n      abs = _ref.abs;\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if (isMatrix(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          // two dimensional array\n          {\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              if (isMatrix(x)) {\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n              } else {\n                // return an Array\n                return _inv(x, rows, cols);\n              }\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      } // create an identity matrix which in the end will contain the\n      // matrix inverse\n\n\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\n\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n\n          r++;\n        }\n\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n\n        r = rBig;\n\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        } // eliminate non-zero values on the other rows at column c\n\n\n        var Ac = A[c];\n        var Bc = B[c];\n\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\n              // at column c\n\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n\n      return B;\n    }\n  }\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/matrix/inv.js"],"names":["isMatrix","arraySize","factory","format","name","dependencies","createInv","_ref","typed","matrix","divideScalar","addScalar","multiply","unaryMinus","det","identity","abs","ArrayMatrix","x","size","length","valueOf","RangeError","rows","cols","_inv","storage","any","mat","r","s","f","value","temp","Error","d","A","concat","B","c","ABig","rBig","Ac","Bc","Ar","Br"],"mappings":"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","sourcesContent":["import { isMatrix } from '../../utils/is';\nimport { arraySize } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nimport { format } from '../../utils/string';\nvar name = 'inv';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\nexport var createInv = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      addScalar = _ref.addScalar,\n      multiply = _ref.multiply,\n      unaryMinus = _ref.unaryMinus,\n      det = _ref.det,\n      identity = _ref.identity,\n      abs = _ref.abs;\n\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if (isMatrix(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          // two dimensional array\n          {\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              if (isMatrix(x)) {\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n              } else {\n                // return an Array\n                return _inv(x, rows, cols);\n              }\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      } // create an identity matrix which in the end will contain the\n      // matrix inverse\n\n\n      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions\n\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n\n          r++;\n        }\n\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n\n        r = rBig;\n\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        } // eliminate non-zero values on the other rows at column c\n\n\n        var Ac = A[c];\n        var Bc = B[c];\n\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value\n              // at column c\n\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n\n      return B;\n    }\n  }\n});"]},"metadata":{},"sourceType":"module"}
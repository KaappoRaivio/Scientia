{"ast":null,"code":"import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var equal = _ref.equal,\n      isZero = _ref.isZero,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      ParenthesisNode = _ref.ParenthesisNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/simplify/simplifyCore.js"],"names":["isConstantNode","isFunctionNode","isOperatorNode","isParenthesisNode","isSymbolNode","factory","name","dependencies","createSimplifyCore","_ref","equal","isZero","add","subtract","multiply","divide","pow","ConstantNode","OperatorNode","FunctionNode","ParenthesisNode","node0","node1","simplifyCore","node","isUnary","a0","args","op","isBinary","fn","_a","a1","value","a00","a00a1","implicit","a01","c","content","map","arg"],"mappings":"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","sourcesContent":["import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var equal = _ref.equal,\n      isZero = _ref.isZero,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      ParenthesisNode = _ref.ParenthesisNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});"]},"metadata":{},"sourceType":"module"}
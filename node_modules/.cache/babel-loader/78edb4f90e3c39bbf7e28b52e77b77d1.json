{"ast":null,"code":"\"use strict\"; // Map the characters to escape to their escaped values. The list is derived\n// from http://www.cespedes.org/blog/85/how-to-escape-latex-special-characters\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar defaultEscapes = {\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"\\\\\": \"\\\\textbackslash{}\",\n  \"#\": \"\\\\#\",\n  $: \"\\\\$\",\n  \"%\": \"\\\\%\",\n  \"&\": \"\\\\&\",\n  \"^\": \"\\\\textasciicircum{}\",\n  _: \"\\\\_\",\n  \"~\": \"\\\\textasciitilde{}\"\n};\nvar formatEscapes = {\n  \"\\u2013\": \"\\\\--\",\n  \"\\u2014\": \"\\\\---\",\n  \" \": \"~\",\n  \"\\t\": \"\\\\qquad{}\",\n  \"\\r\\n\": \"\\\\newline{}\",\n  \"\\n\": \"\\\\newline{}\"\n};\n\nvar defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {\n  return _extends({}, defaultEscapes, formatEscapes);\n};\n/**\n * Escape a string to be used in LaTeX documents.\n * @param {string} str the string to be escaped.\n * @param {boolean} params.preserveFormatting whether formatting escapes should\n *  be performed (default: false).\n * @param {function} params.escapeMapFn the function to modify the escape maps.\n * @return {string} the escaped string, ready to be used in LaTeX.\n */\n\n\nmodule.exports = function (str) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$preserveFormatti = _ref.preserveFormatting,\n      preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti,\n      _ref$escapeMapFn = _ref.escapeMapFn,\n      escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;\n\n  var runningStr = String(str);\n  var result = \"\";\n  var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});\n  var escapeKeys = Object.keys(escapes); // as it is reused later on\n  // Algorithm: Go through the string character by character, if it matches\n  // with one of the special characters then we'll replace it with the escaped\n  // version.\n\n  var _loop = function _loop() {\n    var specialCharFound = false;\n    escapeKeys.forEach(function (key, index) {\n      if (specialCharFound) {\n        return;\n      }\n\n      if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {\n        result += escapes[escapeKeys[index]];\n        runningStr = runningStr.slice(key.length, runningStr.length);\n        specialCharFound = true;\n      }\n    });\n\n    if (!specialCharFound) {\n      result += runningStr.slice(0, 1);\n      runningStr = runningStr.slice(1, runningStr.length);\n    }\n  };\n\n  while (runningStr) {\n    _loop();\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/escape-latex/dist/index.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","defaultEscapes","$","_","formatEscapes","defaultEscapeMapFn","module","exports","str","_ref","undefined","_ref$preserveFormatti","preserveFormatting","_ref$escapeMapFn","escapeMapFn","runningStr","String","result","escapes","escapeKeys","keys","_loop","specialCharFound","forEach","index","slice"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// Map the characters to escape to their escaped values. The list is derived\n// from http://www.cespedes.org/blog/85/how-to-escape-latex-special-characters\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar defaultEscapes = {\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"\\\\\": \"\\\\textbackslash{}\",\n  \"#\": \"\\\\#\",\n  $: \"\\\\$\",\n  \"%\": \"\\\\%\",\n  \"&\": \"\\\\&\",\n  \"^\": \"\\\\textasciicircum{}\",\n  _: \"\\\\_\",\n  \"~\": \"\\\\textasciitilde{}\"\n};\nvar formatEscapes = {\n  \"\\u2013\": \"\\\\--\",\n  \"\\u2014\": \"\\\\---\",\n  \" \": \"~\",\n  \"\\t\": \"\\\\qquad{}\",\n  \"\\r\\n\": \"\\\\newline{}\",\n  \"\\n\": \"\\\\newline{}\"\n};\n\nvar defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {\n  return _extends({}, defaultEscapes, formatEscapes);\n};\n\n/**\n * Escape a string to be used in LaTeX documents.\n * @param {string} str the string to be escaped.\n * @param {boolean} params.preserveFormatting whether formatting escapes should\n *  be performed (default: false).\n * @param {function} params.escapeMapFn the function to modify the escape maps.\n * @return {string} the escaped string, ready to be used in LaTeX.\n */\nmodule.exports = function (str) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$preserveFormatti = _ref.preserveFormatting,\n      preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti,\n      _ref$escapeMapFn = _ref.escapeMapFn,\n      escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;\n\n  var runningStr = String(str);\n  var result = \"\";\n\n  var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});\n  var escapeKeys = Object.keys(escapes); // as it is reused later on\n\n  // Algorithm: Go through the string character by character, if it matches\n  // with one of the special characters then we'll replace it with the escaped\n  // version.\n\n  var _loop = function _loop() {\n    var specialCharFound = false;\n    escapeKeys.forEach(function (key, index) {\n      if (specialCharFound) {\n        return;\n      }\n      if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {\n        result += escapes[escapeKeys[index]];\n        runningStr = runningStr.slice(key.length, runningStr.length);\n        specialCharFound = true;\n      }\n    });\n    if (!specialCharFound) {\n      result += runningStr.slice(0, 1);\n      runningStr = runningStr.slice(1, runningStr.length);\n    }\n  };\n\n  while (runningStr) {\n    _loop();\n  }\n  return result;\n};"]},"metadata":{},"sourceType":"script"}
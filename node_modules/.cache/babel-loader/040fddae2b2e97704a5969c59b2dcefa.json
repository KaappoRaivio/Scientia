{"ast":null,"code":"import { factory } from '../../utils/factory';\nimport { arraySize } from '../../utils/array';\nimport { isMatrix } from '../../utils/is';\nimport { IndexError } from '../../error/IndexError';\nvar name = 'apply';\nvar dependencies = ['typed', 'isInteger'];\nexport var createApply = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      isInteger = _ref.isInteger;\n  /**\n   * Apply a function that maps an array to a scalar\n   * along a given axis of a matrix or array.\n   * Returns a new matrix or array with one less dimension than the input.\n   *\n   * Syntax:\n   *\n   *     math.apply(A, dim, callback)\n   *\n   * Where:\n   *\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\n   *\n   * Examples:\n   *\n   *    const A = [[1, 2], [3, 4]]\n   *    const sum = math.sum\n   *\n   *    math.apply(A, 0, sum)             // returns [4, 6]\n   *    math.apply(A, 1, sum)             // returns [3, 7]\n   *\n   * See also:\n   *\n   *    map, filter, forEach\n   *\n   * @param {Array | Matrix} array   The input Matrix\n   * @param {number} dim             The dimension along which the callback is applied\n   * @param {Function} callback      The callback function that is applied. This Function\n   *                                 should take an array or 1-d matrix as an input and\n   *                                 return a number.\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\n   */\n\n  var apply = typed(name, {\n    'Array | Matrix, number | BigNumber, function': function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {\n      if (!isInteger(dim)) {\n        throw new TypeError('Integer number expected for dimension');\n      }\n\n      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n\n      if (dim < 0 || dim >= size.length) {\n        throw new IndexError(dim, size.length);\n      }\n\n      if (isMatrix(mat)) {\n        return mat.create(_apply(mat.valueOf(), dim, callback));\n      } else {\n        return _apply(mat, dim, callback);\n      }\n    }\n  });\n  return apply;\n});\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _apply(mat, dim, callback) {\n  var i, ret, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      return callback(mat);\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _apply(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _apply(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/matrix/apply.js"],"names":["factory","arraySize","isMatrix","IndexError","name","dependencies","createApply","_ref","typed","isInteger","apply","ArrayMatrixNumberBigNumberFunction","mat","dim","callback","TypeError","size","Array","isArray","length","create","_apply","valueOf","i","ret","tran","_switch","I","J","j","tmp","push"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory';\nimport { arraySize } from '../../utils/array';\nimport { isMatrix } from '../../utils/is';\nimport { IndexError } from '../../error/IndexError';\nvar name = 'apply';\nvar dependencies = ['typed', 'isInteger'];\nexport var createApply = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      isInteger = _ref.isInteger;\n\n  /**\n   * Apply a function that maps an array to a scalar\n   * along a given axis of a matrix or array.\n   * Returns a new matrix or array with one less dimension than the input.\n   *\n   * Syntax:\n   *\n   *     math.apply(A, dim, callback)\n   *\n   * Where:\n   *\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\n   *\n   * Examples:\n   *\n   *    const A = [[1, 2], [3, 4]]\n   *    const sum = math.sum\n   *\n   *    math.apply(A, 0, sum)             // returns [4, 6]\n   *    math.apply(A, 1, sum)             // returns [3, 7]\n   *\n   * See also:\n   *\n   *    map, filter, forEach\n   *\n   * @param {Array | Matrix} array   The input Matrix\n   * @param {number} dim             The dimension along which the callback is applied\n   * @param {Function} callback      The callback function that is applied. This Function\n   *                                 should take an array or 1-d matrix as an input and\n   *                                 return a number.\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\n   */\n  var apply = typed(name, {\n    'Array | Matrix, number | BigNumber, function': function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {\n      if (!isInteger(dim)) {\n        throw new TypeError('Integer number expected for dimension');\n      }\n\n      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n\n      if (dim < 0 || dim >= size.length) {\n        throw new IndexError(dim, size.length);\n      }\n\n      if (isMatrix(mat)) {\n        return mat.create(_apply(mat.valueOf(), dim, callback));\n      } else {\n        return _apply(mat, dim, callback);\n      }\n    }\n  });\n  return apply;\n});\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _apply(mat, dim, callback) {\n  var i, ret, tran;\n\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      return callback(mat);\n    } else {\n      tran = _switch(mat);\n      ret = [];\n\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _apply(tran[i], dim - 1, callback);\n      }\n\n      return ret;\n    }\n  } else {\n    ret = [];\n\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _apply(mat[i], dim - 1, callback);\n    }\n\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n\n    ret.push(tmp);\n  }\n\n  return ret;\n}"]},"metadata":{},"sourceType":"module"}
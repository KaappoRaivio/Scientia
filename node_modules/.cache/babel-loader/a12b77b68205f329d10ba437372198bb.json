{"ast":null,"code":"import { clone } from '../../../utils/object';\nimport { factory } from '../../../utils/factory';\nvar name = 'lup';\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\nexport var createLup = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      abs = _ref.abs,\n      addScalar = _ref.addScalar,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      equalScalar = _ref.equalScalar,\n      unaryMinus = _ref.unaryMinus,\n      DenseMatrix = _ref.DenseMatrix,\n      SparseMatrix = _ref.SparseMatrix,\n      Spa = _ref.Spa;\n  /**\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\n   * row permutation vector `p` where `A[p,:] = L * U`\n   *\n   * Syntax:\n   *\n   *    math.lup(A)\n   *\n   * Example:\n   *\n   *    const m = [[2, 1], [1, 4]]\n   *    const r = math.lup(m)\n   *    // r = {\n   *    //   L: [[1, 0], [0.5, 1]],\n   *    //   U: [[2, 1], [0, 3.5]],\n   *    //   P: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    slu, lsolve, lusolve, usolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\n   *\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\n   */\n\n  return typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseLUP(m); // result\n\n\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix array, clone original data\n\n    var data = clone(m._data); // l matrix arrays\n\n    var ldata = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var udata = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vector\n\n    var p = [];\n\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j); // v[i, j]\n\n          var s = 0; // loop up to min\n\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n\n          data[i][j] = subtract(data[i][j], s);\n        }\n      } // row with larger value in cvector, row >= j\n\n\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0; // loop rows\n\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j]; // absolute value\n\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      } // swap rows (j <-> pi)\n\n\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0]; // swap j <-> pi in data\n\n        DenseMatrix._swapRows(j, pi, data);\n      } // check column is in lower triangular matrix\n\n\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          } // L\n\n\n          ldata[i] = [];\n        } // check we are in the upper triangular matrix\n\n\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n\n          continue;\n        } // diagonal value\n\n\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n\n          continue;\n        } // check row exists in upper triangular matrix\n\n\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        } // check column exists in lower triangular matrix\n\n\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    } // l matrix\n\n\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    }); // u matrix\n\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    }); // p vector\n\n    var pv = [];\n\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    } // return matrices\n\n\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix arrays (will not be modified, thanks to permutation vector)\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // l matrix arrays\n\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vectors, (current index -> original index) and (original index -> current index)\n\n    var pvCo = [];\n    var pvOc = [];\n\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    } // swap indices in permutation vectors (condition x < y)!\n\n\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y]; // update permutation vector current -> original\n\n      pvCo[kx] = y;\n      pvCo[ky] = x; // update permutation vector original -> current\n\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    }; // loop columns\n\n\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa(); // check lower triangular matrix has a value @ column j\n\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length); // first value in j column for lower triangular matrix\n\n        lvalues.push(1);\n        lindex.push(j);\n      } // update ptr\n\n\n      uptr.push(uvalues.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // copy column j into sparse accumulator\n\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k]; // copy column values into sparse accumulator (use permutation vector)\n\n        spa.set(pvCo[i], values[k]);\n      } // skip first column in upper triangular matrix\n\n\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      } // row with larger value in spa, row >= j\n\n\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj); // loop values in spa (order by row, below diagonal)\n\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      }); // swap rows (j <-> pi)\n\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr); // swap values j <-> pi in U\n\n\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr); // swap values in spa\n\n\n        spa.swap(j, pi); // update permutation vector (swap values @ j, pi)\n\n        swapIndeces(j, pi);\n      } // loop values in spa (order by row)\n\n\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj); // check value is non zero\n\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n\n    for (j = 0; j < columns; j++) {\n      _loop();\n    } // update ptrs\n\n\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length); // return matrices\n\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/decomposition/lup.js"],"names":["clone","factory","name","dependencies","createLup","_ref","typed","matrix","abs","addScalar","divideScalar","multiplyScalar","subtract","larger","equalScalar","unaryMinus","DenseMatrix","SparseMatrix","Spa","m","_denseLUP","_sparseLUP","Array","a","r","L","valueOf","U","p","rows","_size","columns","n","Math","min","data","_data","ldata","lsize","udata","usize","i","j","k","s","pi","pabsv","vjj","v","absv","_swapRows","vij","l","size","u","pv","length","toString","values","_values","index","_index","ptr","_ptr","lvalues","lindex","lptr","uvalues","uindex","uptr","pvCo","pvOc","swapIndeces","x","y","kx","ky","_loop","spa","push","k0","k1","set","forEach","vkj","_forEachRow","vik","accumulate","get","swap"],"mappings":"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","sourcesContent":["import { clone } from '../../../utils/object';\nimport { factory } from '../../../utils/factory';\nvar name = 'lup';\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\nexport var createLup = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      abs = _ref.abs,\n      addScalar = _ref.addScalar,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      equalScalar = _ref.equalScalar,\n      unaryMinus = _ref.unaryMinus,\n      DenseMatrix = _ref.DenseMatrix,\n      SparseMatrix = _ref.SparseMatrix,\n      Spa = _ref.Spa;\n\n  /**\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\n   * row permutation vector `p` where `A[p,:] = L * U`\n   *\n   * Syntax:\n   *\n   *    math.lup(A)\n   *\n   * Example:\n   *\n   *    const m = [[2, 1], [1, 4]]\n   *    const r = math.lup(m)\n   *    // r = {\n   *    //   L: [[1, 0], [0.5, 1]],\n   *    //   U: [[2, 1], [0, 3.5]],\n   *    //   P: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    slu, lsolve, lusolve, usolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\n   *\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\n   */\n  return typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseLUP(m); // result\n\n\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix array, clone original data\n\n    var data = clone(m._data); // l matrix arrays\n\n    var ldata = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var udata = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vector\n\n    var p = [];\n\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j); // v[i, j]\n\n          var s = 0; // loop up to min\n\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n\n          data[i][j] = subtract(data[i][j], s);\n        }\n      } // row with larger value in cvector, row >= j\n\n\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0; // loop rows\n\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j]; // absolute value\n\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      } // swap rows (j <-> pi)\n\n\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0]; // swap j <-> pi in data\n\n        DenseMatrix._swapRows(j, pi, data);\n      } // check column is in lower triangular matrix\n\n\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          } // L\n\n\n          ldata[i] = [];\n        } // check we are in the upper triangular matrix\n\n\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n\n          continue;\n        } // diagonal value\n\n\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n\n          continue;\n        } // check row exists in upper triangular matrix\n\n\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        } // check column exists in lower triangular matrix\n\n\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    } // l matrix\n\n\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    }); // u matrix\n\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    }); // p vector\n\n    var pv = [];\n\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    } // return matrices\n\n\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix arrays (will not be modified, thanks to permutation vector)\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // l matrix arrays\n\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vectors, (current index -> original index) and (original index -> current index)\n\n    var pvCo = [];\n    var pvOc = [];\n\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    } // swap indices in permutation vectors (condition x < y)!\n\n\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y]; // update permutation vector current -> original\n\n      pvCo[kx] = y;\n      pvCo[ky] = x; // update permutation vector original -> current\n\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    }; // loop columns\n\n\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa(); // check lower triangular matrix has a value @ column j\n\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length); // first value in j column for lower triangular matrix\n\n        lvalues.push(1);\n        lindex.push(j);\n      } // update ptr\n\n\n      uptr.push(uvalues.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // copy column j into sparse accumulator\n\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k]; // copy column values into sparse accumulator (use permutation vector)\n\n        spa.set(pvCo[i], values[k]);\n      } // skip first column in upper triangular matrix\n\n\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      } // row with larger value in spa, row >= j\n\n\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj); // loop values in spa (order by row, below diagonal)\n\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      }); // swap rows (j <-> pi)\n\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr); // swap values j <-> pi in U\n\n\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr); // swap values in spa\n\n\n        spa.swap(j, pi); // update permutation vector (swap values @ j, pi)\n\n        swapIndeces(j, pi);\n      } // loop values in spa (order by row)\n\n\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj); // check value is non zero\n\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n\n    for (j = 0; j < columns; j++) {\n      _loop();\n    } // update ptrs\n\n\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length); // return matrices\n\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { factory } from '../utils/factory';\nimport { extend, hasOwnProperty } from '../utils/object';\nimport { getSafeProperty, setSafeProperty } from '../utils/customs';\nimport { warnOnce } from '../utils/log';\nvar name = 'Parser';\nvar dependencies = ['parse'];\nexport var createParserClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var parse = _ref.parse;\n  /**\n   * @constructor Parser\n   * Parser contains methods to evaluate or parse expressions, and has a number\n   * of convenience methods to get, set, and remove variables from memory. Parser\n   * keeps a scope containing variables in memory, which is used for all\n   * evaluations.\n   *\n   * Methods:\n   *    const result = parser.evaluate(expr)  // evaluate an expression\n   *    const value = parser.get(name)        // retrieve a variable from the parser\n   *    const values = parser.getAll()        // retrieve all defined variables\n   *    parser.set(name, value)               // set a variable in the parser\n   *    parser.remove(name)                   // clear a variable from the\n   *                                          // parsers scope\n   *    parser.clear()                        // clear the parsers scope\n   *\n   * Example usage:\n   *    const parser = new Parser()\n   *    // Note: there is a convenience method which can be used instead:\n   *    // const parser = new math.parser()\n   *\n   *    // evaluate expressions\n   *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5\n   *    parser.evaluate('sqrt(-4)')               // 2i\n   *    parser.evaluate('2 inch in cm')           // 5.08 cm\n   *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476\n   *\n   *    // define variables and functions\n   *    parser.evaluate('x = 7 / 2')              // 3.5\n   *    parser.evaluate('x + 3')                  // 6.5\n   *    parser.evaluate('function f(x, y) = x^y') // f(x, y)\n   *    parser.evaluate('f(2, 3)')                // 8\n   *\n   *    // get and set variables and functions\n   *    const x = parser.get('x')                 // 7\n   *    const f = parser.get('f')                 // function\n   *    const g = f(3, 2)                         // 9\n   *    parser.set('h', 500)\n   *    const i = parser.evaluate('h / 2')        // 250\n   *    parser.set('hello', function (name) {\n   *        return 'hello, ' + name + '!'\n   *    })\n   *    parser.evaluate('hello(\"user\")')          // \"hello, user!\"\n   *\n   *    // clear defined functions and variables\n   *    parser.clear()\n   *\n   */\n\n  function Parser() {\n    if (!(this instanceof Parser)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.scope = {};\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Parser.prototype.type = 'Parser';\n  Parser.prototype.isParser = true;\n  /**\n   * Parse an expression and return the parsed function node.\n   * The node tree can be compiled via `code = node.compile(math)`,\n   * and the compiled code can be executed as `code.evaluate([scope])`\n   * @param {string} expr\n   * @return {Node} node\n   * @throws {Error}\n   */\n\n  Parser.prototype.parse = function (expr) {\n    throw new Error('Parser.parse is deprecated. Use math.parse instead.');\n  };\n  /**\n   * Parse and compile an expression, return the compiled javascript code.\n   * The node can be evaluated via code.evaluate([scope])\n   * @param {string} expr\n   * @return {{evaluate: function}} code\n   * @throws {Error}\n   */\n\n\n  Parser.prototype.compile = function (expr) {\n    throw new Error('Parser.compile is deprecated. Use math.compile instead.');\n  };\n  /**\n   * Parse and evaluate the given expression\n   * @param {string} expr   A string containing an expression, for example \"2+3\"\n   * @return {*} result     The result, or undefined when the expression was empty\n   * @throws {Error}\n   */\n\n\n  Parser.prototype.evaluate = function (expr) {\n    // TODO: validate arguments\n    return parse(expr).compile().evaluate(this.scope);\n  };\n  /**\n   * Parse and evaluate the given expression\n   * @param {string} expr   A string containing an expression, for example \"2+3\"\n   * @return {*} result     The result, or undefined when the expression was empty\n   * @throws {Error}\n   */\n  // TODO: Deprecated since v6.0.0. Clean up some day\n\n\n  Parser.prototype.eval = function (expr) {\n    warnOnce('Method Parser.eval is renamed to Parser.evaluate. Please use the new method name.');\n    return this.evaluate(expr);\n  };\n  /**\n   * Get a variable (a function or variable) by name from the parsers scope.\n   * Returns undefined when not found\n   * @param {string} name\n   * @return {* | undefined} value\n   */\n\n\n  Parser.prototype.get = function (name) {\n    // TODO: validate arguments\n    return name in this.scope ? getSafeProperty(this.scope, name) : undefined;\n  };\n  /**\n   * Get a map with all defined variables\n   * @return {Object} values\n   */\n\n\n  Parser.prototype.getAll = function () {\n    return extend({}, this.scope);\n  };\n  /**\n   * Set a symbol (a function or variable) by name from the parsers scope.\n   * @param {string} name\n   * @param {* | undefined} value\n   */\n\n\n  Parser.prototype.set = function (name, value) {\n    // TODO: validate arguments\n    return setSafeProperty(this.scope, name, value);\n  };\n  /**\n   * Remove a variable from the parsers scope\n   * @param {string} name\n   */\n\n\n  Parser.prototype.remove = function (name) {\n    // TODO: validate arguments\n    delete this.scope[name];\n  };\n  /**\n   * Clear the scope with variables and functions\n   */\n\n\n  Parser.prototype.clear = function () {\n    for (var _name in this.scope) {\n      if (hasOwnProperty(this.scope, _name)) {\n        delete this.scope[_name];\n      }\n    }\n  };\n\n  return Parser;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/Parser.js"],"names":["factory","extend","hasOwnProperty","getSafeProperty","setSafeProperty","warnOnce","name","dependencies","createParserClass","_ref","parse","Parser","SyntaxError","scope","prototype","type","isParser","expr","Error","compile","evaluate","eval","get","undefined","getAll","set","value","remove","clear","_name","isClass"],"mappings":"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","sourcesContent":["import { factory } from '../utils/factory';\nimport { extend, hasOwnProperty } from '../utils/object';\nimport { getSafeProperty, setSafeProperty } from '../utils/customs';\nimport { warnOnce } from '../utils/log';\nvar name = 'Parser';\nvar dependencies = ['parse'];\nexport var createParserClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var parse = _ref.parse;\n\n  /**\n   * @constructor Parser\n   * Parser contains methods to evaluate or parse expressions, and has a number\n   * of convenience methods to get, set, and remove variables from memory. Parser\n   * keeps a scope containing variables in memory, which is used for all\n   * evaluations.\n   *\n   * Methods:\n   *    const result = parser.evaluate(expr)  // evaluate an expression\n   *    const value = parser.get(name)        // retrieve a variable from the parser\n   *    const values = parser.getAll()        // retrieve all defined variables\n   *    parser.set(name, value)               // set a variable in the parser\n   *    parser.remove(name)                   // clear a variable from the\n   *                                          // parsers scope\n   *    parser.clear()                        // clear the parsers scope\n   *\n   * Example usage:\n   *    const parser = new Parser()\n   *    // Note: there is a convenience method which can be used instead:\n   *    // const parser = new math.parser()\n   *\n   *    // evaluate expressions\n   *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5\n   *    parser.evaluate('sqrt(-4)')               // 2i\n   *    parser.evaluate('2 inch in cm')           // 5.08 cm\n   *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476\n   *\n   *    // define variables and functions\n   *    parser.evaluate('x = 7 / 2')              // 3.5\n   *    parser.evaluate('x + 3')                  // 6.5\n   *    parser.evaluate('function f(x, y) = x^y') // f(x, y)\n   *    parser.evaluate('f(2, 3)')                // 8\n   *\n   *    // get and set variables and functions\n   *    const x = parser.get('x')                 // 7\n   *    const f = parser.get('f')                 // function\n   *    const g = f(3, 2)                         // 9\n   *    parser.set('h', 500)\n   *    const i = parser.evaluate('h / 2')        // 250\n   *    parser.set('hello', function (name) {\n   *        return 'hello, ' + name + '!'\n   *    })\n   *    parser.evaluate('hello(\"user\")')          // \"hello, user!\"\n   *\n   *    // clear defined functions and variables\n   *    parser.clear()\n   *\n   */\n  function Parser() {\n    if (!(this instanceof Parser)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.scope = {};\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Parser.prototype.type = 'Parser';\n  Parser.prototype.isParser = true;\n  /**\n   * Parse an expression and return the parsed function node.\n   * The node tree can be compiled via `code = node.compile(math)`,\n   * and the compiled code can be executed as `code.evaluate([scope])`\n   * @param {string} expr\n   * @return {Node} node\n   * @throws {Error}\n   */\n\n  Parser.prototype.parse = function (expr) {\n    throw new Error('Parser.parse is deprecated. Use math.parse instead.');\n  };\n  /**\n   * Parse and compile an expression, return the compiled javascript code.\n   * The node can be evaluated via code.evaluate([scope])\n   * @param {string} expr\n   * @return {{evaluate: function}} code\n   * @throws {Error}\n   */\n\n\n  Parser.prototype.compile = function (expr) {\n    throw new Error('Parser.compile is deprecated. Use math.compile instead.');\n  };\n  /**\n   * Parse and evaluate the given expression\n   * @param {string} expr   A string containing an expression, for example \"2+3\"\n   * @return {*} result     The result, or undefined when the expression was empty\n   * @throws {Error}\n   */\n\n\n  Parser.prototype.evaluate = function (expr) {\n    // TODO: validate arguments\n    return parse(expr).compile().evaluate(this.scope);\n  };\n  /**\n   * Parse and evaluate the given expression\n   * @param {string} expr   A string containing an expression, for example \"2+3\"\n   * @return {*} result     The result, or undefined when the expression was empty\n   * @throws {Error}\n   */\n  // TODO: Deprecated since v6.0.0. Clean up some day\n\n\n  Parser.prototype.eval = function (expr) {\n    warnOnce('Method Parser.eval is renamed to Parser.evaluate. Please use the new method name.');\n    return this.evaluate(expr);\n  };\n  /**\n   * Get a variable (a function or variable) by name from the parsers scope.\n   * Returns undefined when not found\n   * @param {string} name\n   * @return {* | undefined} value\n   */\n\n\n  Parser.prototype.get = function (name) {\n    // TODO: validate arguments\n    return name in this.scope ? getSafeProperty(this.scope, name) : undefined;\n  };\n  /**\n   * Get a map with all defined variables\n   * @return {Object} values\n   */\n\n\n  Parser.prototype.getAll = function () {\n    return extend({}, this.scope);\n  };\n  /**\n   * Set a symbol (a function or variable) by name from the parsers scope.\n   * @param {string} name\n   * @param {* | undefined} value\n   */\n\n\n  Parser.prototype.set = function (name, value) {\n    // TODO: validate arguments\n    return setSafeProperty(this.scope, name, value);\n  };\n  /**\n   * Remove a variable from the parsers scope\n   * @param {string} name\n   */\n\n\n  Parser.prototype.remove = function (name) {\n    // TODO: validate arguments\n    delete this.scope[name];\n  };\n  /**\n   * Clear the scope with variables and functions\n   */\n\n\n  Parser.prototype.clear = function () {\n    for (var _name in this.scope) {\n      if (hasOwnProperty(this.scope, _name)) {\n        delete this.scope[_name];\n      }\n    }\n  };\n\n  return Parser;\n}, {\n  isClass: true\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { contains } from './array';\nimport { pickShallow } from './object';\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/utils/factory.js"],"names":["contains","pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"mappings":"AAAA,SAASA,QAAT,QAAyB,SAAzB;AACA,SAASC,WAAT,QAA4B,UAA5B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,SAASC,OAAT,CAAiBC,IAAjB,EAAuBC,YAAvB,EAAqCC,MAArC,EAA6CC,IAA7C,EAAmD;AACxD,WAASC,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B;AACA;AACA;AACA,QAAIC,IAAI,GAAGR,WAAW,CAACO,KAAD,EAAQJ,YAAY,CAACM,GAAb,CAAiBC,qBAAjB,CAAR,CAAtB;AACAC,IAAAA,kBAAkB,CAACT,IAAD,EAAOC,YAAP,EAAqBI,KAArB,CAAlB;AACA,WAAOH,MAAM,CAACI,IAAD,CAAb;AACD;;AAEDF,EAAAA,eAAe,CAACM,SAAhB,GAA4B,IAA5B;AACAN,EAAAA,eAAe,CAACO,EAAhB,GAAqBX,IAArB;AACAI,EAAAA,eAAe,CAACH,YAAhB,GAA+BA,YAAY,CAACW,KAAb,GAAqBC,IAArB,EAA/B;;AAEA,MAAIV,IAAJ,EAAU;AACRC,IAAAA,eAAe,CAACD,IAAhB,GAAuBA,IAAvB;AACD;;AAED,SAAOC,eAAP;AACD;AACD;;;;;;;AAOA,OAAO,SAASU,aAAT,CAAuBC,SAAvB,EAAkC;AACvC,MAAIC,eAAe,GAAG,EAAtB;AACAD,EAAAA,SAAS,CAACE,OAAV,CAAkB,UAAUlB,OAAV,EAAmB;AACnCiB,IAAAA,eAAe,CAACjB,OAAO,CAACY,EAAT,CAAf,GAA8BZ,OAA9B;AACD,GAFD;;AAIA,WAASmB,kBAAT,CAA4BnB,OAA5B,EAAqCoB,UAArC,EAAiD;AAC/C;AACA,QAAIT,SAAS,CAACX,OAAD,CAAb,EAAwB;AACtB,UAAIF,QAAQ,CAACE,OAAO,CAACE,YAAT,EAAuBkB,UAAU,CAACR,EAAX,IAAiBQ,UAAU,CAACnB,IAAnD,CAAZ,EAAsE;AACpE,eAAO,IAAP;AACD;;AAED,UAAID,OAAO,CAACE,YAAR,CAAqBmB,IAArB,CAA0B,UAAUC,CAAV,EAAa;AACzC,eAAOH,kBAAkB,CAACF,eAAe,CAACK,CAAD,CAAhB,EAAqBF,UAArB,CAAzB;AACD,OAFG,CAAJ,EAEI;AACF,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AAED,MAAIG,MAAM,GAAG,EAAb;;AAEA,WAASC,UAAT,CAAoBxB,OAApB,EAA6B;AAC3B,QAAIyB,KAAK,GAAG,CAAZ;;AAEA,WAAOA,KAAK,GAAGF,MAAM,CAACG,MAAf,IAAyB,CAACP,kBAAkB,CAACI,MAAM,CAACE,KAAD,CAAP,EAAgBzB,OAAhB,CAAnD,EAA6E;AAC3EyB,MAAAA,KAAK;AACN;;AAEDF,IAAAA,MAAM,CAACI,MAAP,CAAcF,KAAd,EAAqB,CAArB,EAAwBzB,OAAxB;AACD,GAjCsC,CAiCrC;;;AAGFgB,EAAAA,SAAS,CAACY,MAAV,CAAiBjB,SAAjB,EAA4BO,OAA5B,CAAoCM,UAApC,EApCuC,CAoCU;;AAEjDR,EAAAA,SAAS,CAACY,MAAV,CAAiB,UAAU5B,OAAV,EAAmB;AAClC,WAAO,CAACW,SAAS,CAACX,OAAD,CAAjB;AACD,GAFD,EAEGkB,OAFH,CAEWM,UAFX;AAGA,SAAOD,MAAP;AACD,C,CAAC;;AAEF,OAAO,SAASpB,MAAT,CAAgBa,SAAhB,EAA2B;AAChC,MAAIV,KAAK,GAAGuB,SAAS,CAACH,MAAV,GAAmB,CAAnB,IAAwBG,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AACAd,EAAAA,aAAa,CAACC,SAAD,CAAb,CAAyBE,OAAzB,CAAiC,UAAUlB,OAAV,EAAmB;AAClD,WAAOA,OAAO,CAACM,KAAD,CAAd;AACD,GAFD;AAGA,SAAOA,KAAP;AACD;AACD;;;;;;;AAOA,OAAO,SAASK,SAAT,CAAmBoB,GAAnB,EAAwB;AAC7B,SAAO,OAAOA,GAAP,KAAe,UAAf,IAA6B,OAAOA,GAAG,CAACnB,EAAX,KAAkB,QAA/C,IAA2DoB,KAAK,CAACC,OAAN,CAAcF,GAAG,CAAC7B,YAAlB,CAAlE;AACD;AACD;;;;;;;;;;AAUA,OAAO,SAASQ,kBAAT,CAA4BT,IAA5B,EAAkCC,YAAlC,EAAgDI,KAAhD,EAAuD;AAC5D,MAAI4B,UAAU,GAAGhC,YAAY,CAAC0B,MAAb,CAAoB,UAAUR,UAAV,EAAsB;AACzD,WAAO,CAACe,oBAAoB,CAACf,UAAD,CAA5B;AACD,GAFgB,EAEd;AAFc,GAGhBgB,KAHgB,CAGV,UAAUhB,UAAV,EAAsB;AAC3B,WAAOd,KAAK,CAACc,UAAD,CAAL,KAAsBU,SAA7B;AACD,GALgB,CAAjB;;AAOA,MAAI,CAACI,UAAL,EAAiB;AACf,QAAIG,mBAAmB,GAAGnC,YAAY,CAAC0B,MAAb,CAAoB,UAAUR,UAAV,EAAsB;AAClE,aAAOd,KAAK,CAACc,UAAD,CAAL,KAAsBU,SAA7B;AACD,KAFyB,CAA1B,CADe,CAGX;;AAEJ,UAAM,IAAIQ,KAAJ,CAAU,4BAA4BC,MAA5B,CAAmCtC,IAAnC,EAAyC,MAAzC,IAAmD,kCAAkCsC,MAAlC,CAAyCF,mBAAmB,CAAC7B,GAApB,CAAwB,UAAUc,CAAV,EAAa;AAC/I,aAAO,KAAKiB,MAAL,CAAYjB,CAAZ,EAAe,IAAf,CAAP;AACD,KAF2G,EAEzGkB,IAFyG,CAEpG,IAFoG,CAAzC,EAEpD,GAFoD,CAA7D,CAAN;AAGD;AACF;AACD,OAAO,SAASL,oBAAT,CAA8Bf,UAA9B,EAA0C;AAC/C,SAAOA,UAAU,IAAIA,UAAU,CAAC,CAAD,CAAV,KAAkB,GAAvC;AACD;AACD,OAAO,SAASX,qBAAT,CAA+BW,UAA/B,EAA2C;AAChD,SAAOA,UAAU,IAAIA,UAAU,CAAC,CAAD,CAAV,KAAkB,GAAhC,GAAsCA,UAAU,CAACP,KAAX,CAAiB,CAAjB,CAAtC,GAA4DO,UAAnE;AACD","sourcesContent":["import { contains } from './array';\nimport { pickShallow } from './object';\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}"]},"metadata":{},"sourceType":"module"}
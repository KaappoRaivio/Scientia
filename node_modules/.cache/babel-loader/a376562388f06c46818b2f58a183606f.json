{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { isConstantNode, isParenthesisNode } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nimport { createUtil } from './simplify/util';\nimport { createSimplifyCore } from './simplify/simplifyCore';\nimport { createSimplifyConstant } from './simplify/simplifyConstant';\nimport { createResolve } from './simplify/resolve';\nimport { hasOwnProperty } from '../../utils/object';\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      parse = _ref.parse,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      mathWithTransform = _ref.mathWithTransform,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var simplifyConstant = createSimplifyConstant({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    fraction: fraction,\n    bignumber: bignumber,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    SymbolNode: SymbolNode\n  });\n  var simplifyCore = createSimplifyCore({\n    equal: equal,\n    isZero: isZero,\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    pow: pow,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  var resolve = createResolve({\n    parse: parse,\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    ParenthesisNode: ParenthesisNode\n  });\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      flatten = _createUtil.flatten,\n      unflattenr = _createUtil.unflattenr,\n      unflattenl = _createUtil.unflattenl,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  There is currently one option available: `exactFractions`, a boolean which\n   *  is `true` by default.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return simplify(parse(expr), simplify.rules, {}, {});\n    },\n    'string, Object': function stringObject(expr, scope) {\n      return simplify(parse(expr), simplify.rules, scope, {});\n    },\n    'string, Object, Object': function stringObjectObject(expr, scope, options) {\n      return simplify(parse(expr), simplify.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return simplify(parse(expr), rules, {}, {});\n    },\n    'string, Array, Object': function stringArrayObject(expr, rules, scope) {\n      return simplify(parse(expr), rules, scope, {});\n    },\n    'string, Array, Object, Object': function stringArrayObjectObject(expr, rules, scope, options) {\n      return simplify(parse(expr), rules, scope, options);\n    },\n    'Node, Object': function NodeObject(expr, scope) {\n      return simplify(expr, simplify.rules, scope, {});\n    },\n    'Node, Object, Object': function NodeObjectObject(expr, scope, options) {\n      return simplify(expr, simplify.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return simplify(expr, simplify.rules, {}, {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return simplify(expr, rules, {}, {});\n    },\n    'Node, Array, Object': function NodeArrayObject(expr, rules, scope) {\n      return simplify(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        for (var i = 0; i < rules.length; i++) {\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n          }\n\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: '(-c) * v'\n  }, // make non-constant terms positive\n  {\n    l: '-v',\n    r: '(-1) * v'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  }, // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  }, // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'n1*n2 + n2',\n    r: '(n1+1)*n2'\n  }, {\n    l: 'n1*n3 + n2*n3',\n    r: '(n1+n2)*n3'\n  }, // remove parenthesis in the case of negating a quantitiy\n  {\n    l: 'n1 + -1 * (n2 + n3)',\n    r: 'n1 + -1 * n2 + -1 * n3'\n  }, simplifyConstant, {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  }, // make factors positive (and undo 'make non-constant terms positive')\n  // ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  }, // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  }, // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  }, // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  }, // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n\n      var ruleType = _typeof(rule);\n\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n\n          if (rule.context) {\n            newRule.evaluate = rule.context;\n          }\n\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n\n            var expandsym = _getExpandPlaceholderSymbol();\n\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, the assignments will have\n      // no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        if (res.args) {\n          for (var i = 0; i < res.args.length; i++) {\n            res.args[i] = applyRule(res.args[i], rule);\n          }\n        }\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } // Try to match a rule against this node\n\n\n      var repl = rule.r;\n\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      res.placeholders[key] = match1.placeholders[key];\n\n      if (hasOwnProperty(match2.placeholders, key)) {\n        if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n          return null;\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      res.placeholders[_key] = match2.placeholders[_key];\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!isConstantNode(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/simplify.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","isConstantNode","isParenthesisNode","factory","createUtil","createSimplifyCore","createSimplifyConstant","createResolve","hasOwnProperty","name","dependencies","createSimplify","_ref","config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","fraction","bignumber","mathWithTransform","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","SymbolNode","simplifyConstant","simplifyCore","resolve","_createUtil","isCommutative","isAssociative","flatten","unflattenr","unflattenl","createMakeNodeFunction","simplify","string","expr","rules","stringObject","scope","stringObjectObject","options","stringArray","stringArrayObject","stringArrayObjectObject","NodeObject","NodeObjectObject","Node","NodeArray","NodeArrayObject","NodeArrayObjectObject","_buildRules","res","removeParens","visited","str","toString","parenthesis","_lastsym","i","length","applyRule","node","transform","path","parent","content","SUPPORTED_CONSTANTS","e","Infinity","LN2","LN10","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","l","r","context","commutative","ruleSet","rule","newRule","ruleType","lr","split","SyntaxError","evaluate","makeNode","expandsym","_getExpandPlaceholderSymbol","expanded","clone","TypeError","push","args","repl","matches","_ruleMatch","implicit","isSymbolNode","placeholders","getSplits","right","rightArgs","slice","splice","mergeMatch","match1","match2","key","_exactMatch","_key","combineChildMatches","list1","list2","merged","i1","i2","mergeChildMatches","childMatches","sets","reduce","uniqueSets","unique","s","JSON","stringify","isSplit","op","fn","childMatch","splits","splitMatches","_i","matchSet","concat","Error","substring","value","p","q"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { isConstantNode, isParenthesisNode } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nimport { createUtil } from './simplify/util';\nimport { createSimplifyCore } from './simplify/simplifyCore';\nimport { createSimplifyConstant } from './simplify/simplifyConstant';\nimport { createResolve } from './simplify/resolve';\nimport { hasOwnProperty } from '../../utils/object';\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      parse = _ref.parse,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      mathWithTransform = _ref.mathWithTransform,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var simplifyConstant = createSimplifyConstant({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    fraction: fraction,\n    bignumber: bignumber,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    SymbolNode: SymbolNode\n  });\n  var simplifyCore = createSimplifyCore({\n    equal: equal,\n    isZero: isZero,\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    pow: pow,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  var resolve = createResolve({\n    parse: parse,\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    ParenthesisNode: ParenthesisNode\n  });\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      flatten = _createUtil.flatten,\n      unflattenr = _createUtil.unflattenr,\n      unflattenl = _createUtil.unflattenl,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  There is currently one option available: `exactFractions`, a boolean which\n   *  is `true` by default.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return simplify(parse(expr), simplify.rules, {}, {});\n    },\n    'string, Object': function stringObject(expr, scope) {\n      return simplify(parse(expr), simplify.rules, scope, {});\n    },\n    'string, Object, Object': function stringObjectObject(expr, scope, options) {\n      return simplify(parse(expr), simplify.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return simplify(parse(expr), rules, {}, {});\n    },\n    'string, Array, Object': function stringArrayObject(expr, rules, scope) {\n      return simplify(parse(expr), rules, scope, {});\n    },\n    'string, Array, Object, Object': function stringArrayObjectObject(expr, rules, scope, options) {\n      return simplify(parse(expr), rules, scope, options);\n    },\n    'Node, Object': function NodeObject(expr, scope) {\n      return simplify(expr, simplify.rules, scope, {});\n    },\n    'Node, Object, Object': function NodeObjectObject(expr, scope, options) {\n      return simplify(expr, simplify.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return simplify(expr, simplify.rules, {}, {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return simplify(expr, rules, {}, {});\n    },\n    'Node, Array, Object': function NodeArrayObject(expr, rules, scope) {\n      return simplify(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        for (var i = 0; i < rules.length; i++) {\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n          }\n\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: '(-c) * v'\n  }, // make non-constant terms positive\n  {\n    l: '-v',\n    r: '(-1) * v'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  }, // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  }, // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'n1*n2 + n2',\n    r: '(n1+1)*n2'\n  }, {\n    l: 'n1*n3 + n2*n3',\n    r: '(n1+n2)*n3'\n  }, // remove parenthesis in the case of negating a quantitiy\n  {\n    l: 'n1 + -1 * (n2 + n3)',\n    r: 'n1 + -1 * n2 + -1 * n3'\n  }, simplifyConstant, {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  }, // make factors positive (and undo 'make non-constant terms positive')\n  // ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  }, // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  }, // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  }, // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  }, // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n\n      var ruleType = _typeof(rule);\n\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n\n          if (rule.context) {\n            newRule.evaluate = rule.context;\n          }\n\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n\n            var expandsym = _getExpandPlaceholderSymbol();\n\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, the assignments will have\n      // no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        if (res.args) {\n          for (var i = 0; i < res.args.length; i++) {\n            res.args[i] = applyRule(res.args[i], rule);\n          }\n        }\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } // Try to match a rule against this node\n\n\n      var repl = rule.r;\n\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      res.placeholders[key] = match1.placeholders[key];\n\n      if (hasOwnProperty(match2.placeholders, key)) {\n        if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n          return null;\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      res.placeholders[_key] = match2.placeholders[_key];\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!isConstantNode(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { factory } from '../../utils/factory';\nimport { xgcdNumber } from '../../plain/number';\nvar name = 'xgcd';\nvar dependencies = ['typed', 'config', 'matrix', 'BigNumber'];\nexport var createXgcd = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      matrix = _ref.matrix,\n      BigNumber = _ref.BigNumber;\n  /**\n   * Calculate the extended greatest common divisor for two values.\n   * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.\n   *\n   * Syntax:\n   *\n   *    math.xgcd(a, b)\n   *\n   * Examples:\n   *\n   *    math.xgcd(8, 12)             // returns [4, -1, 1]\n   *    math.gcd(8, 12)              // returns 4\n   *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]\n   *\n   * See also:\n   *\n   *    gcd, lcm\n   *\n   * @param {number | BigNumber} a  An integer number\n   * @param {number | BigNumber} b  An integer number\n   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`\n   *                              where `div = gcd(a, b)` and `a*m + b*n = div`\n   */\n\n  return typed(name, {\n    'number, number': function numberNumber(a, b) {\n      var res = xgcdNumber(a, b);\n      return config.matrix === 'Array' ? res : matrix(res);\n    },\n    'BigNumber, BigNumber': _xgcdBigNumber // TODO: implement support for Fraction\n\n  });\n  /**\n   * Calculate xgcd for two BigNumbers\n   * @param {BigNumber} a\n   * @param {BigNumber} b\n   * @return {BigNumber[]} result\n   * @private\n   */\n\n  function _xgcdBigNumber(a, b) {\n    // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n    var // used to swap two variables\n    t;\n    var // quotient\n    q;\n    var // remainder\n    r;\n    var zero = new BigNumber(0);\n    var one = new BigNumber(1);\n    var x = zero;\n    var lastx = one;\n    var y = one;\n    var lasty = zero;\n\n    if (!a.isInt() || !b.isInt()) {\n      throw new Error('Parameters in function xgcd must be integer numbers');\n    }\n\n    while (!b.isZero()) {\n      q = a.div(b).floor();\n      r = a.mod(b);\n      t = x;\n      x = lastx.minus(q.times(x));\n      lastx = t;\n      t = y;\n      y = lasty.minus(q.times(y));\n      lasty = t;\n      a = b;\n      b = r;\n    }\n\n    var res;\n\n    if (a.lt(zero)) {\n      res = [a.neg(), lastx.neg(), lasty.neg()];\n    } else {\n      res = [a, !a.isZero() ? lastx : 0, lasty];\n    }\n\n    return config.matrix === 'Array' ? res : matrix(res);\n  }\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/arithmetic/xgcd.js"],"names":["factory","xgcdNumber","name","dependencies","createXgcd","_ref","typed","config","matrix","BigNumber","numberNumber","a","b","res","_xgcdBigNumber","t","q","r","zero","one","x","lastx","y","lasty","isInt","Error","isZero","div","floor","mod","minus","times","lt","neg"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory';\nimport { xgcdNumber } from '../../plain/number';\nvar name = 'xgcd';\nvar dependencies = ['typed', 'config', 'matrix', 'BigNumber'];\nexport var createXgcd = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      matrix = _ref.matrix,\n      BigNumber = _ref.BigNumber;\n\n  /**\n   * Calculate the extended greatest common divisor for two values.\n   * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.\n   *\n   * Syntax:\n   *\n   *    math.xgcd(a, b)\n   *\n   * Examples:\n   *\n   *    math.xgcd(8, 12)             // returns [4, -1, 1]\n   *    math.gcd(8, 12)              // returns 4\n   *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]\n   *\n   * See also:\n   *\n   *    gcd, lcm\n   *\n   * @param {number | BigNumber} a  An integer number\n   * @param {number | BigNumber} b  An integer number\n   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`\n   *                              where `div = gcd(a, b)` and `a*m + b*n = div`\n   */\n  return typed(name, {\n    'number, number': function numberNumber(a, b) {\n      var res = xgcdNumber(a, b);\n      return config.matrix === 'Array' ? res : matrix(res);\n    },\n    'BigNumber, BigNumber': _xgcdBigNumber // TODO: implement support for Fraction\n\n  });\n  /**\n   * Calculate xgcd for two BigNumbers\n   * @param {BigNumber} a\n   * @param {BigNumber} b\n   * @return {BigNumber[]} result\n   * @private\n   */\n\n  function _xgcdBigNumber(a, b) {\n    // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n    var // used to swap two variables\n    t;\n    var // quotient\n    q;\n    var // remainder\n    r;\n    var zero = new BigNumber(0);\n    var one = new BigNumber(1);\n    var x = zero;\n    var lastx = one;\n    var y = one;\n    var lasty = zero;\n\n    if (!a.isInt() || !b.isInt()) {\n      throw new Error('Parameters in function xgcd must be integer numbers');\n    }\n\n    while (!b.isZero()) {\n      q = a.div(b).floor();\n      r = a.mod(b);\n      t = x;\n      x = lastx.minus(q.times(x));\n      lastx = t;\n      t = y;\n      y = lasty.minus(q.times(y));\n      lasty = t;\n      a = b;\n      b = r;\n    }\n\n    var res;\n\n    if (a.lt(zero)) {\n      res = [a.neg(), lastx.neg(), lasty.neg()];\n    } else {\n      res = [a, !a.isZero() ? lastx : 0, lasty];\n    }\n\n    return config.matrix === 'Array' ? res : matrix(res);\n  }\n});"]},"metadata":{},"sourceType":"module"}
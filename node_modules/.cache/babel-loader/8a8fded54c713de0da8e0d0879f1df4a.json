{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { isBigNumber, isComplex, isFraction, isMatrix, isUnit } from '../../utils/is';\nimport { isFactory, stripOptionalNotation } from '../../utils/factory';\nimport { hasOwnProperty, isLegacyFactory, lazy, traverse } from '../../utils/object';\nimport { contains } from '../../utils/array';\nimport { ArgumentsError } from '../../error/ArgumentsError';\nimport { warnOnce } from '../../utils/log';\nexport function importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (isLegacyFactory(value)) {\n        // legacy factories don't always have a name,\n        // let's not handle them via the new flatValues\n        _importLegacyFactory(value, options);\n      } else if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if (_typeof(value) === 'object') {\n        for (var _name in value) {\n          if (hasOwnProperty(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if (isFactory(value) || name !== undefined) {\n        var flatName = isFactory(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if (hasOwnProperty(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if (hasOwnProperty(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if (isFactory(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, _defineProperty({}, value.signature, value));\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {{factory: Function, name: string, path: string, math: boolean}} factory\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n  // TODO: _importLegacyFactory is deprecated since v6.0.0, clean up some day\n\n\n  function _importLegacyFactory(factory, options) {\n    warnOnce('Factories of type { name, factory } are deprecated since v6. ' + 'Please create your factory functions using the math.factory function.');\n\n    if (typeof factory.name === 'string') {\n      var name = factory.name;\n      var existingTransform = (name in math.expression.transform);\n      var namespace = factory.path ? traverse(math, factory.path) : math;\n      var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n      var resolver = function resolver() {\n        var instance = load(factory);\n\n        if (instance && typeof instance.transform === 'function') {\n          throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n        }\n\n        if (isTypedFunction(existing) && isTypedFunction(instance)) {\n          if (options.override) {// replace the existing typed function (nothing to do)\n          } else {\n            // merge the existing and new typed function\n            instance = typed(existing, instance);\n          }\n\n          return instance;\n        }\n\n        if (existing === undefined || options.override) {\n          return instance;\n        }\n\n        if (options.silent) {\n          return existing;\n        } else {\n          throw new Error('Cannot import \"' + name + '\": already exists');\n        }\n      };\n\n      if (factory.lazy !== false) {\n        lazy(namespace, name, resolver);\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            lazy(math.expression.mathWithTransform, name, resolver);\n          }\n        }\n      } else {\n        namespace[name] = resolver();\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            math.expression.mathWithTransform[name] = resolver();\n          }\n        }\n      }\n\n      var key = factory.path ? factory.path + '.' + factory.name : factory.name;\n      importedFactories[key] = factory;\n      math.emit('import', name, resolver, factory.path);\n    } else {\n      // unnamed factory.\n      // no lazy loading\n      load(factory);\n    }\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if (contains(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(stripOptionalNotation).forEach(function (dependency) {\n        if (contains(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      lazy(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !hasOwnProperty(unsafe, name);\n  }\n\n  function legacyFactoryAllowedInExpressions(factory) {\n    return factory.path === undefined && !hasOwnProperty(unsafe, factory.name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !hasOwnProperty(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/core/function/import.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_typeof","Symbol","iterator","constructor","prototype","isBigNumber","isComplex","isFraction","isMatrix","isUnit","isFactory","stripOptionalNotation","hasOwnProperty","isLegacyFactory","lazy","traverse","contains","ArgumentsError","warnOnce","importFactory","typed","load","math","importedFactories","mathImport","functions","options","num","arguments","length","flattenImports","flatValues","name","_importLegacyFactory","Array","isArray","forEach","item","_name","undefined","flatName","isTransformFunctionFactory","fn","silent","Error","TypeError","_importFactory","isSupportedType","_import","wrap","_wrap","hasTypedFunctionSignature","signature","isTypedFunction","override","signatures","_importTransform","emit","resolver","transform","expression","allowedInExpressions","mathWithTransform","_deleteTransform","wrapper","args","i","len","arg","valueOf","apply","factory","existingTransform","namespace","path","existing","instance","legacyFactoryAllowedInExpressions","JSON","stringify","dependencies","map","dependency","classes","meta","factoryAllowedInExpressions","object","unsafe","indexOf","isClass","isTransformFunction","type","docs","error","json","chain"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { isBigNumber, isComplex, isFraction, isMatrix, isUnit } from '../../utils/is';\nimport { isFactory, stripOptionalNotation } from '../../utils/factory';\nimport { hasOwnProperty, isLegacyFactory, lazy, traverse } from '../../utils/object';\nimport { contains } from '../../utils/array';\nimport { ArgumentsError } from '../../error/ArgumentsError';\nimport { warnOnce } from '../../utils/log';\nexport function importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (isLegacyFactory(value)) {\n        // legacy factories don't always have a name,\n        // let's not handle them via the new flatValues\n        _importLegacyFactory(value, options);\n      } else if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if (_typeof(value) === 'object') {\n        for (var _name in value) {\n          if (hasOwnProperty(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if (isFactory(value) || name !== undefined) {\n        var flatName = isFactory(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if (hasOwnProperty(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if (hasOwnProperty(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if (isFactory(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, _defineProperty({}, value.signature, value));\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {{factory: Function, name: string, path: string, math: boolean}} factory\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n  // TODO: _importLegacyFactory is deprecated since v6.0.0, clean up some day\n\n\n  function _importLegacyFactory(factory, options) {\n    warnOnce('Factories of type { name, factory } are deprecated since v6. ' + 'Please create your factory functions using the math.factory function.');\n\n    if (typeof factory.name === 'string') {\n      var name = factory.name;\n      var existingTransform = (name in math.expression.transform);\n      var namespace = factory.path ? traverse(math, factory.path) : math;\n      var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n      var resolver = function resolver() {\n        var instance = load(factory);\n\n        if (instance && typeof instance.transform === 'function') {\n          throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n        }\n\n        if (isTypedFunction(existing) && isTypedFunction(instance)) {\n          if (options.override) {// replace the existing typed function (nothing to do)\n          } else {\n            // merge the existing and new typed function\n            instance = typed(existing, instance);\n          }\n\n          return instance;\n        }\n\n        if (existing === undefined || options.override) {\n          return instance;\n        }\n\n        if (options.silent) {\n          return existing;\n        } else {\n          throw new Error('Cannot import \"' + name + '\": already exists');\n        }\n      };\n\n      if (factory.lazy !== false) {\n        lazy(namespace, name, resolver);\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            lazy(math.expression.mathWithTransform, name, resolver);\n          }\n        }\n      } else {\n        namespace[name] = resolver();\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || legacyFactoryAllowedInExpressions(factory)) {\n            math.expression.mathWithTransform[name] = resolver();\n          }\n        }\n      }\n\n      var key = factory.path ? factory.path + '.' + factory.name : factory.name;\n      importedFactories[key] = factory;\n      math.emit('import', name, resolver, factory.path);\n    } else {\n      // unnamed factory.\n      // no lazy loading\n      load(factory);\n    }\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if (contains(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = hasOwnProperty(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(stripOptionalNotation).forEach(function (dependency) {\n        if (contains(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      lazy(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          lazy(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !hasOwnProperty(unsafe, name);\n  }\n\n  function legacyFactoryAllowedInExpressions(factory) {\n    return factory.path === undefined && !hasOwnProperty(unsafe, factory.name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !hasOwnProperty(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}"]},"metadata":{},"sourceType":"module"}
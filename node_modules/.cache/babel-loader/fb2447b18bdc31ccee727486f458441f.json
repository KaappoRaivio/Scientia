{"ast":null,"code":"import { escape } from '../../utils/string';\nimport { getSafeProperty } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nimport { toSymbol } from '../../utils/latex';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Unit = _ref.Unit,\n      Node = _ref.Node;\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return name in scope ? getSafeProperty(scope, name) : getSafeProperty(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return name in scope ? getSafeProperty(scope, name) : isUnit ? new Unit(null, name) : undef(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {} // nothing to do, we don't have childs\n\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n  ;\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  function undef(name) {\n    throw new Error('Undefined symbol ' + name);\n  }\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = escape(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = toSymbol(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/node/SymbolNode.js"],"names":["escape","getSafeProperty","factory","toSymbol","name","dependencies","createSymbolNode","_ref","math","Unit","Node","isValuelessUnit","SymbolNode","SyntaxError","TypeError","prototype","type","isSymbolNode","_compile","argNames","scope","args","context","isUnit","undef","forEach","callback","map","clone","Error","_toString","options","toHTML","toJSON","mathjs","fromJSON","json","_toTex","symbol","isClass","isNode"],"mappings":"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","sourcesContent":["import { escape } from '../../utils/string';\nimport { getSafeProperty } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nimport { toSymbol } from '../../utils/latex';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Unit = _ref.Unit,\n      Node = _ref.Node;\n\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return name in scope ? getSafeProperty(scope, name) : getSafeProperty(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return name in scope ? getSafeProperty(scope, name) : isUnit ? new Unit(null, name) : undef(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {} // nothing to do, we don't have childs\n\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n  ;\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  function undef(name) {\n    throw new Error('Undefined symbol ' + name);\n  }\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = escape(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = toSymbol(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
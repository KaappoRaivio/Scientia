{"ast":null,"code":"// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nimport { hasOwnProperty } from '../utils/object';\nexport var properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:transpose': {\n    associativity: 'left'\n  }\n}];\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {number | null}\n */\n\nexport function getPrecedence(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node}\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\nexport function getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if (hasOwnProperty(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\nexport function isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if (hasOwnProperty(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/operators.js"],"names":["hasOwnProperty","properties","AssignmentNode","FunctionAssignmentNode","ConditionalNode","latexLeftParens","latexRightParens","latexParens","associativity","associativeWith","RelationalNode","RangeNode","getPrecedence","_node","parenthesis","node","getContent","identifier","getIdentifier","i","length","getAssociativity","index","property","Error","isAssociativeWith","nodeA","nodeB","a","b","identifierA","identifierB","Array"],"mappings":"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","sourcesContent":["// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nimport { hasOwnProperty } from '../utils/object';\nexport var properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:transpose': {\n    associativity: 'left'\n  }\n}];\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {number | null}\n */\n\nexport function getPrecedence(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node}\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\nexport function getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if (hasOwnProperty(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\nexport function isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if (hasOwnProperty(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}"]},"metadata":{},"sourceType":"module"}
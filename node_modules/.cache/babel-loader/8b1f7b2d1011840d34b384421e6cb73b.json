{"ast":null,"code":"import { isArray, isBigNumber, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is';\nimport { isInteger } from '../../utils/number';\nimport { format } from '../../utils/string';\nimport { clone, deepStrictEqual } from '../../utils/object';\nimport { arraySize, getArrayDataType, unsqueeze, validateIndex } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nimport { DimensionError } from '../../error/DimensionError';\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nexport var createSparseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      equalScalar = _ref.equalScalar,\n      Matrix = _ref.Matrix;\n  /**\n   * Sparse Matrix implementation. This type implements a Compressed Column Storage format\n   * for sparse matrices.\n   * @class SparseMatrix\n   */\n\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? clone(source._values) : undefined;\n      matrix._index = clone(source._index);\n      matrix._ptr = clone(source._ptr);\n      matrix._size = clone(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\n\n    var rows = data.length;\n    var columns = 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    } // check we have rows (empty array)\n\n\n    if (rows > 0) {\n      // column index\n      var j = 0;\n\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length); // loop rows\n\n\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i]; // check row is an array\n\n          if (isArray(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            } // check row has column\n\n\n            if (j < row.length) {\n              // value\n              var v = row[j]; // check value != 0\n\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v); // index\n\n\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            } // check value != 0 (row is a scalar)\n\n\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row); // index\n\n\n              matrix._index.push(i);\n            }\n          }\n        } // increment index\n\n\n        j++;\n      } while (j < columns);\n    } // store number of values in ptr\n\n\n    matrix._ptr.push(matrix._index.length); // size\n\n\n    matrix._size = [rows, columns];\n  }\n\n  SparseMatrix.prototype = new Matrix();\n  /**\n   * Create a new SparseMatrix\n   */\n\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf SparseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  SparseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._values, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new SparseMatrix\n   * @memberof SparseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Get the matrix density.\n   *\n   * Usage:\n   *     const density = matrix.density()                   // retrieve matrix density\n   *\n   * @memberof SparseMatrix\n   * @return {number}           The matrix density.\n   */\n\n\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // calculate density\n\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof SparseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    } // check arguments\n\n\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!isIndex(idx)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = idx.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    } // validate dimensions\n\n\n    var size = idx.size();\n\n    if (size.length !== matrix._size.length) {\n      throw new DimensionError(size.length, matrix._size.length);\n    } // vars\n\n\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\n\n    var min = idx.min();\n    var max = idx.max();\n\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      validateIndex(min[i], matrix._size[i]);\n      validateIndex(max[i], matrix._size[i]);\n    } // matrix arrays\n\n\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\n\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1); // workspace & permutation vector\n\n    var w = [];\n    var pv = []; // loop rows in resulting matrix\n\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0]; // mark i in workspace\n\n      w[i] = true;\n    }); // result matrix arrays\n\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = []; // loop columns in result matrix\n\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length); // loop values in column j\n\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k]; // check row is in result matrix\n\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]); // check we need to process values\n\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    }); // update ptr\n\n    ptr.push(index.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size(); // use array representation\n\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = arraySize(submatrix);\n    } // check index is a scalar\n\n\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      } // set value\n\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      } // check submatrix and index have the same dimensions\n\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // offsets\n\n\n      var x0 = index.min()[0];\n      var y0 = index.min()[1]; // submatrix rows and columns\n\n      var m = sSize[0];\n      var n = sSize[1]; // loop submatrix\n\n      for (var x = 0; x < m; x++) {\n        // loop columns\n        for (var y = 0; y < n; y++) {\n          // value at i, j\n          var v = submatrix[x][y]; // invoke set (zero value will remove entry from matrix)\n\n          matrix.set([x + x0, y + y0], v, defaultValue);\n        }\n      }\n    }\n\n    return matrix;\n  }\n  /**\n   * Get a single element from the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  SparseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // check i, j are valid\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[1]); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n\n    return 0;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} v\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be set to zero.\n   * @return {SparseMatrix} self\n   */\n\n\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, this._datatype);\n    } // check we need to resize matrix\n\n\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\n\n\n      rows = this._size[0];\n      columns = this._size[1];\n    } // check i, j are valid\n\n\n    validateIndex(i, rows);\n    validateIndex(j, columns); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      // insert value @ (i, j)\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\n    }\n\n    return this;\n  };\n\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    } // loop rows [top, bottom[\n\n\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    } // we did not find row\n\n\n    return top;\n  }\n\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1); // update pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v); // update row for k\n\n    index.splice(k, 0, i); // update column pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isArray(size)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // check sizes\n\n\n    size.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n      }\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, size[0], size[1], defaultValue);\n  };\n\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\n\n      value = typed.convert(value, matrix._datatype);\n    } // should we insert the value?\n\n\n    var ins = !eq(value, zero); // old columns and rows\n\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k; // check we need to increase columns\n\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\n\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value); // update matrix._index\n\n\n            matrix._index.push(i);\n          }\n        }\n      } // store number of matrix._values in matrix._ptr\n\n\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\n\n\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    } // update columns\n\n\n    c = columns; // check we need to increase rows\n\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0; // loop columns\n\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\n\n          k = matrix._ptr[j + 1] + n; // pointer\n\n          var p = 0; // loop new rows, initialize pointer\n\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value); // update matrix._index\n\n\n            matrix._index.splice(k + p, 0, i); // increment inserts\n\n\n            n++;\n          }\n        } // store number of matrix._values in matrix._ptr\n\n\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0; // loop columns\n\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\n\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\n\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k]; // check we need to delete value and matrix._index\n\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1); // remove item from matrix._index\n\n\n            matrix._index.splice(k, 1); // increase deletes\n\n\n            d++;\n          }\n        }\n      } // update matrix._ptr for current column\n\n\n      matrix._ptr[j] = matrix._values.length;\n    } // update matrix._size\n\n\n    matrix._size[0] = rows;\n    matrix._size[1] = columns; // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  SparseMatrix.prototype.reshape = function (size, copy) {\n    // validate arguments\n    if (!isArray(size)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    } // check sizes\n\n\n    size.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n      }\n    }); // m * n must not change\n\n    if (this._size[0] * this._size[1] !== size[0] * size[1]) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    } // matrix to reshape\n\n\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\n\n    if (this._size[0] === size[0] && this._size[1] === size[1]) {\n      return m;\n    } // Convert to COO format (generate a column index)\n\n\n    var colIndex = [];\n\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    } // Clone the values array\n\n\n    var values = m._values.slice(); // Clone the row index array\n\n\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\n\n\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % size[1];\n      rowIndex[_i] = Math.floor(flat / size[1]);\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n    // OR, we could easily just:\n    // 1. Remove all values from the matrix\n\n\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = size[1] + 1;\n    m._size = size.slice();\n\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n\n\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    } // The value indices are inserted out of order, but apparently that's... still OK?\n\n\n    return m;\n  };\n  /**\n   * Create a clone of the matrix\n   * @memberof SparseMatrix\n   * @return {SparseMatrix} clone\n   */\n\n\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? clone(this._values) : undefined,\n      index: clone(this._index),\n      ptr: clone(this._ptr),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof SparseMatrix\n   * @returns {number[]} size\n   */\n\n\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {SparseMatrix} matrix\n   */\n\n\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // invoke callback\n\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      return callback(v, [i, j], me);\n    }; // invoke _map\n\n\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on the interval\n   * [minRow..maxRow, minColumn..maxColumn].\n   */\n\n\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = []; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype);\n    } // invoke callback\n\n\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y); // check value != 0\n\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v); // index\n\n        index.push(x);\n      }\n    }; // loop columns\n\n\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k]; // check i is in range\n\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    } // store number of values in ptr\n\n\n    ptr.push(values.length); // return sparse matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   */\n\n\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k]; // value @ k\n\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n  /**\n   * Create an Array with a copy of the data of the SparseMatrix\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n  /**\n   * Get the primitive value of the SparseMatrix: a two dimensions array\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1]; // result\n\n    var a = []; // vars\n\n    var i, j; // initialize array\n\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k]; // set value (use one for pattern matrix)\n\n        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;\n      }\n    }\n\n    return a;\n  }\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof SparseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // density\n\n    var density = this.density(); // rows & columns\n\n    var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\\n'; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k]; // append value\n\n        str += '\\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.toString = function () {\n    return format(this.toArray());\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {Object}\n   */\n\n\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof SparseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\n   */\n\n\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\n\n    var values = [];\n    var index = [];\n    var ptr = []; // initial ptr value\n\n    ptr[0] = 0; // loop columns\n\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\n\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x]; // check row\n\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]); // store row\n\n          index[values.length - 1] = i - kSub; // exit loop\n\n          break;\n        }\n      }\n    } // close ptr\n\n\n    ptr.push(values.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof SparseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\n   *                       where mathjs is optional\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {Array} size                       The matrix size.\n   * @param {number | Array | Matrix } value   The values for the diagonal.\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]            The default value for non-diagonal\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\n   *\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    } // equal signature to use\n\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // create arrays\n\n\n    var values = [];\n    var index = [];\n    var ptr = []; // loop items\n\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length); // diagonal index\n\n      var i = j - kSuper; // check we need to set diagonal value\n\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i); // check for zero\n\n\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub); // add value\n\n          values.push(v);\n        }\n      }\n    } // last value should be number of values\n\n\n    ptr.push(values.length); // create SparseMatrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Loop rows with data in column j.\n   *\n   * @param {number} j            Column\n   * @param {Array} values        Matrix values\n   * @param {Array} index         Matrix row indeces\n   * @param {Array} ptr           Matrix column pointers\n   * @param {Function} callback   Callback function invoked for every row in column j\n   */\n\n\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1]; // loop\n\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n  /**\n   * Swap rows x and y in Sparse Matrix data structures.\n   *\n   * @param {number} x         Matrix row index 1\n   * @param {number} y         Matrix row index 2\n   * @param {number} columns   Number of columns in matrix\n   * @param {Array} values     Matrix values\n   * @param {Array} index      Matrix row indeces\n   * @param {Array} ptr        Matrix column pointers\n   */\n\n\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // find value index @ x\n\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\n\n\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\n\n\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        } // next column\n\n\n        continue;\n      } // check x row exist & no y row\n\n\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined; // insert value @ y\n\n        index.splice(ky, 0, y);\n\n        if (values) {\n          values.splice(ky, 0, vx);\n        } // remove value @ x (adjust array index if needed)\n\n\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        } // next column\n\n\n        continue;\n      } // check y row exist & no x row\n\n\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined; // insert value @ x\n\n        index.splice(kx, 0, x);\n\n        if (values) {\n          values.splice(kx, 0, vy);\n        } // remove value @ y (adjust array index if needed)\n\n\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n\n  return SparseMatrix;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/type/matrix/SparseMatrix.js"],"names":["isArray","isBigNumber","isIndex","isMatrix","isNumber","isString","typeOf","isInteger","format","clone","deepStrictEqual","arraySize","getArrayDataType","unsqueeze","validateIndex","factory","DimensionError","name","dependencies","createSparseMatrixClass","_ref","typed","equalScalar","Matrix","SparseMatrix","data","datatype","SyntaxError","Error","_createFromMatrix","index","ptr","size","_values","values","_index","_ptr","_size","_datatype","_createFromArray","TypeError","matrix","source","type","undefined","valueOf","rows","length","columns","eq","zero","find","convert","j","push","i","row","v","prototype","createSparseMatrix","isSparseMatrix","getDataType","storage","create","density","subset","replacement","defaultValue","arguments","_getsubset","_setsubset","idx","isScalar","get","min","ii","k","kk","max","mvalues","mindex","mptr","dimension","w","pv","forEach","r","submatrix","iSize","sSize","toArray","set","outer","x0","y0","m","n","x","y","_getValueIndex","_resize","Math","_remove","_insert","top","bottom","splice","resize","copy","value","ins","c","p","d","k0","k1","reshape","colIndex","slice","rowIndex","_i","r1","c1","flat","floor","_i2","h","_i3","_j","map","callback","skipZeros","me","invoke","_map","minRow","maxRow","minColumn","maxColumn","_k","_i4","_i5","_k2","_i6","_i7","_toArray","a","options","str","toString","toJSON","mathjs","diagonal","toNumber","kSuper","kSub","fromJSON","json","s","_value","ms","swapRows","_swapRows","_forEachRow","kx","ky","vx","vy","isClass"],"mappings":"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","sourcesContent":["import { isArray, isBigNumber, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is';\nimport { isInteger } from '../../utils/number';\nimport { format } from '../../utils/string';\nimport { clone, deepStrictEqual } from '../../utils/object';\nimport { arraySize, getArrayDataType, unsqueeze, validateIndex } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nimport { DimensionError } from '../../error/DimensionError';\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nexport var createSparseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      equalScalar = _ref.equalScalar,\n      Matrix = _ref.Matrix;\n\n  /**\n   * Sparse Matrix implementation. This type implements a Compressed Column Storage format\n   * for sparse matrices.\n   * @class SparseMatrix\n   */\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? clone(source._values) : undefined;\n      matrix._index = clone(source._index);\n      matrix._ptr = clone(source._ptr);\n      matrix._size = clone(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\n\n    var rows = data.length;\n    var columns = 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    } // check we have rows (empty array)\n\n\n    if (rows > 0) {\n      // column index\n      var j = 0;\n\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length); // loop rows\n\n\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i]; // check row is an array\n\n          if (isArray(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            } // check row has column\n\n\n            if (j < row.length) {\n              // value\n              var v = row[j]; // check value != 0\n\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v); // index\n\n\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            } // check value != 0 (row is a scalar)\n\n\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row); // index\n\n\n              matrix._index.push(i);\n            }\n          }\n        } // increment index\n\n\n        j++;\n      } while (j < columns);\n    } // store number of values in ptr\n\n\n    matrix._ptr.push(matrix._index.length); // size\n\n\n    matrix._size = [rows, columns];\n  }\n\n  SparseMatrix.prototype = new Matrix();\n  /**\n   * Create a new SparseMatrix\n   */\n\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf SparseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  SparseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._values, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()   // retrieve storage format\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()    // retrieve matrix datatype\n   *\n   * @memberof SparseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new SparseMatrix\n   * @memberof SparseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\n   * Get the matrix density.\n   *\n   * Usage:\n   *     const density = matrix.density()                   // retrieve matrix density\n   *\n   * @memberof SparseMatrix\n   * @return {number}           The matrix density.\n   */\n\n\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // calculate density\n\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof SparseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    } // check arguments\n\n\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!isIndex(idx)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = idx.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    } // validate dimensions\n\n\n    var size = idx.size();\n\n    if (size.length !== matrix._size.length) {\n      throw new DimensionError(size.length, matrix._size.length);\n    } // vars\n\n\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\n\n    var min = idx.min();\n    var max = idx.max();\n\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      validateIndex(min[i], matrix._size[i]);\n      validateIndex(max[i], matrix._size[i]);\n    } // matrix arrays\n\n\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\n\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1); // workspace & permutation vector\n\n    var w = [];\n    var pv = []; // loop rows in resulting matrix\n\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0]; // mark i in workspace\n\n      w[i] = true;\n    }); // result matrix arrays\n\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = []; // loop columns in result matrix\n\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length); // loop values in column j\n\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k]; // check row is in result matrix\n\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]); // check we need to process values\n\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    }); // update ptr\n\n    ptr.push(index.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size(); // use array representation\n\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = arraySize(submatrix);\n    } // check index is a scalar\n\n\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      } // set value\n\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      } // check submatrix and index have the same dimensions\n\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // offsets\n\n\n      var x0 = index.min()[0];\n      var y0 = index.min()[1]; // submatrix rows and columns\n\n      var m = sSize[0];\n      var n = sSize[1]; // loop submatrix\n\n      for (var x = 0; x < m; x++) {\n        // loop columns\n        for (var y = 0; y < n; y++) {\n          // value at i, j\n          var v = submatrix[x][y]; // invoke set (zero value will remove entry from matrix)\n\n          matrix.set([x + x0, y + y0], v, defaultValue);\n        }\n      }\n    }\n\n    return matrix;\n  }\n  /**\n   * Get a single element from the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  SparseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // check i, j are valid\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[1]); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n\n    return 0;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof SparseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} v\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be set to zero.\n   * @return {SparseMatrix} self\n   */\n\n\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, this._datatype);\n    } // check we need to resize matrix\n\n\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\n\n\n      rows = this._size[0];\n      columns = this._size[1];\n    } // check i, j are valid\n\n\n    validateIndex(i, rows);\n    validateIndex(j, columns); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      // insert value @ (i, j)\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\n    }\n\n    return this;\n  };\n\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    } // loop rows [top, bottom[\n\n\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    } // we did not find row\n\n\n    return top;\n  }\n\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1); // update pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v); // update row for k\n\n    index.splice(k, 0, i); // update column pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isArray(size)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // check sizes\n\n\n    size.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n      }\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, size[0], size[1], defaultValue);\n  };\n\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\n\n      value = typed.convert(value, matrix._datatype);\n    } // should we insert the value?\n\n\n    var ins = !eq(value, zero); // old columns and rows\n\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k; // check we need to increase columns\n\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\n\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value); // update matrix._index\n\n\n            matrix._index.push(i);\n          }\n        }\n      } // store number of matrix._values in matrix._ptr\n\n\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\n\n\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    } // update columns\n\n\n    c = columns; // check we need to increase rows\n\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0; // loop columns\n\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\n\n          k = matrix._ptr[j + 1] + n; // pointer\n\n          var p = 0; // loop new rows, initialize pointer\n\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value); // update matrix._index\n\n\n            matrix._index.splice(k + p, 0, i); // increment inserts\n\n\n            n++;\n          }\n        } // store number of matrix._values in matrix._ptr\n\n\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0; // loop columns\n\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\n\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\n\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k]; // check we need to delete value and matrix._index\n\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1); // remove item from matrix._index\n\n\n            matrix._index.splice(k, 1); // increase deletes\n\n\n            d++;\n          }\n        }\n      } // update matrix._ptr for current column\n\n\n      matrix._ptr[j] = matrix._values.length;\n    } // update matrix._size\n\n\n    matrix._size[0] = rows;\n    matrix._size[1] = columns; // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof SparseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  SparseMatrix.prototype.reshape = function (size, copy) {\n    // validate arguments\n    if (!isArray(size)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    } // check sizes\n\n\n    size.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n      }\n    }); // m * n must not change\n\n    if (this._size[0] * this._size[1] !== size[0] * size[1]) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    } // matrix to reshape\n\n\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\n\n    if (this._size[0] === size[0] && this._size[1] === size[1]) {\n      return m;\n    } // Convert to COO format (generate a column index)\n\n\n    var colIndex = [];\n\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    } // Clone the values array\n\n\n    var values = m._values.slice(); // Clone the row index array\n\n\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\n\n\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % size[1];\n      rowIndex[_i] = Math.floor(flat / size[1]);\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n    // OR, we could easily just:\n    // 1. Remove all values from the matrix\n\n\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = size[1] + 1;\n    m._size = size.slice();\n\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n\n\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    } // The value indices are inserted out of order, but apparently that's... still OK?\n\n\n    return m;\n  };\n  /**\n   * Create a clone of the matrix\n   * @memberof SparseMatrix\n   * @return {SparseMatrix} clone\n   */\n\n\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? clone(this._values) : undefined,\n      index: clone(this._index),\n      ptr: clone(this._ptr),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof SparseMatrix\n   * @returns {number[]} size\n   */\n\n\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   *\n   * @return {SparseMatrix} matrix\n   */\n\n\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // invoke callback\n\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      return callback(v, [i, j], me);\n    }; // invoke _map\n\n\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on the interval\n   * [minRow..maxRow, minColumn..maxColumn].\n   */\n\n\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = []; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype);\n    } // invoke callback\n\n\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y); // check value != 0\n\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v); // index\n\n        index.push(x);\n      }\n    }; // loop columns\n\n\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k]; // check i is in range\n\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    } // store number of values in ptr\n\n\n    ptr.push(values.length); // return sparse matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof SparseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\n   */\n\n\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k]; // value @ k\n\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n  /**\n   * Create an Array with a copy of the data of the SparseMatrix\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n  /**\n   * Get the primitive value of the SparseMatrix: a two dimensions array\n   * @memberof SparseMatrix\n   * @returns {Array} array\n   */\n\n\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1]; // result\n\n    var a = []; // vars\n\n    var i, j; // initialize array\n\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k]; // set value (use one for pattern matrix)\n\n        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;\n      }\n    }\n\n    return a;\n  }\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof SparseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // density\n\n    var density = this.density(); // rows & columns\n\n    var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\\n'; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k]; // append value\n\n        str += '\\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {string} str\n   */\n\n\n  SparseMatrix.prototype.toString = function () {\n    return format(this.toArray());\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof SparseMatrix\n   * @returns {Object}\n   */\n\n\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof SparseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\n   */\n\n\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\n\n    var values = [];\n    var index = [];\n    var ptr = []; // initial ptr value\n\n    ptr[0] = 0; // loop columns\n\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\n\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x]; // check row\n\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]); // store row\n\n          index[values.length - 1] = i - kSub; // exit loop\n\n          break;\n        }\n      }\n    } // close ptr\n\n\n    ptr.push(values.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof SparseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\n   *                       where mathjs is optional\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {Array} size                       The matrix size.\n   * @param {number | Array | Matrix } value   The values for the diagonal.\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]            The default value for non-diagonal\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\n   *\n   * @returns {SparseMatrix}\n   */\n\n\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    } // equal signature to use\n\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // create arrays\n\n\n    var values = [];\n    var index = [];\n    var ptr = []; // loop items\n\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length); // diagonal index\n\n      var i = j - kSuper; // check we need to set diagonal value\n\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i); // check for zero\n\n\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub); // add value\n\n          values.push(v);\n        }\n      }\n    } // last value should be number of values\n\n\n    ptr.push(values.length); // create SparseMatrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof SparseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Loop rows with data in column j.\n   *\n   * @param {number} j            Column\n   * @param {Array} values        Matrix values\n   * @param {Array} index         Matrix row indeces\n   * @param {Array} ptr           Matrix column pointers\n   * @param {Function} callback   Callback function invoked for every row in column j\n   */\n\n\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1]; // loop\n\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n  /**\n   * Swap rows x and y in Sparse Matrix data structures.\n   *\n   * @param {number} x         Matrix row index 1\n   * @param {number} y         Matrix row index 2\n   * @param {number} columns   Number of columns in matrix\n   * @param {Array} values     Matrix values\n   * @param {Array} index      Matrix row indeces\n   * @param {Array} ptr        Matrix column pointers\n   */\n\n\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // find value index @ x\n\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\n\n\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\n\n\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        } // next column\n\n\n        continue;\n      } // check x row exist & no y row\n\n\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined; // insert value @ y\n\n        index.splice(ky, 0, y);\n\n        if (values) {\n          values.splice(ky, 0, vx);\n        } // remove value @ x (adjust array index if needed)\n\n\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        } // next column\n\n\n        continue;\n      } // check y row exist & no x row\n\n\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined; // insert value @ x\n\n        index.splice(kx, 0, x);\n\n        if (values) {\n          values.splice(kx, 0, vy);\n        } // remove value @ y (adjust array index if needed)\n\n\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n\n  return SparseMatrix;\n}, {\n  isClass: true\n});"]},"metadata":{},"sourceType":"module"}
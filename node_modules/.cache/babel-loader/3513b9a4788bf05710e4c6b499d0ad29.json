{"ast":null,"code":"import { csMarked } from './csMarked';\nimport { csMark } from './csMark';\nimport { csUnflip } from './csUnflip';\n/**\n * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting\n * at nodes in B (see csReach()).\n *\n * @param {Number}  j               The starting node for the DFS algorithm\n * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored\n * @param {Number}  top             Start index in stack xi[top..n-1]\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n *\n * @return {Number}                 New value of top\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\n\nexport function csDfs(j, g, top, xi, pinv) {\n  // g arrays\n  var index = g._index;\n  var ptr = g._ptr;\n  var size = g._size; // columns\n\n  var n = size[1]; // vars\n\n  var i, p, p2; // initialize head\n\n  var head = 0; // initialize the recursion stack\n\n  xi[0] = j; // loop\n\n  while (head >= 0) {\n    // get j from the top of the recursion stack\n    j = xi[head]; // apply permutation vector\n\n    var jnew = pinv ? pinv[j] : j; // check node j is marked\n\n    if (!csMarked(ptr, j)) {\n      // mark node j as visited\n      csMark(ptr, j); // update stack (last n entries in xi)\n\n      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);\n    } // node j done if no unvisited neighbors\n\n\n    var done = 1; // examine all neighbors of j, stack (last n entries in xi)\n\n    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {\n      // consider neighbor node i\n      i = index[p]; // check we have visited node i, skip it\n\n      if (csMarked(ptr, i)) {\n        continue;\n      } // pause depth-first search of node j, update stack (last n entries in xi)\n\n\n      xi[n + head] = p; // start dfs at node i\n\n      xi[++head] = i; // node j is not done\n\n      done = 0; // break, to start dfs(i)\n\n      break;\n    } // check depth-first search at node j is done\n\n\n    if (done) {\n      // remove j from the recursion stack\n      head--; // and place in the output stack\n\n      xi[--top] = j;\n    }\n  }\n\n  return top;\n}","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/algebra/sparse/csDfs.js"],"names":["csMarked","csMark","csUnflip","csDfs","j","g","top","xi","pinv","index","_index","ptr","_ptr","size","_size","n","i","p","p2","head","jnew","done"],"mappings":"AAAA,SAASA,QAAT,QAAyB,YAAzB;AACA,SAASC,MAAT,QAAuB,UAAvB;AACA,SAASC,QAAT,QAAyB,YAAzB;AACA;;;;;;;;;;;;;;;;;AAiBA,OAAO,SAASC,KAAT,CAAeC,CAAf,EAAkBC,CAAlB,EAAqBC,GAArB,EAA0BC,EAA1B,EAA8BC,IAA9B,EAAoC;AACzC;AACA,MAAIC,KAAK,GAAGJ,CAAC,CAACK,MAAd;AACA,MAAIC,GAAG,GAAGN,CAAC,CAACO,IAAZ;AACA,MAAIC,IAAI,GAAGR,CAAC,CAACS,KAAb,CAJyC,CAIrB;;AAEpB,MAAIC,CAAC,GAAGF,IAAI,CAAC,CAAD,CAAZ,CANyC,CAMxB;;AAEjB,MAAIG,CAAJ,EAAOC,CAAP,EAAUC,EAAV,CARyC,CAQ3B;;AAEd,MAAIC,IAAI,GAAG,CAAX,CAVyC,CAU3B;;AAEdZ,EAAAA,EAAE,CAAC,CAAD,CAAF,GAAQH,CAAR,CAZyC,CAY9B;;AAEX,SAAOe,IAAI,IAAI,CAAf,EAAkB;AAChB;AACAf,IAAAA,CAAC,GAAGG,EAAE,CAACY,IAAD,CAAN,CAFgB,CAEF;;AAEd,QAAIC,IAAI,GAAGZ,IAAI,GAAGA,IAAI,CAACJ,CAAD,CAAP,GAAaA,CAA5B,CAJgB,CAIe;;AAE/B,QAAI,CAACJ,QAAQ,CAACW,GAAD,EAAMP,CAAN,CAAb,EAAuB;AACrB;AACAH,MAAAA,MAAM,CAACU,GAAD,EAAMP,CAAN,CAAN,CAFqB,CAEL;;AAEhBG,MAAAA,EAAE,CAACQ,CAAC,GAAGI,IAAL,CAAF,GAAeC,IAAI,GAAG,CAAP,GAAW,CAAX,GAAelB,QAAQ,CAACS,GAAG,CAACS,IAAD,CAAJ,CAAtC;AACD,KAXe,CAWd;;;AAGF,QAAIC,IAAI,GAAG,CAAX,CAdgB,CAcF;;AAEd,SAAKJ,CAAC,GAAGV,EAAE,CAACQ,CAAC,GAAGI,IAAL,CAAN,EAAkBD,EAAE,GAAGE,IAAI,GAAG,CAAP,GAAW,CAAX,GAAelB,QAAQ,CAACS,GAAG,CAACS,IAAI,GAAG,CAAR,CAAJ,CAAnD,EAAoEH,CAAC,GAAGC,EAAxE,EAA4ED,CAAC,EAA7E,EAAiF;AAC/E;AACAD,MAAAA,CAAC,GAAGP,KAAK,CAACQ,CAAD,CAAT,CAF+E,CAEjE;;AAEd,UAAIjB,QAAQ,CAACW,GAAD,EAAMK,CAAN,CAAZ,EAAsB;AACpB;AACD,OAN8E,CAM7E;;;AAGFT,MAAAA,EAAE,CAACQ,CAAC,GAAGI,IAAL,CAAF,GAAeF,CAAf,CAT+E,CAS7D;;AAElBV,MAAAA,EAAE,CAAC,EAAEY,IAAH,CAAF,GAAaH,CAAb,CAX+E,CAW/D;;AAEhBK,MAAAA,IAAI,GAAG,CAAP,CAb+E,CAarE;;AAEV;AACD,KAhCe,CAgCd;;;AAGF,QAAIA,IAAJ,EAAU;AACR;AACAF,MAAAA,IAAI,GAFI,CAEA;;AAERZ,MAAAA,EAAE,CAAC,EAAED,GAAH,CAAF,GAAYF,CAAZ;AACD;AACF;;AAED,SAAOE,GAAP;AACD","sourcesContent":["import { csMarked } from './csMarked';\nimport { csMark } from './csMark';\nimport { csUnflip } from './csUnflip';\n/**\n * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting\n * at nodes in B (see csReach()).\n *\n * @param {Number}  j               The starting node for the DFS algorithm\n * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored\n * @param {Number}  top             Start index in stack xi[top..n-1]\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n *\n * @return {Number}                 New value of top\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\n\nexport function csDfs(j, g, top, xi, pinv) {\n  // g arrays\n  var index = g._index;\n  var ptr = g._ptr;\n  var size = g._size; // columns\n\n  var n = size[1]; // vars\n\n  var i, p, p2; // initialize head\n\n  var head = 0; // initialize the recursion stack\n\n  xi[0] = j; // loop\n\n  while (head >= 0) {\n    // get j from the top of the recursion stack\n    j = xi[head]; // apply permutation vector\n\n    var jnew = pinv ? pinv[j] : j; // check node j is marked\n\n    if (!csMarked(ptr, j)) {\n      // mark node j as visited\n      csMark(ptr, j); // update stack (last n entries in xi)\n\n      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);\n    } // node j done if no unvisited neighbors\n\n\n    var done = 1; // examine all neighbors of j, stack (last n entries in xi)\n\n    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {\n      // consider neighbor node i\n      i = index[p]; // check we have visited node i, skip it\n\n      if (csMarked(ptr, i)) {\n        continue;\n      } // pause depth-first search of node j, update stack (last n entries in xi)\n\n\n      xi[n + head] = p; // start dfs at node i\n\n      xi[++head] = i; // node j is not done\n\n      done = 0; // break, to start dfs(i)\n\n      break;\n    } // check depth-first search at node j is done\n\n\n    if (done) {\n      // remove j from the recursion stack\n      head--; // and place in the output stack\n\n      xi[--top] = j;\n    }\n  }\n\n  return top;\n}"]},"metadata":{},"sourceType":"module"}
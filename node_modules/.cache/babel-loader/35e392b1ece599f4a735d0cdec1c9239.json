{"ast":null,"code":"import { factory } from '../../../utils/factory';\nimport { createSolveValidation } from './utils/solveValidation';\nvar name = 'lsolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createLsolve = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = createSolveValidation({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Solves the linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolve(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\n   *\n   * See also:\n   *\n   *    lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      // create dense matrix from array\n      var m = matrix(a); // use matrix implementation\n\n      var r = _denseForwardSubstitution(m, b); // result\n\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = []; // data\n\n    var data = m._data; // forward solve m * x = b, loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // x[j]\n\n      var xj = void 0; // forward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = data[j][j]; // check vjj\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j + 1; i < rows; i++) {\n          // update copy of b\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];\n        }\n      } else {\n        // zero @ j\n        xj = 0;\n      } // update x\n\n\n      x[j] = [xj];\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // matrix arrays\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // vars\n\n    var i, k; // result\n\n    var x = []; // forward solve m * x = b, loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // forward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = 0; // lower triangular matrix values & index (column j)\n\n        var jvalues = [];\n        var jindex = []; // last index in column\n\n        var l = ptr[j + 1]; // values in column, find value @ [j, j]\n\n        for (k = ptr[j]; k < l; k++) {\n          // row\n          i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            // update vjj\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jvalues.push(values[k]);\n            jindex.push(i);\n          }\n        } // at this point we must have a value @ [j, j]\n\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved, there is no value @ [j, j]\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        var xj = divideScalar(bj, vjj); // loop lower triangular\n\n        for (k = 0, l = jindex.length; k < l; k++) {\n          // row\n          i = jindex[k]; // update copy of b\n\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, jvalues[k]))];\n        } // update x\n\n\n        x[j] = [xj];\n      } else {\n        // update x\n        x[j] = [0];\n      }\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/solver/lsolve.js"],"names":["factory","createSolveValidation","name","dependencies","createLsolve","_ref","typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix","solveValidation","SparseMatrixArrayMatrix","m","b","_sparseForwardSubstitution","DenseMatrixArrayMatrix","_denseForwardSubstitution","ArrayArrayMatrix","a","r","valueOf","bdata","_data","rows","_size","columns","x","data","j","bj","xj","vjj","Error","i","size","values","_values","index","_index","ptr","_ptr","k","jvalues","jindex","l","push","length"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory';\nimport { createSolveValidation } from './utils/solveValidation';\nvar name = 'lsolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createLsolve = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = createSolveValidation({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Solves the linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolve(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\n   *\n   * See also:\n   *\n   *    lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      // process matrix\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      // create dense matrix from array\n      var m = matrix(a); // use matrix implementation\n\n      var r = _denseForwardSubstitution(m, b); // result\n\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = []; // data\n\n    var data = m._data; // forward solve m * x = b, loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // x[j]\n\n      var xj = void 0; // forward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = data[j][j]; // check vjj\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j + 1; i < rows; i++) {\n          // update copy of b\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, data[i][j]))];\n        }\n      } else {\n        // zero @ j\n        xj = 0;\n      } // update x\n\n\n      x[j] = [xj];\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true); // column vector data\n\n    var bdata = b._data; // rows & columns\n\n    var rows = m._size[0];\n    var columns = m._size[1]; // matrix arrays\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // vars\n\n    var i, k; // result\n\n    var x = []; // forward solve m * x = b, loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // forward substitution (outer product) avoids inner looping when bj === 0\n\n      if (!equalScalar(bj, 0)) {\n        // value @ [j, j]\n        var vjj = 0; // lower triangular matrix values & index (column j)\n\n        var jvalues = [];\n        var jindex = []; // last index in column\n\n        var l = ptr[j + 1]; // values in column, find value @ [j, j]\n\n        for (k = ptr[j]; k < l; k++) {\n          // row\n          i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            // update vjj\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jvalues.push(values[k]);\n            jindex.push(i);\n          }\n        } // at this point we must have a value @ [j, j]\n\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved, there is no value @ [j, j]\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        } // calculate xj\n\n\n        var xj = divideScalar(bj, vjj); // loop lower triangular\n\n        for (k = 0, l = jindex.length; k < l; k++) {\n          // row\n          i = jindex[k]; // update copy of b\n\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, jvalues[k]))];\n        } // update x\n\n\n        x[j] = [xj];\n      } else {\n        // update x\n        x[j] = [0];\n      }\n    } // return vector\n\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { isBigNumber } from '../../utils/is';\nimport { format, sign } from '../../utils/number';\nimport { factory } from '../../utils/factory';\nvar name = 'Range';\nvar dependencies = [];\nexport var createRangeClass = /* #__PURE__ */factory(name, dependencies, function () {\n  /**\n   * Create a range. A range has a start, step, and end, and contains functions\n   * to iterate over the range.\n   *\n   * A range can be constructed as:\n   *\n   *     const range = new Range(start, end)\n   *     const range = new Range(start, end, step)\n   *\n   * To get the result of the range:\n   *     range.forEach(function (x) {\n   *         console.log(x)\n   *     })\n   *     range.map(function (x) {\n   *         return math.sin(x)\n   *     })\n   *     range.toArray()\n   *\n   * Example usage:\n   *\n   *     const c = new Range(2, 6)       // 2:1:5\n   *     c.toArray()                     // [2, 3, 4, 5]\n   *     const d = new Range(2, -3, -1)  // 2:-1:-2\n   *     d.toArray()                     // [2, 1, 0, -1, -2]\n   *\n   * @class Range\n   * @constructor Range\n   * @param {number} start  included lower bound\n   * @param {number} end    excluded upper bound\n   * @param {number} [step] step size, default value is 1\n   */\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    var hasStart = start !== null && start !== undefined;\n    var hasEnd = end !== null && end !== undefined;\n    var hasStep = step !== null && step !== undefined;\n\n    if (hasStart) {\n      if (isBigNumber(start)) {\n        start = start.toNumber();\n      } else if (typeof start !== 'number') {\n        throw new TypeError('Parameter start must be a number');\n      }\n    }\n\n    if (hasEnd) {\n      if (isBigNumber(end)) {\n        end = end.toNumber();\n      } else if (typeof end !== 'number') {\n        throw new TypeError('Parameter end must be a number');\n      }\n    }\n\n    if (hasStep) {\n      if (isBigNumber(step)) {\n        step = step.toNumber();\n      } else if (typeof step !== 'number') {\n        throw new TypeError('Parameter step must be a number');\n      }\n    }\n\n    this.start = hasStart ? parseFloat(start) : 0;\n    this.end = hasEnd ? parseFloat(end) : 0;\n    this.step = hasStep ? parseFloat(step) : 1;\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Range.prototype.type = 'Range';\n  Range.prototype.isRange = true;\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @memberof Range\n   * @param {string} str\n   * @return {Range | null} range\n   */\n\n  Range.parse = function (str) {\n    if (typeof str !== 'string') {\n      return null;\n    }\n\n    var args = str.split(':');\n    var nums = args.map(function (arg) {\n      return parseFloat(arg);\n    });\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n\n    if (invalid) {\n      return null;\n    }\n\n    switch (nums.length) {\n      case 2:\n        return new Range(nums[0], nums[1]);\n\n      case 3:\n        return new Range(nums[0], nums[2], nums[1]);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Create a clone of the range\n   * @return {Range} clone\n   */\n\n\n  Range.prototype.clone = function () {\n    return new Range(this.start, this.end, this.step);\n  };\n  /**\n   * Retrieve the size of the range.\n   * Returns an array containing one number, the number of elements in the range.\n   * @memberof Range\n   * @returns {number[]} size\n   */\n\n\n  Range.prototype.size = function () {\n    var len = 0;\n    var start = this.start;\n    var step = this.step;\n    var end = this.end;\n    var diff = end - start;\n\n    if (sign(step) === sign(diff)) {\n      len = Math.ceil(diff / step);\n    } else if (diff === 0) {\n      len = 0;\n    }\n\n    if (isNaN(len)) {\n      len = 0;\n    }\n\n    return [len];\n  };\n  /**\n   * Calculate the minimum value in the range\n   * @memberof Range\n   * @return {number | undefined} min\n   */\n\n\n  Range.prototype.min = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start;\n      } else {\n        // negative step\n        return this.start + (size - 1) * this.step;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Calculate the maximum value in the range\n   * @memberof Range\n   * @return {number | undefined} max\n   */\n\n\n  Range.prototype.max = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start + (size - 1) * this.step;\n      } else {\n        // negative step\n        return this.start;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Execute a callback function for each value in the range.\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Range being traversed.\n   */\n\n\n  Range.prototype.forEach = function (callback) {\n    var x = this.start;\n    var step = this.step;\n    var end = this.end;\n    var i = 0;\n\n    if (step > 0) {\n      while (x < end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    } else if (step < 0) {\n      while (x > end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    }\n  };\n  /**\n   * Execute a callback function for each value in the Range, and return the\n   * results as an array\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.map = function (callback) {\n    var array = [];\n    this.forEach(function (value, index, obj) {\n      array[index[0]] = callback(value, index, obj);\n    });\n    return array;\n  };\n  /**\n   * Create an Array with a copy of the Ranges data\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.toArray = function () {\n    var array = [];\n    this.forEach(function (value, index) {\n      array[index[0]] = value;\n    });\n    return array;\n  };\n  /**\n   * Get the primitive value of the Range, a one dimensional array\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.valueOf = function () {\n    // TODO: implement a caching mechanism for range.valueOf()\n    return this.toArray();\n  };\n  /**\n   * Get a string representation of the range, with optional formatting options.\n   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'\n   * @memberof Range\n   * @param {Object | number | function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  Range.prototype.format = function (options) {\n    var str = format(this.start, options);\n\n    if (this.step !== 1) {\n      str += ':' + format(this.step, options);\n    }\n\n    str += ':' + format(this.end, options);\n    return str;\n  };\n  /**\n   * Get a string representation of the range.\n   * @memberof Range\n   * @returns {string}\n   */\n\n\n  Range.prototype.toString = function () {\n    return this.format();\n  };\n  /**\n   * Get a JSON representation of the range\n   * @memberof Range\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   */\n\n\n  Range.prototype.toJSON = function () {\n    return {\n      mathjs: 'Range',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate a Range from a JSON object\n   * @memberof Range\n   * @param {Object} json A JSON object structured as:\n   *                      `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   * @return {Range}\n   */\n\n\n  Range.fromJSON = function (json) {\n    return new Range(json.start, json.end, json.step);\n  };\n\n  return Range;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/type/matrix/Range.js"],"names":["isBigNumber","format","sign","factory","name","dependencies","createRangeClass","Range","start","end","step","SyntaxError","hasStart","undefined","hasEnd","hasStep","toNumber","TypeError","parseFloat","prototype","type","isRange","parse","str","args","split","nums","map","arg","invalid","some","num","isNaN","length","clone","size","len","diff","Math","ceil","min","max","forEach","callback","x","i","array","value","index","obj","toArray","valueOf","options","toString","toJSON","mathjs","fromJSON","json","isClass"],"mappings":"AAAA,SAASA,WAAT,QAA4B,gBAA5B;AACA,SAASC,MAAT,EAAiBC,IAAjB,QAA6B,oBAA7B;AACA,SAASC,OAAT,QAAwB,qBAAxB;AACA,IAAIC,IAAI,GAAG,OAAX;AACA,IAAIC,YAAY,GAAG,EAAnB;AACA,OAAO,IAAIC,gBAAgB,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,YAAY;AACnF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,WAASE,KAAT,CAAeC,KAAf,EAAsBC,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,QAAI,EAAE,gBAAgBH,KAAlB,CAAJ,EAA8B;AAC5B,YAAM,IAAII,WAAJ,CAAgB,kDAAhB,CAAN;AACD;;AAED,QAAIC,QAAQ,GAAGJ,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKK,SAA3C;AACA,QAAIC,MAAM,GAAGL,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAKI,SAArC;AACA,QAAIE,OAAO,GAAGL,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAKG,SAAxC;;AAEA,QAAID,QAAJ,EAAc;AACZ,UAAIZ,WAAW,CAACQ,KAAD,CAAf,EAAwB;AACtBA,QAAAA,KAAK,GAAGA,KAAK,CAACQ,QAAN,EAAR;AACD,OAFD,MAEO,IAAI,OAAOR,KAAP,KAAiB,QAArB,EAA+B;AACpC,cAAM,IAAIS,SAAJ,CAAc,kCAAd,CAAN;AACD;AACF;;AAED,QAAIH,MAAJ,EAAY;AACV,UAAId,WAAW,CAACS,GAAD,CAAf,EAAsB;AACpBA,QAAAA,GAAG,GAAGA,GAAG,CAACO,QAAJ,EAAN;AACD,OAFD,MAEO,IAAI,OAAOP,GAAP,KAAe,QAAnB,EAA6B;AAClC,cAAM,IAAIQ,SAAJ,CAAc,gCAAd,CAAN;AACD;AACF;;AAED,QAAIF,OAAJ,EAAa;AACX,UAAIf,WAAW,CAACU,IAAD,CAAf,EAAuB;AACrBA,QAAAA,IAAI,GAAGA,IAAI,CAACM,QAAL,EAAP;AACD,OAFD,MAEO,IAAI,OAAON,IAAP,KAAgB,QAApB,EAA8B;AACnC,cAAM,IAAIO,SAAJ,CAAc,iCAAd,CAAN;AACD;AACF;;AAED,SAAKT,KAAL,GAAaI,QAAQ,GAAGM,UAAU,CAACV,KAAD,CAAb,GAAuB,CAA5C;AACA,SAAKC,GAAL,GAAWK,MAAM,GAAGI,UAAU,CAACT,GAAD,CAAb,GAAqB,CAAtC;AACA,SAAKC,IAAL,GAAYK,OAAO,GAAGG,UAAU,CAACR,IAAD,CAAb,GAAsB,CAAzC;AACD;AACD;;;;;AAKAH,EAAAA,KAAK,CAACY,SAAN,CAAgBC,IAAhB,GAAuB,OAAvB;AACAb,EAAAA,KAAK,CAACY,SAAN,CAAgBE,OAAhB,GAA0B,IAA1B;AACA;;;;;;;;;;AAUAd,EAAAA,KAAK,CAACe,KAAN,GAAc,UAAUC,GAAV,EAAe;AAC3B,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,aAAO,IAAP;AACD;;AAED,QAAIC,IAAI,GAAGD,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAX;AACA,QAAIC,IAAI,GAAGF,IAAI,CAACG,GAAL,CAAS,UAAUC,GAAV,EAAe;AACjC,aAAOV,UAAU,CAACU,GAAD,CAAjB;AACD,KAFU,CAAX;AAGA,QAAIC,OAAO,GAAGH,IAAI,CAACI,IAAL,CAAU,UAAUC,GAAV,EAAe;AACrC,aAAOC,KAAK,CAACD,GAAD,CAAZ;AACD,KAFa,CAAd;;AAIA,QAAIF,OAAJ,EAAa;AACX,aAAO,IAAP;AACD;;AAED,YAAQH,IAAI,CAACO,MAAb;AACE,WAAK,CAAL;AACE,eAAO,IAAI1B,KAAJ,CAAUmB,IAAI,CAAC,CAAD,CAAd,EAAmBA,IAAI,CAAC,CAAD,CAAvB,CAAP;;AAEF,WAAK,CAAL;AACE,eAAO,IAAInB,KAAJ,CAAUmB,IAAI,CAAC,CAAD,CAAd,EAAmBA,IAAI,CAAC,CAAD,CAAvB,EAA4BA,IAAI,CAAC,CAAD,CAAhC,CAAP;;AAEF;AACE,eAAO,IAAP;AARJ;AAUD,GA3BD;AA4BA;;;;;;AAMAnB,EAAAA,KAAK,CAACY,SAAN,CAAgBe,KAAhB,GAAwB,YAAY;AAClC,WAAO,IAAI3B,KAAJ,CAAU,KAAKC,KAAf,EAAsB,KAAKC,GAA3B,EAAgC,KAAKC,IAArC,CAAP;AACD,GAFD;AAGA;;;;;;;;AAQAH,EAAAA,KAAK,CAACY,SAAN,CAAgBgB,IAAhB,GAAuB,YAAY;AACjC,QAAIC,GAAG,GAAG,CAAV;AACA,QAAI5B,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIE,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAID,GAAG,GAAG,KAAKA,GAAf;AACA,QAAI4B,IAAI,GAAG5B,GAAG,GAAGD,KAAjB;;AAEA,QAAIN,IAAI,CAACQ,IAAD,CAAJ,KAAeR,IAAI,CAACmC,IAAD,CAAvB,EAA+B;AAC7BD,MAAAA,GAAG,GAAGE,IAAI,CAACC,IAAL,CAAUF,IAAI,GAAG3B,IAAjB,CAAN;AACD,KAFD,MAEO,IAAI2B,IAAI,KAAK,CAAb,EAAgB;AACrBD,MAAAA,GAAG,GAAG,CAAN;AACD;;AAED,QAAIJ,KAAK,CAACI,GAAD,CAAT,EAAgB;AACdA,MAAAA,GAAG,GAAG,CAAN;AACD;;AAED,WAAO,CAACA,GAAD,CAAP;AACD,GAlBD;AAmBA;;;;;;;AAOA7B,EAAAA,KAAK,CAACY,SAAN,CAAgBqB,GAAhB,GAAsB,YAAY;AAChC,QAAIL,IAAI,GAAG,KAAKA,IAAL,GAAY,CAAZ,CAAX;;AAEA,QAAIA,IAAI,GAAG,CAAX,EAAc;AACZ,UAAI,KAAKzB,IAAL,GAAY,CAAhB,EAAmB;AACjB;AACA,eAAO,KAAKF,KAAZ;AACD,OAHD,MAGO;AACL;AACA,eAAO,KAAKA,KAAL,GAAa,CAAC2B,IAAI,GAAG,CAAR,IAAa,KAAKzB,IAAtC;AACD;AACF,KARD,MAQO;AACL,aAAOG,SAAP;AACD;AACF,GAdD;AAeA;;;;;;;AAOAN,EAAAA,KAAK,CAACY,SAAN,CAAgBsB,GAAhB,GAAsB,YAAY;AAChC,QAAIN,IAAI,GAAG,KAAKA,IAAL,GAAY,CAAZ,CAAX;;AAEA,QAAIA,IAAI,GAAG,CAAX,EAAc;AACZ,UAAI,KAAKzB,IAAL,GAAY,CAAhB,EAAmB;AACjB;AACA,eAAO,KAAKF,KAAL,GAAa,CAAC2B,IAAI,GAAG,CAAR,IAAa,KAAKzB,IAAtC;AACD,OAHD,MAGO;AACL;AACA,eAAO,KAAKF,KAAZ;AACD;AACF,KARD,MAQO;AACL,aAAOK,SAAP;AACD;AACF,GAdD;AAeA;;;;;;;;;AASAN,EAAAA,KAAK,CAACY,SAAN,CAAgBuB,OAAhB,GAA0B,UAAUC,QAAV,EAAoB;AAC5C,QAAIC,CAAC,GAAG,KAAKpC,KAAb;AACA,QAAIE,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAID,GAAG,GAAG,KAAKA,GAAf;AACA,QAAIoC,CAAC,GAAG,CAAR;;AAEA,QAAInC,IAAI,GAAG,CAAX,EAAc;AACZ,aAAOkC,CAAC,GAAGnC,GAAX,EAAgB;AACdkC,QAAAA,QAAQ,CAACC,CAAD,EAAI,CAACC,CAAD,CAAJ,EAAS,IAAT,CAAR;AACAD,QAAAA,CAAC,IAAIlC,IAAL;AACAmC,QAAAA,CAAC;AACF;AACF,KAND,MAMO,IAAInC,IAAI,GAAG,CAAX,EAAc;AACnB,aAAOkC,CAAC,GAAGnC,GAAX,EAAgB;AACdkC,QAAAA,QAAQ,CAACC,CAAD,EAAI,CAACC,CAAD,CAAJ,EAAS,IAAT,CAAR;AACAD,QAAAA,CAAC,IAAIlC,IAAL;AACAmC,QAAAA,CAAC;AACF;AACF;AACF,GAnBD;AAoBA;;;;;;;;;;;AAWAtC,EAAAA,KAAK,CAACY,SAAN,CAAgBQ,GAAhB,GAAsB,UAAUgB,QAAV,EAAoB;AACxC,QAAIG,KAAK,GAAG,EAAZ;AACA,SAAKJ,OAAL,CAAa,UAAUK,KAAV,EAAiBC,KAAjB,EAAwBC,GAAxB,EAA6B;AACxCH,MAAAA,KAAK,CAACE,KAAK,CAAC,CAAD,CAAN,CAAL,GAAkBL,QAAQ,CAACI,KAAD,EAAQC,KAAR,EAAeC,GAAf,CAA1B;AACD,KAFD;AAGA,WAAOH,KAAP;AACD,GAND;AAOA;;;;;;;AAOAvC,EAAAA,KAAK,CAACY,SAAN,CAAgB+B,OAAhB,GAA0B,YAAY;AACpC,QAAIJ,KAAK,GAAG,EAAZ;AACA,SAAKJ,OAAL,CAAa,UAAUK,KAAV,EAAiBC,KAAjB,EAAwB;AACnCF,MAAAA,KAAK,CAACE,KAAK,CAAC,CAAD,CAAN,CAAL,GAAkBD,KAAlB;AACD,KAFD;AAGA,WAAOD,KAAP;AACD,GAND;AAOA;;;;;;;AAOAvC,EAAAA,KAAK,CAACY,SAAN,CAAgBgC,OAAhB,GAA0B,YAAY;AACpC;AACA,WAAO,KAAKD,OAAL,EAAP;AACD,GAHD;AAIA;;;;;;;;;;;;AAYA3C,EAAAA,KAAK,CAACY,SAAN,CAAgBlB,MAAhB,GAAyB,UAAUmD,OAAV,EAAmB;AAC1C,QAAI7B,GAAG,GAAGtB,MAAM,CAAC,KAAKO,KAAN,EAAa4C,OAAb,CAAhB;;AAEA,QAAI,KAAK1C,IAAL,KAAc,CAAlB,EAAqB;AACnBa,MAAAA,GAAG,IAAI,MAAMtB,MAAM,CAAC,KAAKS,IAAN,EAAY0C,OAAZ,CAAnB;AACD;;AAED7B,IAAAA,GAAG,IAAI,MAAMtB,MAAM,CAAC,KAAKQ,GAAN,EAAW2C,OAAX,CAAnB;AACA,WAAO7B,GAAP;AACD,GATD;AAUA;;;;;;;AAOAhB,EAAAA,KAAK,CAACY,SAAN,CAAgBkC,QAAhB,GAA2B,YAAY;AACrC,WAAO,KAAKpD,MAAL,EAAP;AACD,GAFD;AAGA;;;;;;;;AAQAM,EAAAA,KAAK,CAACY,SAAN,CAAgBmC,MAAhB,GAAyB,YAAY;AACnC,WAAO;AACLC,MAAAA,MAAM,EAAE,OADH;AAEL/C,MAAAA,KAAK,EAAE,KAAKA,KAFP;AAGLC,MAAAA,GAAG,EAAE,KAAKA,GAHL;AAILC,MAAAA,IAAI,EAAE,KAAKA;AAJN,KAAP;AAMD,GAPD;AAQA;;;;;;;;;AASAH,EAAAA,KAAK,CAACiD,QAAN,GAAiB,UAAUC,IAAV,EAAgB;AAC/B,WAAO,IAAIlD,KAAJ,CAAUkD,IAAI,CAACjD,KAAf,EAAsBiD,IAAI,CAAChD,GAA3B,EAAgCgD,IAAI,CAAC/C,IAArC,CAAP;AACD,GAFD;;AAIA,SAAOH,KAAP;AACD,CAxUmD,EAwUjD;AACDmD,EAAAA,OAAO,EAAE;AADR,CAxUiD,CAA7C","sourcesContent":["import { isBigNumber } from '../../utils/is';\nimport { format, sign } from '../../utils/number';\nimport { factory } from '../../utils/factory';\nvar name = 'Range';\nvar dependencies = [];\nexport var createRangeClass = /* #__PURE__ */factory(name, dependencies, function () {\n  /**\n   * Create a range. A range has a start, step, and end, and contains functions\n   * to iterate over the range.\n   *\n   * A range can be constructed as:\n   *\n   *     const range = new Range(start, end)\n   *     const range = new Range(start, end, step)\n   *\n   * To get the result of the range:\n   *     range.forEach(function (x) {\n   *         console.log(x)\n   *     })\n   *     range.map(function (x) {\n   *         return math.sin(x)\n   *     })\n   *     range.toArray()\n   *\n   * Example usage:\n   *\n   *     const c = new Range(2, 6)       // 2:1:5\n   *     c.toArray()                     // [2, 3, 4, 5]\n   *     const d = new Range(2, -3, -1)  // 2:-1:-2\n   *     d.toArray()                     // [2, 1, 0, -1, -2]\n   *\n   * @class Range\n   * @constructor Range\n   * @param {number} start  included lower bound\n   * @param {number} end    excluded upper bound\n   * @param {number} [step] step size, default value is 1\n   */\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    var hasStart = start !== null && start !== undefined;\n    var hasEnd = end !== null && end !== undefined;\n    var hasStep = step !== null && step !== undefined;\n\n    if (hasStart) {\n      if (isBigNumber(start)) {\n        start = start.toNumber();\n      } else if (typeof start !== 'number') {\n        throw new TypeError('Parameter start must be a number');\n      }\n    }\n\n    if (hasEnd) {\n      if (isBigNumber(end)) {\n        end = end.toNumber();\n      } else if (typeof end !== 'number') {\n        throw new TypeError('Parameter end must be a number');\n      }\n    }\n\n    if (hasStep) {\n      if (isBigNumber(step)) {\n        step = step.toNumber();\n      } else if (typeof step !== 'number') {\n        throw new TypeError('Parameter step must be a number');\n      }\n    }\n\n    this.start = hasStart ? parseFloat(start) : 0;\n    this.end = hasEnd ? parseFloat(end) : 0;\n    this.step = hasStep ? parseFloat(step) : 1;\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Range.prototype.type = 'Range';\n  Range.prototype.isRange = true;\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @memberof Range\n   * @param {string} str\n   * @return {Range | null} range\n   */\n\n  Range.parse = function (str) {\n    if (typeof str !== 'string') {\n      return null;\n    }\n\n    var args = str.split(':');\n    var nums = args.map(function (arg) {\n      return parseFloat(arg);\n    });\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n\n    if (invalid) {\n      return null;\n    }\n\n    switch (nums.length) {\n      case 2:\n        return new Range(nums[0], nums[1]);\n\n      case 3:\n        return new Range(nums[0], nums[2], nums[1]);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Create a clone of the range\n   * @return {Range} clone\n   */\n\n\n  Range.prototype.clone = function () {\n    return new Range(this.start, this.end, this.step);\n  };\n  /**\n   * Retrieve the size of the range.\n   * Returns an array containing one number, the number of elements in the range.\n   * @memberof Range\n   * @returns {number[]} size\n   */\n\n\n  Range.prototype.size = function () {\n    var len = 0;\n    var start = this.start;\n    var step = this.step;\n    var end = this.end;\n    var diff = end - start;\n\n    if (sign(step) === sign(diff)) {\n      len = Math.ceil(diff / step);\n    } else if (diff === 0) {\n      len = 0;\n    }\n\n    if (isNaN(len)) {\n      len = 0;\n    }\n\n    return [len];\n  };\n  /**\n   * Calculate the minimum value in the range\n   * @memberof Range\n   * @return {number | undefined} min\n   */\n\n\n  Range.prototype.min = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start;\n      } else {\n        // negative step\n        return this.start + (size - 1) * this.step;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Calculate the maximum value in the range\n   * @memberof Range\n   * @return {number | undefined} max\n   */\n\n\n  Range.prototype.max = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start + (size - 1) * this.step;\n      } else {\n        // negative step\n        return this.start;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Execute a callback function for each value in the range.\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Range being traversed.\n   */\n\n\n  Range.prototype.forEach = function (callback) {\n    var x = this.start;\n    var step = this.step;\n    var end = this.end;\n    var i = 0;\n\n    if (step > 0) {\n      while (x < end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    } else if (step < 0) {\n      while (x > end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    }\n  };\n  /**\n   * Execute a callback function for each value in the Range, and return the\n   * results as an array\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.map = function (callback) {\n    var array = [];\n    this.forEach(function (value, index, obj) {\n      array[index[0]] = callback(value, index, obj);\n    });\n    return array;\n  };\n  /**\n   * Create an Array with a copy of the Ranges data\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.toArray = function () {\n    var array = [];\n    this.forEach(function (value, index) {\n      array[index[0]] = value;\n    });\n    return array;\n  };\n  /**\n   * Get the primitive value of the Range, a one dimensional array\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.valueOf = function () {\n    // TODO: implement a caching mechanism for range.valueOf()\n    return this.toArray();\n  };\n  /**\n   * Get a string representation of the range, with optional formatting options.\n   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'\n   * @memberof Range\n   * @param {Object | number | function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  Range.prototype.format = function (options) {\n    var str = format(this.start, options);\n\n    if (this.step !== 1) {\n      str += ':' + format(this.step, options);\n    }\n\n    str += ':' + format(this.end, options);\n    return str;\n  };\n  /**\n   * Get a string representation of the range.\n   * @memberof Range\n   * @returns {string}\n   */\n\n\n  Range.prototype.toString = function () {\n    return this.format();\n  };\n  /**\n   * Get a JSON representation of the range\n   * @memberof Range\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   */\n\n\n  Range.prototype.toJSON = function () {\n    return {\n      mathjs: 'Range',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate a Range from a JSON object\n   * @memberof Range\n   * @param {Object} json A JSON object structured as:\n   *                      `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   * @return {Range}\n   */\n\n\n  Range.fromJSON = function (json) {\n    return new Range(json.start, json.end, json.step);\n  };\n\n  return Range;\n}, {\n  isClass: true\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { flatten } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nvar name = 'setPowerset';\nvar dependencies = ['typed', 'size', 'subset', 'compareNatural', 'Index'];\nexport var createSetPowerset = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      size = _ref.size,\n      subset = _ref.subset,\n      compareNatural = _ref.compareNatural,\n      Index = _ref.Index;\n  /**\n   * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setPowerset(set)\n   *\n   * Examples:\n   *\n   *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n   *\n   * See also:\n   *\n   *    setCartesian\n   *\n   * @param {Array | Matrix}    a  A (multi)set\n   * @return {Array}    The powerset of the (multi)set\n   */\n\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(a) {\n      if (subset(size(a), new Index(0)) === 0) {\n        // if empty, return empty\n        return [];\n      }\n\n      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);\n      var result = [];\n      var number = 0;\n\n      while (number.toString(2).length <= b.length) {\n        result.push(_subset(b, number.toString(2).split('').reverse()));\n        number++;\n      } // can not return a matrix, because of the different size of the subarrays\n\n\n      return _sort(result);\n    }\n  }); // create subset\n\n  function _subset(array, bitarray) {\n    var result = [];\n\n    for (var i = 0; i < bitarray.length; i++) {\n      if (bitarray[i] === '1') {\n        result.push(array[i]);\n      }\n    }\n\n    return result;\n  } // sort subsests by length\n\n\n  function _sort(array) {\n    var temp = [];\n\n    for (var i = array.length - 1; i > 0; i--) {\n      for (var j = 0; j < i; j++) {\n        if (array[j].length > array[j + 1].length) {\n          temp = array[j];\n          array[j] = array[j + 1];\n          array[j + 1] = temp;\n        }\n      }\n    }\n\n    return array;\n  }\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/set/setPowerset.js"],"names":["flatten","factory","name","dependencies","createSetPowerset","_ref","typed","size","subset","compareNatural","Index","ArrayMatrix","a","b","Array","isArray","toArray","sort","result","number","toString","length","push","_subset","split","reverse","_sort","array","bitarray","i","temp","j"],"mappings":"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","sourcesContent":["import { flatten } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nvar name = 'setPowerset';\nvar dependencies = ['typed', 'size', 'subset', 'compareNatural', 'Index'];\nexport var createSetPowerset = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      size = _ref.size,\n      subset = _ref.subset,\n      compareNatural = _ref.compareNatural,\n      Index = _ref.Index;\n\n  /**\n   * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)\n   * A multi-dimension array will be converted to a single-dimension array before the operation.\n   *\n   * Syntax:\n   *\n   *    math.setPowerset(set)\n   *\n   * Examples:\n   *\n   *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n   *\n   * See also:\n   *\n   *    setCartesian\n   *\n   * @param {Array | Matrix}    a  A (multi)set\n   * @return {Array}    The powerset of the (multi)set\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(a) {\n      if (subset(size(a), new Index(0)) === 0) {\n        // if empty, return empty\n        return [];\n      }\n\n      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);\n      var result = [];\n      var number = 0;\n\n      while (number.toString(2).length <= b.length) {\n        result.push(_subset(b, number.toString(2).split('').reverse()));\n        number++;\n      } // can not return a matrix, because of the different size of the subarrays\n\n\n      return _sort(result);\n    }\n  }); // create subset\n\n  function _subset(array, bitarray) {\n    var result = [];\n\n    for (var i = 0; i < bitarray.length; i++) {\n      if (bitarray[i] === '1') {\n        result.push(array[i]);\n      }\n    }\n\n    return result;\n  } // sort subsests by length\n\n\n  function _sort(array) {\n    var temp = [];\n\n    for (var i = array.length - 1; i > 0; i--) {\n      for (var j = 0; j < i; j++) {\n        if (array[j].length > array[j + 1].length) {\n          temp = array[j];\n          array[j] = array[j + 1];\n          array[j + 1] = temp;\n        }\n      }\n    }\n\n    return array;\n  }\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isNode, isObjectNode, isParenthesisNode, isSymbolNode } from '../../utils/is';\nimport { getSafeProperty } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nimport { accessFactory } from './utils/access';\nvar name = 'AccessorNode';\nvar dependencies = ['subset', 'Node'];\nexport var createAccessorNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var subset = _ref.subset,\n      Node = _ref.Node;\n  var access = accessFactory({\n    subset: subset\n  });\n  /**\n   * @constructor AccessorNode\n   * @extends {Node}\n   * Access an object property or get a matrix subset\n   *\n   * @param {Node} object                 The object from which to retrieve\n   *                                      a property or subset.\n   * @param {IndexNode} index             IndexNode containing ranges\n   */\n\n  function AccessorNode(object, index) {\n    if (!(this instanceof AccessorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(object)) {\n      throw new TypeError('Node expected for parameter \"object\"');\n    }\n\n    if (!isIndexNode(index)) {\n      throw new TypeError('IndexNode expected for parameter \"index\"');\n    }\n\n    this.object = object || null;\n    this.index = index; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        if (this.index) {\n          return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';\n        } else {\n          return this.object.name || '';\n        }\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  AccessorNode.prototype = new Node();\n  AccessorNode.prototype.type = 'AccessorNode';\n  AccessorNode.prototype.isAccessorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  AccessorNode.prototype._compile = function (math, argNames) {\n    var evalObject = this.object._compile(math, argNames);\n\n    var evalIndex = this.index._compile(math, argNames);\n\n    if (this.index.isObjectProperty()) {\n      var prop = this.index.getObjectProperty();\n      return function evalAccessorNode(scope, args, context) {\n        return getSafeProperty(evalObject(scope, args, context), prop);\n      };\n    } else {\n      return function evalAccessorNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        var index = evalIndex(scope, args, object); // we pass object here instead of context\n\n        return access(object, index);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  AccessorNode.prototype.forEach = function (callback) {\n    callback(this.object, 'object', this);\n    callback(this.index, 'index', this);\n  };\n  /**\n   * Create a new AccessorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {AccessorNode} Returns a transformed copy of the node\n   */\n\n\n  AccessorNode.prototype.map = function (callback) {\n    return new AccessorNode(this._ifNode(callback(this.object, 'object', this)), this._ifNode(callback(this.index, 'index', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {AccessorNode}\n   */\n\n\n  AccessorNode.prototype.clone = function () {\n    return new AccessorNode(this.object, this.index);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype._toString = function (options) {\n    var object = this.object.toString(options);\n\n    if (needParenthesis(this.object)) {\n      object = '(' + object + ')';\n    }\n\n    return object + this.index.toString(options);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype.toHTML = function (options) {\n    var object = this.object.toHTML(options);\n\n    if (needParenthesis(this.object)) {\n      object = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + object + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return object + this.index.toHTML(options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype._toTex = function (options) {\n    var object = this.object.toTex(options);\n\n    if (needParenthesis(this.object)) {\n      object = '\\\\left(\\' + object + \\'\\\\right)';\n    }\n\n    return object + this.index.toTex(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  AccessorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'AccessorNode',\n      object: this.object,\n      index: this.index\n    };\n  };\n  /**\n   * Instantiate an AccessorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"AccessorNode\", object: ..., index: ...}`,\n   *                       where mathjs is optional\n   * @returns {AccessorNode}\n   */\n\n\n  AccessorNode.fromJSON = function (json) {\n    return new AccessorNode(json.object, json.index);\n  };\n  /**\n   * Are parenthesis needed?\n   * @private\n   */\n\n\n  function needParenthesis(node) {\n    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?\n    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));\n  }\n\n  return AccessorNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/node/AccessorNode.js"],"names":["isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isIndexNode","isNode","isObjectNode","isParenthesisNode","isSymbolNode","getSafeProperty","factory","accessFactory","name","dependencies","createAccessorNode","_ref","subset","Node","access","AccessorNode","object","index","SyntaxError","TypeError","Object","defineProperty","get","isObjectProperty","getObjectProperty","bind","set","Error","prototype","type","_compile","math","argNames","evalObject","evalIndex","prop","evalAccessorNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","toString","needParenthesis","toHTML","_toTex","toTex","toJSON","mathjs","fromJSON","json","node","isClass"],"mappings":"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","sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isNode, isObjectNode, isParenthesisNode, isSymbolNode } from '../../utils/is';\nimport { getSafeProperty } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nimport { accessFactory } from './utils/access';\nvar name = 'AccessorNode';\nvar dependencies = ['subset', 'Node'];\nexport var createAccessorNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var subset = _ref.subset,\n      Node = _ref.Node;\n  var access = accessFactory({\n    subset: subset\n  });\n  /**\n   * @constructor AccessorNode\n   * @extends {Node}\n   * Access an object property or get a matrix subset\n   *\n   * @param {Node} object                 The object from which to retrieve\n   *                                      a property or subset.\n   * @param {IndexNode} index             IndexNode containing ranges\n   */\n\n  function AccessorNode(object, index) {\n    if (!(this instanceof AccessorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(object)) {\n      throw new TypeError('Node expected for parameter \"object\"');\n    }\n\n    if (!isIndexNode(index)) {\n      throw new TypeError('IndexNode expected for parameter \"index\"');\n    }\n\n    this.object = object || null;\n    this.index = index; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        if (this.index) {\n          return this.index.isObjectProperty() ? this.index.getObjectProperty() : '';\n        } else {\n          return this.object.name || '';\n        }\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  AccessorNode.prototype = new Node();\n  AccessorNode.prototype.type = 'AccessorNode';\n  AccessorNode.prototype.isAccessorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  AccessorNode.prototype._compile = function (math, argNames) {\n    var evalObject = this.object._compile(math, argNames);\n\n    var evalIndex = this.index._compile(math, argNames);\n\n    if (this.index.isObjectProperty()) {\n      var prop = this.index.getObjectProperty();\n      return function evalAccessorNode(scope, args, context) {\n        return getSafeProperty(evalObject(scope, args, context), prop);\n      };\n    } else {\n      return function evalAccessorNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        var index = evalIndex(scope, args, object); // we pass object here instead of context\n\n        return access(object, index);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  AccessorNode.prototype.forEach = function (callback) {\n    callback(this.object, 'object', this);\n    callback(this.index, 'index', this);\n  };\n  /**\n   * Create a new AccessorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {AccessorNode} Returns a transformed copy of the node\n   */\n\n\n  AccessorNode.prototype.map = function (callback) {\n    return new AccessorNode(this._ifNode(callback(this.object, 'object', this)), this._ifNode(callback(this.index, 'index', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {AccessorNode}\n   */\n\n\n  AccessorNode.prototype.clone = function () {\n    return new AccessorNode(this.object, this.index);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype._toString = function (options) {\n    var object = this.object.toString(options);\n\n    if (needParenthesis(this.object)) {\n      object = '(' + object + ')';\n    }\n\n    return object + this.index.toString(options);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype.toHTML = function (options) {\n    var object = this.object.toHTML(options);\n\n    if (needParenthesis(this.object)) {\n      object = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + object + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return object + this.index.toHTML(options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string}\n   */\n\n\n  AccessorNode.prototype._toTex = function (options) {\n    var object = this.object.toTex(options);\n\n    if (needParenthesis(this.object)) {\n      object = '\\\\left(\\' + object + \\'\\\\right)';\n    }\n\n    return object + this.index.toTex(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  AccessorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'AccessorNode',\n      object: this.object,\n      index: this.index\n    };\n  };\n  /**\n   * Instantiate an AccessorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"AccessorNode\", object: ..., index: ...}`,\n   *                       where mathjs is optional\n   * @returns {AccessorNode}\n   */\n\n\n  AccessorNode.fromJSON = function (json) {\n    return new AccessorNode(json.object, json.index);\n  };\n  /**\n   * Are parenthesis needed?\n   * @private\n   */\n\n\n  function needParenthesis(node) {\n    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?\n    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));\n  }\n\n  return AccessorNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
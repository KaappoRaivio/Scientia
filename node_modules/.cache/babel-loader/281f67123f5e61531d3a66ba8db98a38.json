{"ast":null,"code":"import { isNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators';\nimport { latexOperators } from '../../utils/latex';\nimport { factory } from '../../utils/factory';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n\n    if (!Array.isArray(args) || !args.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.implicit = implicit === true;\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n\n  OperatorNode.prototype = new Node();\n  OperatorNode.prototype.type = 'OperatorNode';\n  OperatorNode.prototype.isOperatorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  OperatorNode.prototype._compile = function (math, argNames) {\n    // validate fn\n    if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n      if (!math[this.fn]) {\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n      } else {\n        throw new Error('No access to function \"' + this.fn + '\"');\n      }\n    }\n\n    var fn = getSafeProperty(math, this.fn);\n    var evalArgs = map(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (evalArgs.length === 1) {\n      var evalArg0 = evalArgs[0];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(evalArg0(scope, args, context));\n      };\n    } else if (evalArgs.length === 2) {\n      var _evalArg = evalArgs[0];\n      var evalArg1 = evalArgs[1];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n      };\n    } else {\n      return function evalOperatorNode(scope, args, context) {\n        return fn.apply(null, map(evalArgs, function (evalArg) {\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n\n\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n  /**\n   * Check whether this is an unary OperatorNode:\n   * has exactly one argument, like `-a`.\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isUnary = function () {\n    return this.args.length === 1;\n  };\n  /**\n   * Check whether this is a binary OperatorNode:\n   * has exactly two arguments, like `a + b`.\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isBinary = function () {\n    return this.args.length === 2;\n  };\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis);\n    var associativity = getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = getPrecedence(args[0], parenthesis); // is the root node associative with the left hand side\n\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = getPrecedence(args[1], parenthesis); // is the root node associative with the right hand side?\n\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    // printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\n\n        if (result[index] || isParenthesisNode) {\n          // put in parenthesis?\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = getAssociativity(this, parenthesis);\n      var operand = args[0].toString(options);\n\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      } // for example for \"not\", we want a space between operand and argument\n\n\n      var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n      if (assoc === 'right') {\n        // prefix operator\n        return this.op + (opIsNamed ? ' ' : '') + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return operand + (opIsNamed ? ' ' : '') + this.op;\n      } // fall back to postfix\n\n\n      return operand + this.op;\n    } else if (args.length === 2) {\n      var lhs = args[0].toString(options); // left hand side\n\n      var rhs = args[1].toString(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + ' ' + rhs;\n      }\n\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return stringifiedArgs.join(' ');\n      }\n\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      // fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  OperatorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'OperatorNode',\n      op: this.op,\n      fn: this.fn,\n      args: this.args,\n      implicit: this.implicit\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"OperatorNode\", \"op\": \"+\", \"fn\": \"add\", \"args\": [...], \"implicit\": false}`,\n   *                       where mathjs is optional\n   * @returns {OperatorNode}\n   */\n\n\n  OperatorNode.fromJSON = function (json) {\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\n  };\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = getAssociativity(this, parenthesis);\n      var operand = args[0].toHTML(options);\n\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n      } else {\n        // postfix when assoc === 'left' or undefined\n        return operand + '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n      }\n    } else if (args.length === 2) {\n      // binary operatoes\n      var lhs = args[0].toHTML(options); // left hand side\n\n      var rhs = args[1].toHTML(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n      }\n\n      return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n    } else {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return arg;\n      });\n\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n        }\n\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n      } else {\n        // fallback to formatting as a function call\n        return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n      }\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = latexOperators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = getAssociativity(this, parenthesis);\n      var operand = args[0].toTex(options);\n\n      if (parens[0]) {\n        operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return op + operand;\n      } else if (assoc === 'left') {\n        // postfix operator\n        return operand + op;\n      } // fall back to postfix\n\n\n      return operand + op;\n    } else if (args.length === 2) {\n      // binary operators\n      var lhs = args[0]; // left hand side\n\n      var lhsTex = lhs.toTex(options);\n\n      if (parens[0]) {\n        lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n      }\n\n      var rhs = args[1]; // right hand side\n\n      var rhsTex = rhs.toTex(options);\n\n      if (parens[1]) {\n        rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n      } // handle some exceptions (due to the way LaTeX works)\n\n\n      var lhsIdentifier;\n\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      } else {\n        // Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          // op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n\n            case 'OperatorNode:divide':\n              lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n\n          break;\n\n        case 'OperatorNode:multiply':\n          if (this.implicit && implicit === 'hide') {\n            return lhsTex + '~' + rhsTex;\n          }\n\n      }\n\n      return lhsTex + op + rhsTex;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n\n        if (parens[index]) {\n          arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n        }\n\n        return arg;\n      });\n\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n\n      return texifiedArgs.join(op);\n    } else {\n      // fall back to formatting as a function call\n      // as this is a fallback, it doesn't use\n      // fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n        return arg.toTex(options);\n      }).join(',') + '\\\\right)';\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/node/OperatorNode.js"],"names":["isNode","map","escape","getSafeProperty","isSafeMethod","getAssociativity","getPrecedence","isAssociativeWith","properties","latexOperators","factory","name","dependencies","createOperatorNode","_ref","Node","OperatorNode","op","fn","args","implicit","SyntaxError","TypeError","Array","isArray","every","prototype","type","isOperatorNode","_compile","math","argNames","Error","evalArgs","arg","length","evalArg0","evalOperatorNode","scope","context","_evalArg","evalArg1","apply","evalArg","forEach","callback","i","_ifNode","clone","slice","isUnary","isBinary","calculateNecessaryParentheses","root","parenthesis","latex","precedence","associativity","getIdentifier","getContent","result","operandPrecedence","operandIdentifier","rootIdentifier","latexLeftParens","latexParens","lhsParens","lhsPrecedence","assocWithLhs","rhsParens","rhsPrecedence","assocWithRhs","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","index","isParenthesisNode","_toString","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","lhsTex","rhsTex","texifiedArgs","isClass"],"mappings":"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","sourcesContent":["import { isNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators';\nimport { latexOperators } from '../../utils/latex';\nimport { factory } from '../../utils/factory';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n\n    if (!Array.isArray(args) || !args.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.implicit = implicit === true;\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n\n  OperatorNode.prototype = new Node();\n  OperatorNode.prototype.type = 'OperatorNode';\n  OperatorNode.prototype.isOperatorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  OperatorNode.prototype._compile = function (math, argNames) {\n    // validate fn\n    if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n      if (!math[this.fn]) {\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n      } else {\n        throw new Error('No access to function \"' + this.fn + '\"');\n      }\n    }\n\n    var fn = getSafeProperty(math, this.fn);\n    var evalArgs = map(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (evalArgs.length === 1) {\n      var evalArg0 = evalArgs[0];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(evalArg0(scope, args, context));\n      };\n    } else if (evalArgs.length === 2) {\n      var _evalArg = evalArgs[0];\n      var evalArg1 = evalArgs[1];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n      };\n    } else {\n      return function evalOperatorNode(scope, args, context) {\n        return fn.apply(null, map(evalArgs, function (evalArg) {\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n\n\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n  /**\n   * Check whether this is an unary OperatorNode:\n   * has exactly one argument, like `-a`.\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isUnary = function () {\n    return this.args.length === 1;\n  };\n  /**\n   * Check whether this is a binary OperatorNode:\n   * has exactly two arguments, like `a + b`.\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isBinary = function () {\n    return this.args.length === 2;\n  };\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis);\n    var associativity = getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = getPrecedence(args[0], parenthesis); // is the root node associative with the left hand side\n\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = getPrecedence(args[1], parenthesis); // is the root node associative with the right hand side?\n\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    // printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\n\n        if (result[index] || isParenthesisNode) {\n          // put in parenthesis?\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = getAssociativity(this, parenthesis);\n      var operand = args[0].toString(options);\n\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      } // for example for \"not\", we want a space between operand and argument\n\n\n      var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n      if (assoc === 'right') {\n        // prefix operator\n        return this.op + (opIsNamed ? ' ' : '') + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return operand + (opIsNamed ? ' ' : '') + this.op;\n      } // fall back to postfix\n\n\n      return operand + this.op;\n    } else if (args.length === 2) {\n      var lhs = args[0].toString(options); // left hand side\n\n      var rhs = args[1].toString(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + ' ' + rhs;\n      }\n\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return stringifiedArgs.join(' ');\n      }\n\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      // fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  OperatorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'OperatorNode',\n      op: this.op,\n      fn: this.fn,\n      args: this.args,\n      implicit: this.implicit\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"OperatorNode\", \"op\": \"+\", \"fn\": \"add\", \"args\": [...], \"implicit\": false}`,\n   *                       where mathjs is optional\n   * @returns {OperatorNode}\n   */\n\n\n  OperatorNode.fromJSON = function (json) {\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\n  };\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = getAssociativity(this, parenthesis);\n      var operand = args[0].toHTML(options);\n\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n      } else {\n        // postfix when assoc === 'left' or undefined\n        return operand + '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n      }\n    } else if (args.length === 2) {\n      // binary operatoes\n      var lhs = args[0].toHTML(options); // left hand side\n\n      var rhs = args[1].toHTML(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n      }\n\n      return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n    } else {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return arg;\n      });\n\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n        }\n\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n      } else {\n        // fallback to formatting as a function call\n        return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n      }\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = latexOperators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = getAssociativity(this, parenthesis);\n      var operand = args[0].toTex(options);\n\n      if (parens[0]) {\n        operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return op + operand;\n      } else if (assoc === 'left') {\n        // postfix operator\n        return operand + op;\n      } // fall back to postfix\n\n\n      return operand + op;\n    } else if (args.length === 2) {\n      // binary operators\n      var lhs = args[0]; // left hand side\n\n      var lhsTex = lhs.toTex(options);\n\n      if (parens[0]) {\n        lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n      }\n\n      var rhs = args[1]; // right hand side\n\n      var rhsTex = rhs.toTex(options);\n\n      if (parens[1]) {\n        rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n      } // handle some exceptions (due to the way LaTeX works)\n\n\n      var lhsIdentifier;\n\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      } else {\n        // Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          // op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n\n            case 'OperatorNode:divide':\n              lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n\n          break;\n\n        case 'OperatorNode:multiply':\n          if (this.implicit && implicit === 'hide') {\n            return lhsTex + '~' + rhsTex;\n          }\n\n      }\n\n      return lhsTex + op + rhsTex;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n\n        if (parens[index]) {\n          arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n        }\n\n        return arg;\n      });\n\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n\n      return texifiedArgs.join(op);\n    } else {\n      // fall back to formatting as a function call\n      // as this is a fallback, it doesn't use\n      // fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n        return arg.toTex(options);\n      }).join(',') + '\\\\right)';\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
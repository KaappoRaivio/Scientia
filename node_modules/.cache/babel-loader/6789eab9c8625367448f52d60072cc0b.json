{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nimport { getSafeProperty } from '../../utils/customs';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n      Node = _ref.Node,\n      size = _ref.size;\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/node/IndexNode.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","isBigNumber","isConstantNode","isNode","isRangeNode","isSymbolNode","map","escape","factory","getSafeProperty","dependencies","createIndexNode","_ref","Range","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","every","isObjectProperty","Error","deprecated","defineProperty","get","set","type","isIndexNode","_compile","math","argNames","evalDimensions","range","needsEnd","childArgNames","create","end","evalStart","start","evalEnd","evalStep","step","evalDimension","scope","args","context","s","valueOf","childArgs","createRange","_evalStart","_evalEnd","_evalStep","_childArgNames","evalRange","_evalRange","index","evalIndexNode","apply","forEach","callback","_ifNode","clone","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","toNumber","isClass"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nimport { getSafeProperty } from '../../utils/customs';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n      Node = _ref.Node,\n      size = _ref.size;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');\n    };\n\n    Object.defineProperty(this, 'object', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { isOperatorNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { hasOwnProperty } from '../../../utils/object';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      SymbolNode = _ref.SymbolNode; // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/simplify/util.js"],"names":["isOperatorNode","factory","hasOwnProperty","name","dependencies","createUtil","_ref","FunctionNode","OperatorNode","SymbolNode","commutative","add","multiply","associative","isCommutative","node","context","fn","toString","isAssociative","flatten","args","length","allChildren","i","op","children","findChildren","child","push","unflattenr","makeNode","createMakeNodeFunction","l","curnode","pop","unflattenl","shift","implicit","err","console","error"],"mappings":"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","sourcesContent":["import { isOperatorNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { hasOwnProperty } from '../../../utils/object';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n});"]},"metadata":{},"sourceType":"module"}
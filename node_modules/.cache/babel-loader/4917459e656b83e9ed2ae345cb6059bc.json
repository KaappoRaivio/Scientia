{"ast":null,"code":"// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nimport { isFraction, isNode, isOperatorNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { createUtil } from './util';\nimport { noBignumber, noFraction } from '../../../utils/noop';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      mathWithTransform = _ref.mathWithTransform,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      SymbolNode = _ref.SymbolNode;\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      allChildren = _createUtil.allChildren,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  function simplifyConstant(expr, options) {\n    var res = foldFraction(expr, options);\n    return isNode(res) ? res : _toNode(res);\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function (x) {\n        if (isFraction(x)) {\n          return x.valueOf();\n        }\n\n        return x;\n      });\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    }\n  }); // convert a number to a fraction only if it can be expressed exactly\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n\n      if (f.valueOf() === n) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!isNode(a) && !isNode(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!isNode(a)) {\n        a = _toNode(a);\n      } else if (!isNode(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\n          return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            }); // If all args are numbers\n\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontine) {}\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            args = args.map(function (arg) {\n              return isNode(arg) ? arg : _toNode(arg);\n            });\n            return new FunctionNode(node.name, args);\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node)) {\n            _args = allChildren(node);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            if (isCommutative(fn)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n      /* falls through */\n\n      case 'ArrayNode':\n      /* falls through */\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'IndexNode':\n      /* falls through */\n\n      case 'ObjectNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/simplify/simplifyConstant.js"],"names":["isFraction","isNode","isOperatorNode","factory","createUtil","noBignumber","noFraction","name","dependencies","createSimplifyConstant","_ref","typed","config","mathWithTransform","fraction","bignumber","ConstantNode","OperatorNode","FunctionNode","SymbolNode","_createUtil","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","expr","options","res","foldFraction","_toNode","_eval","fnname","args","_toNumber","apply","ignore","map","x","valueOf","Fraction","_fractionToNode","number","n","unaryMinusNode","BigNumber","Complex","s","Error","_exactFraction","exactFractions","isFinite","f","stringObject","undefined","parseFloat","FractionObject","BigNumberObject","numberObject","ComplexObject","im","re","vn","d","foldOp","fn","makeNode","reduce","a","b","ignoreandcontinue","node","type","value","isNaN","rawArgs","operatorFunctions","indexOf","arg","some","ignoreandcontine","toString","_args","isUnary","consts","vars","i","length","push","unshift","content","concat"],"mappings":"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","sourcesContent":["// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nimport { isFraction, isNode, isOperatorNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { createUtil } from './util';\nimport { noBignumber, noFraction } from '../../../utils/noop';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      mathWithTransform = _ref.mathWithTransform,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      SymbolNode = _ref.SymbolNode;\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      allChildren = _createUtil.allChildren,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  function simplifyConstant(expr, options) {\n    var res = foldFraction(expr, options);\n    return isNode(res) ? res : _toNode(res);\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function (x) {\n        if (isFraction(x)) {\n          return x.valueOf();\n        }\n\n        return x;\n      });\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    }\n  }); // convert a number to a fraction only if it can be expressed exactly\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n\n      if (f.valueOf() === n) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!isNode(a) && !isNode(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!isNode(a)) {\n        a = _toNode(a);\n      } else if (!isNode(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\n          return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            }); // If all args are numbers\n\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontine) {}\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            args = args.map(function (arg) {\n              return isNode(arg) ? arg : _toNode(arg);\n            });\n            return new FunctionNode(node.name, args);\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node)) {\n            _args = allChildren(node);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            if (isCommutative(fn)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n      /* falls through */\n\n      case 'ArrayNode':\n      /* falls through */\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'IndexNode':\n      /* falls through */\n\n      case 'ObjectNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { factory } from '../../utils/factory';\nvar name = 'nthRoots';\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\nexport var createNthRoots = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      divideScalar = _ref.divideScalar,\n      Complex = _ref.Complex;\n  /**\n   * Calculate the nth roots of a value.\n   * An nth root of a positive real number A,\n   * is a positive real solution of the equation \"x^root = A\".\n   * This function returns an array of complex values.\n   *\n   * Syntax:\n   *\n   *    math.nthRoots(x)\n   *    math.nthRoots(x, root)\n   *\n   * Examples:\n   *\n   *    math.nthRoots(1)\n   *    // returns [\n   *    //   {re: 1, im: 0},\n   *    //   {re: -1, im: 0}\n   *    // ]\n   *    nthRoots(1, 3)\n   *    // returns [\n   *    //   { re: 1, im: 0 },\n   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },\n   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }\n   *    ]\n   *\n   * See also:\n   *\n   *    nthRoot, pow, sqrt\n   *\n   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value\n   */\n\n  var nthRoots = typed(name, {\n    Complex: function Complex(x) {\n      return _nthComplexRoots(x, 2);\n    },\n    'Complex, number': _nthComplexRoots\n  });\n  /**\n   * Each function here returns a real multiple of i as a Complex value.\n   * @param  {number} val\n   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3\n   */\n  // This is used to fix float artifacts for zero-valued components.\n\n  var _calculateExactResult = [function realPos(val) {\n    return new Complex(val, 0);\n  }, function imagPos(val) {\n    return new Complex(0, val);\n  }, function realNeg(val) {\n    return new Complex(-val, 0);\n  }, function imagNeg(val) {\n    return new Complex(0, -val);\n  }];\n  /**\n   * Calculate the nth root of a Complex Number a using De Movire's Theorem.\n   * @param  {Complex} a\n   * @param  {number} root\n   * @return {Array} array of n Complex Roots\n   */\n\n  function _nthComplexRoots(a, root) {\n    if (root < 0) throw new Error('Root must be greater than zero');\n    if (root === 0) throw new Error('Root must be non-zero');\n    if (root % 1 !== 0) throw new Error('Root must be an integer');\n    if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];\n    var aIsNumeric = typeof a === 'number';\n    var offset; // determine the offset (argument of a)/(pi/2)\n\n    if (aIsNumeric || a.re === 0 || a.im === 0) {\n      if (aIsNumeric) {\n        offset = 2 * +(a < 0); // numeric value on the real axis\n      } else if (a.im === 0) {\n        offset = 2 * +(a.re < 0); // complex value on the real axis\n      } else {\n        offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis\n      }\n    }\n\n    var arg = a.arg();\n    var abs = a.abs();\n    var roots = [];\n    var r = Math.pow(abs, 1 / root);\n\n    for (var k = 0; k < root; k++) {\n      var halfPiFactor = (offset + 4 * k) / root;\n      /**\n       * If (offset + 4*k)/root is an integral multiple of pi/2\n       * then we can produce a more exact result.\n       */\n\n      if (halfPiFactor === Math.round(halfPiFactor)) {\n        roots.push(_calculateExactResult[halfPiFactor % 4](r));\n        continue;\n      }\n\n      roots.push(new Complex({\n        r: r,\n        phi: (arg + 2 * Math.PI * k) / root\n      }));\n    }\n\n    return roots;\n  }\n\n  return nthRoots;\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/arithmetic/nthRoots.js"],"names":["factory","name","dependencies","createNthRoots","_ref","typed","config","divideScalar","Complex","nthRoots","x","_nthComplexRoots","_calculateExactResult","realPos","val","imagPos","realNeg","imagNeg","a","root","Error","abs","aIsNumeric","offset","re","im","arg","roots","r","Math","pow","k","halfPiFactor","round","push","phi","PI"],"mappings":"AAAA,SAASA,OAAT,QAAwB,qBAAxB;AACA,IAAIC,IAAI,GAAG,UAAX;AACA,IAAIC,YAAY,GAAG,CAAC,QAAD,EAAW,OAAX,EAAoB,cAApB,EAAoC,SAApC,CAAnB;AACA,OAAO,IAAIC,cAAc,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,UAAUE,IAAV,EAAgB;AACrF,MAAIC,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAA,MACIC,MAAM,GAAGF,IAAI,CAACE,MADlB;AAAA,MAEIC,YAAY,GAAGH,IAAI,CAACG,YAFxB;AAAA,MAGIC,OAAO,GAAGJ,IAAI,CAACI,OAHnB;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,MAAIC,QAAQ,GAAGJ,KAAK,CAACJ,IAAD,EAAO;AACzBO,IAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBE,CAAjB,EAAoB;AAC3B,aAAOC,gBAAgB,CAACD,CAAD,EAAI,CAAJ,CAAvB;AACD,KAHwB;AAIzB,uBAAmBC;AAJM,GAAP,CAApB;AAMA;;;;;AAKA;;AAEA,MAAIC,qBAAqB,GAAG,CAAC,SAASC,OAAT,CAAiBC,GAAjB,EAAsB;AACjD,WAAO,IAAIN,OAAJ,CAAYM,GAAZ,EAAiB,CAAjB,CAAP;AACD,GAF2B,EAEzB,SAASC,OAAT,CAAiBD,GAAjB,EAAsB;AACvB,WAAO,IAAIN,OAAJ,CAAY,CAAZ,EAAeM,GAAf,CAAP;AACD,GAJ2B,EAIzB,SAASE,OAAT,CAAiBF,GAAjB,EAAsB;AACvB,WAAO,IAAIN,OAAJ,CAAY,CAACM,GAAb,EAAkB,CAAlB,CAAP;AACD,GAN2B,EAMzB,SAASG,OAAT,CAAiBH,GAAjB,EAAsB;AACvB,WAAO,IAAIN,OAAJ,CAAY,CAAZ,EAAe,CAACM,GAAhB,CAAP;AACD,GAR2B,CAA5B;AASA;;;;;;;AAOA,WAASH,gBAAT,CAA0BO,CAA1B,EAA6BC,IAA7B,EAAmC;AACjC,QAAIA,IAAI,GAAG,CAAX,EAAc,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACd,QAAID,IAAI,KAAK,CAAb,EAAgB,MAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AAChB,QAAID,IAAI,GAAG,CAAP,KAAa,CAAjB,EAAoB,MAAM,IAAIC,KAAJ,CAAU,yBAAV,CAAN;AACpB,QAAIF,CAAC,KAAK,CAAN,IAAWA,CAAC,CAACG,GAAF,OAAY,CAA3B,EAA8B,OAAO,CAAC,IAAIb,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAD,CAAP;AAC9B,QAAIc,UAAU,GAAG,OAAOJ,CAAP,KAAa,QAA9B;AACA,QAAIK,MAAJ,CANiC,CAMrB;;AAEZ,QAAID,UAAU,IAAIJ,CAAC,CAACM,EAAF,KAAS,CAAvB,IAA4BN,CAAC,CAACO,EAAF,KAAS,CAAzC,EAA4C;AAC1C,UAAIH,UAAJ,EAAgB;AACdC,QAAAA,MAAM,GAAG,IAAI,EAAEL,CAAC,GAAG,CAAN,CAAb,CADc,CACS;AACxB,OAFD,MAEO,IAAIA,CAAC,CAACO,EAAF,KAAS,CAAb,EAAgB;AACrBF,QAAAA,MAAM,GAAG,IAAI,EAAEL,CAAC,CAACM,EAAF,GAAO,CAAT,CAAb,CADqB,CACK;AAC3B,OAFM,MAEA;AACLD,QAAAA,MAAM,GAAG,IAAI,EAAEL,CAAC,CAACO,EAAF,GAAO,CAAT,CAAJ,GAAkB,CAA3B,CADK,CACyB;AAC/B;AACF;;AAED,QAAIC,GAAG,GAAGR,CAAC,CAACQ,GAAF,EAAV;AACA,QAAIL,GAAG,GAAGH,CAAC,CAACG,GAAF,EAAV;AACA,QAAIM,KAAK,GAAG,EAAZ;AACA,QAAIC,CAAC,GAAGC,IAAI,CAACC,GAAL,CAAST,GAAT,EAAc,IAAIF,IAAlB,CAAR;;AAEA,SAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,IAApB,EAA0BY,CAAC,EAA3B,EAA+B;AAC7B,UAAIC,YAAY,GAAG,CAACT,MAAM,GAAG,IAAIQ,CAAd,IAAmBZ,IAAtC;AACA;;;;;AAKA,UAAIa,YAAY,KAAKH,IAAI,CAACI,KAAL,CAAWD,YAAX,CAArB,EAA+C;AAC7CL,QAAAA,KAAK,CAACO,IAAN,CAAWtB,qBAAqB,CAACoB,YAAY,GAAG,CAAhB,CAArB,CAAwCJ,CAAxC,CAAX;AACA;AACD;;AAEDD,MAAAA,KAAK,CAACO,IAAN,CAAW,IAAI1B,OAAJ,CAAY;AACrBoB,QAAAA,CAAC,EAAEA,CADkB;AAErBO,QAAAA,GAAG,EAAE,CAACT,GAAG,GAAG,IAAIG,IAAI,CAACO,EAAT,GAAcL,CAArB,IAA0BZ;AAFV,OAAZ,CAAX;AAID;;AAED,WAAOQ,KAAP;AACD;;AAED,SAAOlB,QAAP;AACD,CAhHiD,CAA3C","sourcesContent":["import { factory } from '../../utils/factory';\nvar name = 'nthRoots';\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\nexport var createNthRoots = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      divideScalar = _ref.divideScalar,\n      Complex = _ref.Complex;\n\n  /**\n   * Calculate the nth roots of a value.\n   * An nth root of a positive real number A,\n   * is a positive real solution of the equation \"x^root = A\".\n   * This function returns an array of complex values.\n   *\n   * Syntax:\n   *\n   *    math.nthRoots(x)\n   *    math.nthRoots(x, root)\n   *\n   * Examples:\n   *\n   *    math.nthRoots(1)\n   *    // returns [\n   *    //   {re: 1, im: 0},\n   *    //   {re: -1, im: 0}\n   *    // ]\n   *    nthRoots(1, 3)\n   *    // returns [\n   *    //   { re: 1, im: 0 },\n   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },\n   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }\n   *    ]\n   *\n   * See also:\n   *\n   *    nthRoot, pow, sqrt\n   *\n   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value\n   */\n  var nthRoots = typed(name, {\n    Complex: function Complex(x) {\n      return _nthComplexRoots(x, 2);\n    },\n    'Complex, number': _nthComplexRoots\n  });\n  /**\n   * Each function here returns a real multiple of i as a Complex value.\n   * @param  {number} val\n   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3\n   */\n  // This is used to fix float artifacts for zero-valued components.\n\n  var _calculateExactResult = [function realPos(val) {\n    return new Complex(val, 0);\n  }, function imagPos(val) {\n    return new Complex(0, val);\n  }, function realNeg(val) {\n    return new Complex(-val, 0);\n  }, function imagNeg(val) {\n    return new Complex(0, -val);\n  }];\n  /**\n   * Calculate the nth root of a Complex Number a using De Movire's Theorem.\n   * @param  {Complex} a\n   * @param  {number} root\n   * @return {Array} array of n Complex Roots\n   */\n\n  function _nthComplexRoots(a, root) {\n    if (root < 0) throw new Error('Root must be greater than zero');\n    if (root === 0) throw new Error('Root must be non-zero');\n    if (root % 1 !== 0) throw new Error('Root must be an integer');\n    if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];\n    var aIsNumeric = typeof a === 'number';\n    var offset; // determine the offset (argument of a)/(pi/2)\n\n    if (aIsNumeric || a.re === 0 || a.im === 0) {\n      if (aIsNumeric) {\n        offset = 2 * +(a < 0); // numeric value on the real axis\n      } else if (a.im === 0) {\n        offset = 2 * +(a.re < 0); // complex value on the real axis\n      } else {\n        offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis\n      }\n    }\n\n    var arg = a.arg();\n    var abs = a.abs();\n    var roots = [];\n    var r = Math.pow(abs, 1 / root);\n\n    for (var k = 0; k < root; k++) {\n      var halfPiFactor = (offset + 4 * k) / root;\n      /**\n       * If (offset + 4*k)/root is an integral multiple of pi/2\n       * then we can produce a more exact result.\n       */\n\n      if (halfPiFactor === Math.round(halfPiFactor)) {\n        roots.push(_calculateExactResult[halfPiFactor % 4](r));\n        continue;\n      }\n\n      roots.push(new Complex({\n        r: r,\n        phi: (arg + 2 * Math.PI * k) / root\n      }));\n    }\n\n    return roots;\n  }\n\n  return nthRoots;\n});"]},"metadata":{},"sourceType":"module"}
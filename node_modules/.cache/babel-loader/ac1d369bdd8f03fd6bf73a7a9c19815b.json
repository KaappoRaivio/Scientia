{"ast":null,"code":"import { csReach } from './csReach';\nimport { factory } from '../../../utils/factory';\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nexport var createCsSpsolve = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract;\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = csReach(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/sparse/csSpsolve.js"],"names":["csReach","factory","name","dependencies","createCsSpsolve","_ref","divideScalar","multiply","subtract","csSpsolve","g","b","k","xi","x","pinv","lo","gvalues","_values","gindex","_index","gptr","_ptr","gsize","_size","n","bvalues","bindex","bptr","p","p0","p1","q","top","px","j","J","i"],"mappings":"AAAA,SAASA,OAAT,QAAwB,WAAxB;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,WAAX;AACA,IAAIC,YAAY,GAAG,CAAC,cAAD,EAAiB,UAAjB,EAA6B,UAA7B,CAAnB;AACA,OAAO,IAAIC,eAAe,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqB,UAAUE,IAAV,EAAgB;AACtF,MAAIC,YAAY,GAAGD,IAAI,CAACC,YAAxB;AAAA,MACIC,QAAQ,GAAGF,IAAI,CAACE,QADpB;AAAA,MAEIC,QAAQ,GAAGH,IAAI,CAACG,QAFpB;AAIA;;;;;;;;;;;;;;;;;;;;AAmBA,SAAO,SAASC,SAAT,CAAmBC,CAAnB,EAAsBC,CAAtB,EAAyBC,CAAzB,EAA4BC,EAA5B,EAAgCC,CAAhC,EAAmCC,IAAnC,EAAyCC,EAAzC,EAA6C;AAClD;AACA,QAAIC,OAAO,GAAGP,CAAC,CAACQ,OAAhB;AACA,QAAIC,MAAM,GAAGT,CAAC,CAACU,MAAf;AACA,QAAIC,IAAI,GAAGX,CAAC,CAACY,IAAb;AACA,QAAIC,KAAK,GAAGb,CAAC,CAACc,KAAd,CALkD,CAK7B;;AAErB,QAAIC,CAAC,GAAGF,KAAK,CAAC,CAAD,CAAb,CAPkD,CAOhC;;AAElB,QAAIG,OAAO,GAAGf,CAAC,CAACO,OAAhB;AACA,QAAIS,MAAM,GAAGhB,CAAC,CAACS,MAAf;AACA,QAAIQ,IAAI,GAAGjB,CAAC,CAACW,IAAb,CAXkD,CAW/B;;AAEnB,QAAIO,CAAJ,EAAOC,EAAP,EAAWC,EAAX,EAAeC,CAAf,CAbkD,CAahC;;AAElB,QAAIC,GAAG,GAAGjC,OAAO,CAACU,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAUC,EAAV,EAAcE,IAAd,CAAjB,CAfkD,CAeZ;;AAEtC,SAAKc,CAAC,GAAGI,GAAT,EAAcJ,CAAC,GAAGJ,CAAlB,EAAqBI,CAAC,EAAtB,EAA0B;AACxBf,MAAAA,CAAC,CAACD,EAAE,CAACgB,CAAD,CAAH,CAAD,GAAW,CAAX;AACD,KAnBiD,CAmBhD;;;AAGF,SAAKC,EAAE,GAAGF,IAAI,CAAChB,CAAD,CAAT,EAAcmB,EAAE,GAAGH,IAAI,CAAChB,CAAC,GAAG,CAAL,CAAvB,EAAgCiB,CAAC,GAAGC,EAAzC,EAA6CD,CAAC,GAAGE,EAAjD,EAAqDF,CAAC,EAAtD,EAA0D;AACxDf,MAAAA,CAAC,CAACa,MAAM,CAACE,CAAD,CAAP,CAAD,GAAeH,OAAO,CAACG,CAAD,CAAtB;AACD,KAxBiD,CAwBhD;;;AAGF,SAAK,IAAIK,EAAE,GAAGD,GAAd,EAAmBC,EAAE,GAAGT,CAAxB,EAA2BS,EAAE,EAA7B,EAAiC;AAC/B;AACA,UAAIC,CAAC,GAAGtB,EAAE,CAACqB,EAAD,CAAV,CAF+B,CAEf;;AAEhB,UAAIE,CAAC,GAAGrB,IAAI,GAAGA,IAAI,CAACoB,CAAD,CAAP,GAAaA,CAAzB,CAJ+B,CAIH;;AAE5B,UAAIC,CAAC,GAAG,CAAR,EAAW;AACT;AACD,OAR8B,CAQ7B;;;AAGFN,MAAAA,EAAE,GAAGT,IAAI,CAACe,CAAD,CAAT;AACAL,MAAAA,EAAE,GAAGV,IAAI,CAACe,CAAC,GAAG,CAAL,CAAT,CAZ+B,CAYb;;AAElBtB,MAAAA,CAAC,CAACqB,CAAD,CAAD,GAAO7B,YAAY,CAACQ,CAAC,CAACqB,CAAD,CAAF,EAAOlB,OAAO,CAACD,EAAE,GAAGc,EAAH,GAAQC,EAAE,GAAG,CAAhB,CAAd,CAAnB,CAd+B,CAcuB;;AAEtDF,MAAAA,CAAC,GAAGb,EAAE,GAAGc,EAAE,GAAG,CAAR,GAAYA,EAAlB;AACAE,MAAAA,CAAC,GAAGhB,EAAE,GAAGe,EAAH,GAAQA,EAAE,GAAG,CAAnB,CAjB+B,CAiBT;;AAEtB,aAAOF,CAAC,GAAGG,CAAX,EAAcH,CAAC,EAAf,EAAmB;AACjB;AACA,YAAIQ,CAAC,GAAGlB,MAAM,CAACU,CAAD,CAAd,CAFiB,CAEE;;AAEnBf,QAAAA,CAAC,CAACuB,CAAD,CAAD,GAAO7B,QAAQ,CAACM,CAAC,CAACuB,CAAD,CAAF,EAAO9B,QAAQ,CAACU,OAAO,CAACY,CAAD,CAAR,EAAaf,CAAC,CAACqB,CAAD,CAAd,CAAf,CAAf;AACD;AACF,KApDiD,CAoDhD;;;AAGF,WAAOF,GAAP;AACD,GAxDD;AAyDD,CAjFkD,CAA5C","sourcesContent":["import { csReach } from './csReach';\nimport { factory } from '../../../utils/factory';\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nexport var createCsSpsolve = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract;\n\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = csReach(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n});"]},"metadata":{},"sourceType":"module"}
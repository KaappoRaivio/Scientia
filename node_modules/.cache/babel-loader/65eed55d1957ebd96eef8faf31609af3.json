{"ast":null,"code":"import { factory } from '../../utils/factory';\nimport { isMatrix } from '../../utils/is';\nimport { extend } from '../../utils/object';\nimport { arraySize } from '../../utils/array';\nimport { createAlgorithm11 } from '../../type/matrix/utils/algorithm11';\nimport { createAlgorithm14 } from '../../type/matrix/utils/algorithm14';\nvar name = 'multiply';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar'];\nexport var createMultiply = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      addScalar = _ref.addScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      equalScalar = _ref.equalScalar;\n  var algorithm11 = createAlgorithm11({\n    typed: typed,\n    equalScalar: equalScalar\n  });\n  var algorithm14 = createAlgorithm14({\n    typed: typed\n  });\n  /**\n   * Multiply two or more values, `x * y`.\n   * For matrices, the matrix product is calculated.\n   *\n   * Syntax:\n   *\n   *    math.multiply(x, y)\n   *    math.multiply(x, y, z, ...)\n   *\n   * Examples:\n   *\n   *    math.multiply(4, 5.2)        // returns number 20.8\n   *    math.multiply(2, 3, 4)       // returns number 24\n   *\n   *    const a = math.complex(2, 3)\n   *    const b = math.complex(4, 1)\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\n   *\n   *    const c = [[1, 2], [4, 3]]\n   *    const d = [[1, 2, 3], [3, -4, 7]]\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\n   *\n   *    const e = math.unit('2.1 km')\n   *    math.multiply(3, e)          // returns Unit 6.3 km\n   *\n   * See also:\n   *\n   *    divide, prod, cross, dot\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\n   */\n\n  var multiply = typed(name, extend({\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\n    'Array, Array': function ArrayArray(x, y) {\n      // check dimensions\n      _validateMatrixDimensions(arraySize(x), arraySize(y)); // use dense matrix implementation\n\n\n      var m = multiply(matrix(x), matrix(y)); // return array or scalar\n\n      return isMatrix(m) ? m.valueOf() : m;\n    },\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      // dimensions\n      var xsize = x.size();\n      var ysize = y.size(); // check dimensions\n\n      _validateMatrixDimensions(xsize, ysize); // process dimensions\n\n\n      if (xsize.length === 1) {\n        // process y dimensions\n        if (ysize.length === 1) {\n          // Vector * Vector\n          return _multiplyVectorVector(x, y, xsize[0]);\n        } // Vector * Matrix\n\n\n        return _multiplyVectorMatrix(x, y);\n      } // process y dimensions\n\n\n      if (ysize.length === 1) {\n        // Matrix * Vector\n        return _multiplyMatrixVector(x, y);\n      } // Matrix * Matrix\n\n\n      return _multiplyMatrixMatrix(x, y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use Matrix * Matrix implementation\n      return multiply(x, matrix(y));\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use Matrix * Matrix implementation\n      return multiply(matrix(x, y.storage()), y);\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm11(x, y, multiplyScalar, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, multiplyScalar, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm11(y, x, multiplyScalar, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, multiplyScalar, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();\n    },\n    'any, any': multiplyScalar,\n    'any, any, ...any': function anyAnyAny(x, y, rest) {\n      var result = multiply(x, y);\n\n      for (var i = 0; i < rest.length; i++) {\n        result = multiply(result, rest[i]);\n      }\n\n      return result;\n    }\n  }, multiplyScalar.signatures));\n\n  function _validateMatrixDimensions(size1, size2) {\n    // check left operand dimensions\n    switch (size1.length) {\n      case 1:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Vector x Vector\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\n            }\n\n            break;\n\n          case 2:\n            // Vector x Matrix\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      case 2:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Matrix x Vector\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\n            }\n\n            break;\n\n          case 2:\n            // Matrix x Matrix\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      default:\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\n    }\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (N)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {number}             Scalar value\n   */\n\n\n  function _multiplyVectorVector(a, b, n) {\n    // check empty vector\n    if (n === 0) {\n      throw new Error('Cannot multiply two empty vectors');\n    } // a dense\n\n\n    var adata = a._data;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result (do not initialize it with zero)\n\n\n    var c = mf(adata[0], bdata[0]); // loop data\n\n    for (var i = 1; i < n; i++) {\n      // multiply and accumulate\n      c = af(c, mf(adata[i], bdata[i]));\n    }\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Matrix         (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorMatrix(a, b) {\n    // process storage\n    if (b.storage() !== 'dense') {\n      throw new Error('Support for SparseMatrix not implemented');\n    }\n\n    return _multiplyVectorDenseMatrix(a, b);\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Dense Matrix   (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var alength = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix columns\n\n    for (var j = 0; j < bcolumns; j++) {\n      // sum (do not initialize it with zero)\n      var sum = mf(adata[0], bdata[0][j]); // loop vector\n\n      for (var i = 1; i < alength; i++) {\n        // multiply & accumulate\n        sum = af(sum, mf(adata[i], bdata[i][j]));\n      }\n\n      c[j] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {Matrix}             Dense Vector   (M)\n   */\n\n\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\n    'SparseMatrix, any': _multiplySparseMatrixVector\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Matrix         (NxC)\n   *\n   * @return {Matrix}             Matrix         (MxC)\n   */\n\n\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix  (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             Dense Vector (M)\n   */\n\n\n  function _multiplyDenseMatrixVector(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // sum (do not initialize it with zero)\n\n      var sum = mf(row[0], bdata[0]); // loop matrix a columns\n\n      for (var j = 1; j < acolumns; j++) {\n        // multiply & accumulate\n        sum = af(sum, mf(row[j], bdata[j]));\n      }\n\n      c[i] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            DenseMatrix    (NxC)\n   *\n   * @return {Matrix}             DenseMatrix    (MxC)\n   */\n\n\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // initialize row array\n\n      c[i] = []; // loop matrix b columns\n\n      for (var j = 0; j < bcolumns; j++) {\n        // sum (avoid initializing sum to zero)\n        var sum = mf(row[0], bdata[0][j]); // loop matrix a columns\n\n        for (var x = 1; x < acolumns; x++) {\n          // multiply & accumulate\n          sum = af(sum, mf(row[x], bdata[x][j]));\n        }\n\n        c[i][j] = sum;\n      }\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows, bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            SparseMatrix   (NxC)\n   *\n   * @return {Matrix}             SparseMatrix   (MxC)\n   */\n\n\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate b matrix\n\n    if (!bvalues) {\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\n    } // rows & columns\n\n\n    var arows = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = b.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // indeces in column jb\n\n      var kb0 = bptr[jb];\n      var kb1 = bptr[jb + 1]; // do not process column jb if no data exists\n\n      if (kb1 > kb0) {\n        // last row mark processed\n        var last = 0; // loop a rows\n\n        for (var i = 0; i < arows; i++) {\n          // column mark\n          var mark = i + 1; // C[i, jb]\n\n          var cij = void 0; // values in b column j\n\n          for (var kb = kb0; kb < kb1; kb++) {\n            // row\n            var ib = bindex[kb]; // check value has been initialized\n\n            if (last !== mark) {\n              // first value in column jb\n              cij = mf(adata[i][ib], bvalues[kb]); // update mark\n\n              last = mark;\n            } else {\n              // accumulate value\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\n            }\n          } // check column has been processed and value != 0\n\n\n          if (last === mark && !eq(cij, zero)) {\n            // push row & value\n            cindex.push(i);\n            cvalues.push(cij);\n          }\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix    (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             SparseMatrix    (M, 1)\n   */\n\n\n  function _multiplySparseMatrixVector(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0]; // result\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // workspace\n\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // update ptr\n\n    cptr[0] = 0; // rows in b\n\n    for (var ib = 0; ib < brows; ib++) {\n      // b[ib]\n      var vbi = bdata[ib]; // check b[ib] != 0, avoid loops\n\n      if (!eq(vbi, zero)) {\n        // A values & index in ib column\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n          // a row\n          var ia = aindex[ka]; // check value exists in current j\n\n          if (!w[ia]) {\n            // ia is new entry in j\n            w[ia] = true; // add i to pattern of C\n\n            cindex.push(ia); // x(ia) = A\n\n            x[ia] = mf(vbi, avalues[ka]);\n          } else {\n            // i exists in C already\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\n          }\n        }\n      }\n    } // copy values from x to column jb of c\n\n\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\n      // row\n      var ic = cindex[p]; // copy value\n\n      cvalues[p] = x[ic];\n    } // update ptr\n\n\n    cptr[1] = cindex.length; // return sparse matrix\n\n    return a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, 1],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            DenseMatrix       (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixDenseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0];\n    var bcolumns = b._size[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // rows in jb\n\n      for (var ib = 0; ib < brows; ib++) {\n        // b[ib, jb]\n        var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops\n\n        if (!eq(vbij, zero)) {\n          // A values & index in ib column\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // a row\n            var ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(vbij, avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\n            }\n          }\n        }\n      } // copy values from x to column jb of c\n\n\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n        // row\n        var ic = cindex[p]; // copy value\n\n        cvalues[p] = x[ic];\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            SparseMatrix      (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixSparseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data\n\n    var values = avalues && bvalues; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // variables\n\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // B values & index in j\n\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\n        // b row\n        ib = bindex[kb]; // check we need to process values\n\n        if (values) {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(bvalues[kb], avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\n            }\n          }\n        } else {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia);\n            }\n          }\n        }\n      } // check we need to process matrix values (pattern matrix)\n\n\n      if (values) {\n        // copy values from x to column jb of c\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n          // row\n          var ic = cindex[p]; // copy value\n\n          cvalues[p] = x[ic];\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n\n  return multiply;\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/arithmetic/multiply.js"],"names":["factory","isMatrix","extend","arraySize","createAlgorithm11","createAlgorithm14","name","dependencies","createMultiply","_ref","typed","matrix","addScalar","multiplyScalar","equalScalar","algorithm11","algorithm14","multiply","ArrayArray","x","y","_validateMatrixDimensions","m","valueOf","MatrixMatrix","xsize","size","ysize","length","_multiplyVectorVector","_multiplyVectorMatrix","_multiplyMatrixVector","_multiplyMatrixMatrix","MatrixArray","ArrayMatrix","storage","SparseMatrixAny","DenseMatrixAny","anySparseMatrix","anyDenseMatrix","ArrayAny","anyArray","anyAnyAny","rest","result","i","signatures","size1","size2","RangeError","Error","a","b","n","adata","_data","adt","_datatype","bdata","bdt","dt","af","mf","find","c","_multiplyVectorDenseMatrix","asize","_size","bsize","alength","bcolumns","j","sum","createDenseMatrix","data","datatype","_multiplyDenseMatrixVector","_multiplySparseMatrixVector","_multiplyDenseMatrixDenseMatrix","_multiplyDenseMatrixSparseMatrix","_multiplySparseMatrixDenseMatrix","_multiplySparseMatrixSparseMatrix","arows","acolumns","row","bvalues","_values","bindex","_index","bptr","_ptr","eq","zero","convert","cvalues","cindex","cptr","createSparseMatrix","values","index","ptr","jb","kb0","kb1","last","mark","cij","kb","ib","push","avalues","aindex","aptr","brows","w","vbi","ka0","ka1","ka","ia","p1","p","ic","vbij","p0","undefined"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory';\nimport { isMatrix } from '../../utils/is';\nimport { extend } from '../../utils/object';\nimport { arraySize } from '../../utils/array';\nimport { createAlgorithm11 } from '../../type/matrix/utils/algorithm11';\nimport { createAlgorithm14 } from '../../type/matrix/utils/algorithm14';\nvar name = 'multiply';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar'];\nexport var createMultiply = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      addScalar = _ref.addScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      equalScalar = _ref.equalScalar;\n  var algorithm11 = createAlgorithm11({\n    typed: typed,\n    equalScalar: equalScalar\n  });\n  var algorithm14 = createAlgorithm14({\n    typed: typed\n  });\n  /**\n   * Multiply two or more values, `x * y`.\n   * For matrices, the matrix product is calculated.\n   *\n   * Syntax:\n   *\n   *    math.multiply(x, y)\n   *    math.multiply(x, y, z, ...)\n   *\n   * Examples:\n   *\n   *    math.multiply(4, 5.2)        // returns number 20.8\n   *    math.multiply(2, 3, 4)       // returns number 24\n   *\n   *    const a = math.complex(2, 3)\n   *    const b = math.complex(4, 1)\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\n   *\n   *    const c = [[1, 2], [4, 3]]\n   *    const d = [[1, 2, 3], [3, -4, 7]]\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\n   *\n   *    const e = math.unit('2.1 km')\n   *    math.multiply(3, e)          // returns Unit 6.3 km\n   *\n   * See also:\n   *\n   *    divide, prod, cross, dot\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\n   */\n\n  var multiply = typed(name, extend({\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\n    'Array, Array': function ArrayArray(x, y) {\n      // check dimensions\n      _validateMatrixDimensions(arraySize(x), arraySize(y)); // use dense matrix implementation\n\n\n      var m = multiply(matrix(x), matrix(y)); // return array or scalar\n\n      return isMatrix(m) ? m.valueOf() : m;\n    },\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      // dimensions\n      var xsize = x.size();\n      var ysize = y.size(); // check dimensions\n\n      _validateMatrixDimensions(xsize, ysize); // process dimensions\n\n\n      if (xsize.length === 1) {\n        // process y dimensions\n        if (ysize.length === 1) {\n          // Vector * Vector\n          return _multiplyVectorVector(x, y, xsize[0]);\n        } // Vector * Matrix\n\n\n        return _multiplyVectorMatrix(x, y);\n      } // process y dimensions\n\n\n      if (ysize.length === 1) {\n        // Matrix * Vector\n        return _multiplyMatrixVector(x, y);\n      } // Matrix * Matrix\n\n\n      return _multiplyMatrixMatrix(x, y);\n    },\n    'Matrix, Array': function MatrixArray(x, y) {\n      // use Matrix * Matrix implementation\n      return multiply(x, matrix(y));\n    },\n    'Array, Matrix': function ArrayMatrix(x, y) {\n      // use Matrix * Matrix implementation\n      return multiply(matrix(x, y.storage()), y);\n    },\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return algorithm11(x, y, multiplyScalar, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return algorithm14(x, y, multiplyScalar, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return algorithm11(y, x, multiplyScalar, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return algorithm14(y, x, multiplyScalar, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();\n    },\n    'any, any': multiplyScalar,\n    'any, any, ...any': function anyAnyAny(x, y, rest) {\n      var result = multiply(x, y);\n\n      for (var i = 0; i < rest.length; i++) {\n        result = multiply(result, rest[i]);\n      }\n\n      return result;\n    }\n  }, multiplyScalar.signatures));\n\n  function _validateMatrixDimensions(size1, size2) {\n    // check left operand dimensions\n    switch (size1.length) {\n      case 1:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Vector x Vector\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\n            }\n\n            break;\n\n          case 2:\n            // Vector x Matrix\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      case 2:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Matrix x Vector\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\n            }\n\n            break;\n\n          case 2:\n            // Matrix x Matrix\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      default:\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\n    }\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (N)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {number}             Scalar value\n   */\n\n\n  function _multiplyVectorVector(a, b, n) {\n    // check empty vector\n    if (n === 0) {\n      throw new Error('Cannot multiply two empty vectors');\n    } // a dense\n\n\n    var adata = a._data;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result (do not initialize it with zero)\n\n\n    var c = mf(adata[0], bdata[0]); // loop data\n\n    for (var i = 1; i < n; i++) {\n      // multiply and accumulate\n      c = af(c, mf(adata[i], bdata[i]));\n    }\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Matrix         (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorMatrix(a, b) {\n    // process storage\n    if (b.storage() !== 'dense') {\n      throw new Error('Support for SparseMatrix not implemented');\n    }\n\n    return _multiplyVectorDenseMatrix(a, b);\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Dense Matrix   (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n\n\n  function _multiplyVectorDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var alength = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix columns\n\n    for (var j = 0; j < bcolumns; j++) {\n      // sum (do not initialize it with zero)\n      var sum = mf(adata[0], bdata[0][j]); // loop vector\n\n      for (var i = 1; i < alength; i++) {\n        // multiply & accumulate\n        sum = af(sum, mf(adata[i], bdata[i][j]));\n      }\n\n      c[j] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {Matrix}             Dense Vector   (M)\n   */\n\n\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\n    'SparseMatrix, any': _multiplySparseMatrixVector\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Matrix         (NxC)\n   *\n   * @return {Matrix}             Matrix         (MxC)\n   */\n\n\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\n  });\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix  (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             Dense Vector (M)\n   */\n\n\n  function _multiplyDenseMatrixVector(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // sum (do not initialize it with zero)\n\n      var sum = mf(row[0], bdata[0]); // loop matrix a columns\n\n      for (var j = 1; j < acolumns; j++) {\n        // multiply & accumulate\n        sum = af(sum, mf(row[j], bdata[j]));\n      }\n\n      c[i] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            DenseMatrix    (NxC)\n   *\n   * @return {Matrix}             DenseMatrix    (MxC)\n   */\n\n\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // initialize row array\n\n      c[i] = []; // loop matrix b columns\n\n      for (var j = 0; j < bcolumns; j++) {\n        // sum (avoid initializing sum to zero)\n        var sum = mf(row[0], bdata[0][j]); // loop matrix a columns\n\n        for (var x = 1; x < acolumns; x++) {\n          // multiply & accumulate\n          sum = af(sum, mf(row[x], bdata[x][j]));\n        }\n\n        c[i][j] = sum;\n      }\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows, bcolumns],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            SparseMatrix   (NxC)\n   *\n   * @return {Matrix}             SparseMatrix   (MxC)\n   */\n\n\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate b matrix\n\n    if (!bvalues) {\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\n    } // rows & columns\n\n\n    var arows = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = b.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // indeces in column jb\n\n      var kb0 = bptr[jb];\n      var kb1 = bptr[jb + 1]; // do not process column jb if no data exists\n\n      if (kb1 > kb0) {\n        // last row mark processed\n        var last = 0; // loop a rows\n\n        for (var i = 0; i < arows; i++) {\n          // column mark\n          var mark = i + 1; // C[i, jb]\n\n          var cij = void 0; // values in b column j\n\n          for (var kb = kb0; kb < kb1; kb++) {\n            // row\n            var ib = bindex[kb]; // check value has been initialized\n\n            if (last !== mark) {\n              // first value in column jb\n              cij = mf(adata[i][ib], bvalues[kb]); // update mark\n\n              last = mark;\n            } else {\n              // accumulate value\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\n            }\n          } // check column has been processed and value != 0\n\n\n          if (last === mark && !eq(cij, zero)) {\n            // push row & value\n            cindex.push(i);\n            cvalues.push(cij);\n          }\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix    (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             SparseMatrix    (M, 1)\n   */\n\n\n  function _multiplySparseMatrixVector(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0]; // result\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // workspace\n\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // update ptr\n\n    cptr[0] = 0; // rows in b\n\n    for (var ib = 0; ib < brows; ib++) {\n      // b[ib]\n      var vbi = bdata[ib]; // check b[ib] != 0, avoid loops\n\n      if (!eq(vbi, zero)) {\n        // A values & index in ib column\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n          // a row\n          var ia = aindex[ka]; // check value exists in current j\n\n          if (!w[ia]) {\n            // ia is new entry in j\n            w[ia] = true; // add i to pattern of C\n\n            cindex.push(ia); // x(ia) = A\n\n            x[ia] = mf(vbi, avalues[ka]);\n          } else {\n            // i exists in C already\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\n          }\n        }\n      }\n    } // copy values from x to column jb of c\n\n\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\n      // row\n      var ic = cindex[p]; // copy value\n\n      cvalues[p] = x[ic];\n    } // update ptr\n\n\n    cptr[1] = cindex.length; // return sparse matrix\n\n    return a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, 1],\n      datatype: dt\n    });\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            DenseMatrix       (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixDenseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0];\n    var bcolumns = b._size[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // rows in jb\n\n      for (var ib = 0; ib < brows; ib++) {\n        // b[ib, jb]\n        var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops\n\n        if (!eq(vbij, zero)) {\n          // A values & index in ib column\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // a row\n            var ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(vbij, avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\n            }\n          }\n        }\n      } // copy values from x to column jb of c\n\n\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n        // row\n        var ic = cindex[p]; // copy value\n\n        cvalues[p] = x[ic];\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            SparseMatrix      (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n\n\n  function _multiplySparseMatrixSparseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data\n\n    var values = avalues && bvalues; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // variables\n\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // B values & index in j\n\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\n        // b row\n        ib = bindex[kb]; // check we need to process values\n\n        if (values) {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(bvalues[kb], avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\n            }\n          }\n        } else {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia);\n            }\n          }\n        }\n      } // check we need to process matrix values (pattern matrix)\n\n\n      if (values) {\n        // copy values from x to column jb of c\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n          // row\n          var ic = cindex[p]; // copy value\n\n          cvalues[p] = x[ic];\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n\n  return multiply;\n});"]},"metadata":{},"sourceType":"module"}
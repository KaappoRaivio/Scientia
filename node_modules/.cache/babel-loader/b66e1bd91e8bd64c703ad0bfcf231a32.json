{"ast":null,"code":"import naturalSort from 'javascript-natural-sort';\nimport { isDenseMatrix, isSparseMatrix, typeOf } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nvar name = 'compareNatural';\nvar dependencies = ['typed', 'compare'];\nexport var createCompareNatural = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      compare = _ref.compare;\n  var compareBooleans = compare.signatures['boolean,boolean'];\n  /**\n   * Compare two values of any type in a deterministic, natural way.\n   *\n   * For numeric values, the function works the same as `math.compare`.\n   * For types of values that can't be compared mathematically,\n   * the function compares in a natural way.\n   *\n   * For numeric values, x and y are considered equal when the relative\n   * difference between x and y is smaller than the configured epsilon.\n   * The function cannot be used to compare values smaller than\n   * approximately 2.22e-16.\n   *\n   * For Complex numbers, first the real parts are compared. If equal,\n   * the imaginary parts are compared.\n   *\n   * Strings are compared with a natural sorting algorithm, which\n   * orders strings in a \"logic\" way following some heuristics.\n   * This differs from the function `compare`, which converts the string\n   * into a numeric value and compares that. The function `compareText`\n   * on the other hand compares text lexically.\n   *\n   * Arrays and Matrices are compared value by value until there is an\n   * unequal pair of values encountered. Objects are compared by sorted\n   * keys until the keys or their values are unequal.\n   *\n   * Syntax:\n   *\n   *    math.compareNatural(x, y)\n   *\n   * Examples:\n   *\n   *    math.compareNatural(6, 1)              // returns 1\n   *    math.compareNatural(2, 3)              // returns -1\n   *    math.compareNatural(7, 7)              // returns 0\n   *\n   *    math.compareNatural('10', '2')         // returns 1\n   *    math.compareText('10', '2')            // returns -1\n   *    math.compare('10', '2')                // returns 1\n   *\n   *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1\n   *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1\n   *    math.compare('Answer: 10', 'Answer: 2')\n   *        // Error: Cannot convert \"Answer: 10\" to a number\n   *\n   *    const a = math.unit('5 cm')\n   *    const b = math.unit('40 mm')\n   *    math.compareNatural(a, b)              // returns 1\n   *\n   *    const c = math.complex('2 + 3i')\n   *    const d = math.complex('2 + 4i')\n   *    math.compareNatural(c, d)              // returns -1\n   *\n   *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1\n   *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1\n   *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1\n   *    math.compareNatural([1, 2], [1, 2])       // returns 0\n   *\n   *    math.compareNatural({a: 2}, {a: 4})       // returns -1\n   *\n   * See also:\n   *\n   *    compare, compareText\n   *\n   * @param  {*} x First value to compare\n   * @param  {*} y Second value to compare\n   * @return {number} Returns the result of the comparison:\n   *                  1 when x > y, -1 when x < y, and 0 when x == y.\n   */\n\n  var compareNatural = typed(name, {\n    'any, any': function anyAny(x, y) {\n      var typeX = typeOf(x);\n      var typeY = typeOf(y);\n      var c; // numeric types\n\n      if ((typeX === 'number' || typeX === 'BigNumber' || typeX === 'Fraction') && (typeY === 'number' || typeY === 'BigNumber' || typeY === 'Fraction')) {\n        c = compare(x, y);\n\n        if (c.toString() !== '0') {\n          // c can be number, BigNumber, or Fraction\n          return c > 0 ? 1 : -1; // return a number\n        } else {\n          return naturalSort(typeX, typeY);\n        }\n      } // matrix types\n\n\n      if (typeX === 'Array' || typeX === 'Matrix' || typeY === 'Array' || typeY === 'Matrix') {\n        c = compareMatricesAndArrays(x, y);\n\n        if (c !== 0) {\n          return c;\n        } else {\n          return naturalSort(typeX, typeY);\n        }\n      } // in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'\n\n\n      if (typeX !== typeY) {\n        return naturalSort(typeX, typeY);\n      }\n\n      if (typeX === 'Complex') {\n        return compareComplexNumbers(x, y);\n      }\n\n      if (typeX === 'Unit') {\n        if (x.equalBase(y)) {\n          return compareNatural(x.value, y.value);\n        } // compare by units\n\n\n        return compareArrays(x.formatUnits(), y.formatUnits());\n      }\n\n      if (typeX === 'boolean') {\n        return compareBooleans(x, y);\n      }\n\n      if (typeX === 'string') {\n        return naturalSort(x, y);\n      }\n\n      if (typeX === 'Object') {\n        return compareObjects(x, y);\n      }\n\n      if (typeX === 'null') {\n        return 0;\n      }\n\n      if (typeX === 'undefined') {\n        return 0;\n      } // this should not occur...\n\n\n      throw new TypeError('Unsupported type of value \"' + typeX + '\"');\n    }\n  });\n  /**\n   * Compare mixed matrix/array types, by converting to same-shaped array.\n   * This comparator is non-deterministic regarding input types.\n   * @param {Array | SparseMatrix | DenseMatrix | *} x\n   * @param {Array | SparseMatrix | DenseMatrix | *} y\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n  function compareMatricesAndArrays(x, y) {\n    if (isSparseMatrix(x) && isSparseMatrix(y)) {\n      return compareArrays(x.toJSON().values, y.toJSON().values);\n    }\n\n    if (isSparseMatrix(x)) {\n      // note: convert to array is expensive\n      return compareMatricesAndArrays(x.toArray(), y);\n    }\n\n    if (isSparseMatrix(y)) {\n      // note: convert to array is expensive\n      return compareMatricesAndArrays(x, y.toArray());\n    } // convert DenseArray into Array\n\n\n    if (isDenseMatrix(x)) {\n      return compareMatricesAndArrays(x.toJSON().data, y);\n    }\n\n    if (isDenseMatrix(y)) {\n      return compareMatricesAndArrays(x, y.toJSON().data);\n    } // convert scalars to array\n\n\n    if (!Array.isArray(x)) {\n      return compareMatricesAndArrays([x], y);\n    }\n\n    if (!Array.isArray(y)) {\n      return compareMatricesAndArrays(x, [y]);\n    }\n\n    return compareArrays(x, y);\n  }\n  /**\n   * Compare two Arrays\n   *\n   * - First, compares value by value\n   * - Next, if all corresponding values are equal,\n   *   look at the length: longest array will be considered largest\n   *\n   * @param {Array} x\n   * @param {Array} y\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n\n  function compareArrays(x, y) {\n    // compare each value\n    for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {\n      var v = compareNatural(x[i], y[i]);\n\n      if (v !== 0) {\n        return v;\n      }\n    } // compare the size of the arrays\n\n\n    if (x.length > y.length) {\n      return 1;\n    }\n\n    if (x.length < y.length) {\n      return -1;\n    } // both Arrays have equal size and content\n\n\n    return 0;\n  }\n  /**\n   * Compare two objects\n   *\n   * - First, compare sorted property names\n   * - Next, compare the property values\n   *\n   * @param {Object} x\n   * @param {Object} y\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n\n  function compareObjects(x, y) {\n    var keysX = Object.keys(x);\n    var keysY = Object.keys(y); // compare keys\n\n    keysX.sort(naturalSort);\n    keysY.sort(naturalSort);\n    var c = compareArrays(keysX, keysY);\n\n    if (c !== 0) {\n      return c;\n    } // compare values\n\n\n    for (var i = 0; i < keysX.length; i++) {\n      var v = compareNatural(x[keysX[i]], y[keysY[i]]);\n\n      if (v !== 0) {\n        return v;\n      }\n    }\n\n    return 0;\n  }\n\n  return compareNatural;\n});\n/**\n * Compare two complex numbers, `x` and `y`:\n *\n * - First, compare the real values of `x` and `y`\n * - If equal, compare the imaginary values of `x` and `y`\n *\n * @params {Complex} x\n * @params {Complex} y\n * @returns {number} Returns the comparison result: -1, 0, or 1\n */\n\nfunction compareComplexNumbers(x, y) {\n  if (x.re > y.re) {\n    return 1;\n  }\n\n  if (x.re < y.re) {\n    return -1;\n  }\n\n  if (x.im > y.im) {\n    return 1;\n  }\n\n  if (x.im < y.im) {\n    return -1;\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/relational/compareNatural.js"],"names":["naturalSort","isDenseMatrix","isSparseMatrix","typeOf","factory","name","dependencies","createCompareNatural","_ref","typed","compare","compareBooleans","signatures","compareNatural","anyAny","x","y","typeX","typeY","c","toString","compareMatricesAndArrays","compareComplexNumbers","equalBase","value","compareArrays","formatUnits","compareObjects","TypeError","toJSON","values","toArray","data","Array","isArray","i","ii","Math","min","length","v","keysX","Object","keys","keysY","sort","re","im"],"mappings":"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","sourcesContent":["import naturalSort from 'javascript-natural-sort';\nimport { isDenseMatrix, isSparseMatrix, typeOf } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nvar name = 'compareNatural';\nvar dependencies = ['typed', 'compare'];\nexport var createCompareNatural = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      compare = _ref.compare;\n  var compareBooleans = compare.signatures['boolean,boolean'];\n  /**\n   * Compare two values of any type in a deterministic, natural way.\n   *\n   * For numeric values, the function works the same as `math.compare`.\n   * For types of values that can't be compared mathematically,\n   * the function compares in a natural way.\n   *\n   * For numeric values, x and y are considered equal when the relative\n   * difference between x and y is smaller than the configured epsilon.\n   * The function cannot be used to compare values smaller than\n   * approximately 2.22e-16.\n   *\n   * For Complex numbers, first the real parts are compared. If equal,\n   * the imaginary parts are compared.\n   *\n   * Strings are compared with a natural sorting algorithm, which\n   * orders strings in a \"logic\" way following some heuristics.\n   * This differs from the function `compare`, which converts the string\n   * into a numeric value and compares that. The function `compareText`\n   * on the other hand compares text lexically.\n   *\n   * Arrays and Matrices are compared value by value until there is an\n   * unequal pair of values encountered. Objects are compared by sorted\n   * keys until the keys or their values are unequal.\n   *\n   * Syntax:\n   *\n   *    math.compareNatural(x, y)\n   *\n   * Examples:\n   *\n   *    math.compareNatural(6, 1)              // returns 1\n   *    math.compareNatural(2, 3)              // returns -1\n   *    math.compareNatural(7, 7)              // returns 0\n   *\n   *    math.compareNatural('10', '2')         // returns 1\n   *    math.compareText('10', '2')            // returns -1\n   *    math.compare('10', '2')                // returns 1\n   *\n   *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1\n   *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1\n   *    math.compare('Answer: 10', 'Answer: 2')\n   *        // Error: Cannot convert \"Answer: 10\" to a number\n   *\n   *    const a = math.unit('5 cm')\n   *    const b = math.unit('40 mm')\n   *    math.compareNatural(a, b)              // returns 1\n   *\n   *    const c = math.complex('2 + 3i')\n   *    const d = math.complex('2 + 4i')\n   *    math.compareNatural(c, d)              // returns -1\n   *\n   *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1\n   *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1\n   *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1\n   *    math.compareNatural([1, 2], [1, 2])       // returns 0\n   *\n   *    math.compareNatural({a: 2}, {a: 4})       // returns -1\n   *\n   * See also:\n   *\n   *    compare, compareText\n   *\n   * @param  {*} x First value to compare\n   * @param  {*} y Second value to compare\n   * @return {number} Returns the result of the comparison:\n   *                  1 when x > y, -1 when x < y, and 0 when x == y.\n   */\n\n  var compareNatural = typed(name, {\n    'any, any': function anyAny(x, y) {\n      var typeX = typeOf(x);\n      var typeY = typeOf(y);\n      var c; // numeric types\n\n      if ((typeX === 'number' || typeX === 'BigNumber' || typeX === 'Fraction') && (typeY === 'number' || typeY === 'BigNumber' || typeY === 'Fraction')) {\n        c = compare(x, y);\n\n        if (c.toString() !== '0') {\n          // c can be number, BigNumber, or Fraction\n          return c > 0 ? 1 : -1; // return a number\n        } else {\n          return naturalSort(typeX, typeY);\n        }\n      } // matrix types\n\n\n      if (typeX === 'Array' || typeX === 'Matrix' || typeY === 'Array' || typeY === 'Matrix') {\n        c = compareMatricesAndArrays(x, y);\n\n        if (c !== 0) {\n          return c;\n        } else {\n          return naturalSort(typeX, typeY);\n        }\n      } // in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'\n\n\n      if (typeX !== typeY) {\n        return naturalSort(typeX, typeY);\n      }\n\n      if (typeX === 'Complex') {\n        return compareComplexNumbers(x, y);\n      }\n\n      if (typeX === 'Unit') {\n        if (x.equalBase(y)) {\n          return compareNatural(x.value, y.value);\n        } // compare by units\n\n\n        return compareArrays(x.formatUnits(), y.formatUnits());\n      }\n\n      if (typeX === 'boolean') {\n        return compareBooleans(x, y);\n      }\n\n      if (typeX === 'string') {\n        return naturalSort(x, y);\n      }\n\n      if (typeX === 'Object') {\n        return compareObjects(x, y);\n      }\n\n      if (typeX === 'null') {\n        return 0;\n      }\n\n      if (typeX === 'undefined') {\n        return 0;\n      } // this should not occur...\n\n\n      throw new TypeError('Unsupported type of value \"' + typeX + '\"');\n    }\n  });\n  /**\n   * Compare mixed matrix/array types, by converting to same-shaped array.\n   * This comparator is non-deterministic regarding input types.\n   * @param {Array | SparseMatrix | DenseMatrix | *} x\n   * @param {Array | SparseMatrix | DenseMatrix | *} y\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n  function compareMatricesAndArrays(x, y) {\n    if (isSparseMatrix(x) && isSparseMatrix(y)) {\n      return compareArrays(x.toJSON().values, y.toJSON().values);\n    }\n\n    if (isSparseMatrix(x)) {\n      // note: convert to array is expensive\n      return compareMatricesAndArrays(x.toArray(), y);\n    }\n\n    if (isSparseMatrix(y)) {\n      // note: convert to array is expensive\n      return compareMatricesAndArrays(x, y.toArray());\n    } // convert DenseArray into Array\n\n\n    if (isDenseMatrix(x)) {\n      return compareMatricesAndArrays(x.toJSON().data, y);\n    }\n\n    if (isDenseMatrix(y)) {\n      return compareMatricesAndArrays(x, y.toJSON().data);\n    } // convert scalars to array\n\n\n    if (!Array.isArray(x)) {\n      return compareMatricesAndArrays([x], y);\n    }\n\n    if (!Array.isArray(y)) {\n      return compareMatricesAndArrays(x, [y]);\n    }\n\n    return compareArrays(x, y);\n  }\n  /**\n   * Compare two Arrays\n   *\n   * - First, compares value by value\n   * - Next, if all corresponding values are equal,\n   *   look at the length: longest array will be considered largest\n   *\n   * @param {Array} x\n   * @param {Array} y\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n\n  function compareArrays(x, y) {\n    // compare each value\n    for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {\n      var v = compareNatural(x[i], y[i]);\n\n      if (v !== 0) {\n        return v;\n      }\n    } // compare the size of the arrays\n\n\n    if (x.length > y.length) {\n      return 1;\n    }\n\n    if (x.length < y.length) {\n      return -1;\n    } // both Arrays have equal size and content\n\n\n    return 0;\n  }\n  /**\n   * Compare two objects\n   *\n   * - First, compare sorted property names\n   * - Next, compare the property values\n   *\n   * @param {Object} x\n   * @param {Object} y\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n\n  function compareObjects(x, y) {\n    var keysX = Object.keys(x);\n    var keysY = Object.keys(y); // compare keys\n\n    keysX.sort(naturalSort);\n    keysY.sort(naturalSort);\n    var c = compareArrays(keysX, keysY);\n\n    if (c !== 0) {\n      return c;\n    } // compare values\n\n\n    for (var i = 0; i < keysX.length; i++) {\n      var v = compareNatural(x[keysX[i]], y[keysY[i]]);\n\n      if (v !== 0) {\n        return v;\n      }\n    }\n\n    return 0;\n  }\n\n  return compareNatural;\n});\n/**\n * Compare two complex numbers, `x` and `y`:\n *\n * - First, compare the real values of `x` and `y`\n * - If equal, compare the imaginary values of `x` and `y`\n *\n * @params {Complex} x\n * @params {Complex} y\n * @returns {number} Returns the comparison result: -1, 0, or 1\n */\n\nfunction compareComplexNumbers(x, y) {\n  if (x.re > y.re) {\n    return 1;\n  }\n\n  if (x.re < y.re) {\n    return -1;\n  }\n\n  if (x.im > y.im) {\n    return 1;\n  }\n\n  if (x.im < y.im) {\n    return -1;\n  }\n\n  return 0;\n}"]},"metadata":{},"sourceType":"module"}
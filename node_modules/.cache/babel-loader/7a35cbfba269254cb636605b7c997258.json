{"ast":null,"code":"import { getPrecedence } from '../operators';\nimport { escape } from '../../utils/string';\nimport { getSafeProperty } from '../../utils/customs';\nimport { latexOperators } from '../../utils/latex';\nimport { factory } from '../../utils/factory';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(function (p) {\n      return p._compile(math, argNames);\n    });\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = getSafeProperty(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    var _this = this;\n\n    this.params.forEach(function (n, i) {\n      return callback(n, 'params[' + i + ']', _this);\n    }, this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    var _this2 = this;\n\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\n    }, this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/node/RelationalNode.js"],"names":["getPrecedence","escape","getSafeProperty","latexOperators","factory","name","dependencies","createRelationalNode","_ref","Node","RelationalNode","conditionals","params","SyntaxError","Array","isArray","TypeError","length","prototype","type","isRelationalNode","_compile","math","argNames","self","compiled","map","p","evalRelationalNode","scope","args","context","evalLhs","evalRhs","i","condFn","forEach","callback","_this","n","_this2","slice","_ifNode","clone","_toString","options","parenthesis","precedence","paramStrings","index","paramPrecedence","toString","operatorMap","equal","unequal","smaller","larger","smallerEq","largerEq","ret","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass","isNode"],"mappings":"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","sourcesContent":["import { getPrecedence } from '../operators';\nimport { escape } from '../../utils/string';\nimport { getSafeProperty } from '../../utils/customs';\nimport { latexOperators } from '../../utils/latex';\nimport { factory } from '../../utils/factory';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(function (p) {\n      return p._compile(math, argNames);\n    });\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = getSafeProperty(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    var _this = this;\n\n    this.params.forEach(function (n, i) {\n      return callback(n, 'params[' + i + ']', _this);\n    }, this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    var _this2 = this;\n\n    return new RelationalNode(this.conditionals.slice(), this.params.map(function (n, i) {\n      return _this2._ifNode(callback(n, 'params[' + i + ']', _this2));\n    }, this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { factory } from '../../../utils/factory';\nimport { csLeaf } from './csLeaf';\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nexport var createCsCounts = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var transpose = _ref.transpose;\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/sparse/csCounts.js"],"names":["factory","csLeaf","name","dependencies","createCsCounts","_ref","transpose","a","parent","post","ata","asize","_size","m","n","i","j","k","J","p","p0","p1","s","w","ancestor","maxfirst","prevleaf","first","head","next","colcount","at","tindex","_index","tptr","_ptr","Math","min","r","jleaf","q"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory';\nimport { csLeaf } from './csLeaf';\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nexport var createCsCounts = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var transpose = _ref.transpose;\n\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n});"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"'use strict';\n\nvar width = 256; // each RC4 output is 0 <= x < 256\n\nvar chunks = 6; // at least six RC4 outputs for each double\n\nvar digits = 52; // there are 52 significant digits in a double\n\nvar pool = []; // pool: entropy pool starts empty\n\nvar GLOBAL = typeof global === 'undefined' ? window : global; //\n// The following constants are related to IEEE 754 limits.\n//\n\nvar startdenom = Math.pow(width, chunks),\n    significance = Math.pow(2, digits),\n    overflow = significance * 2,\n    mask = width - 1;\nvar oldRandom = Math.random; //\n// seedrandom()\n// This is the seedrandom function described above.\n//\n\nmodule.exports = function (seed, options) {\n  if (options && options.global === true) {\n    options.global = false;\n    Math.random = module.exports(seed, options);\n    options.global = true;\n    return Math.random;\n  }\n\n  var use_entropy = options && options.entropy || false;\n  var key = []; // Flatten the seed string or build one from local entropy if needed.\n\n  var shortseed = mixkey(flatten(use_entropy ? [seed, tostring(pool)] : 0 in arguments ? seed : autoseed(), 3), key); // Use the seed to initialize an ARC4 generator.\n\n  var arc4 = new ARC4(key); // Mix the randomness into accumulated entropy.\n\n  mixkey(tostring(arc4.S), pool); // Override Math.random\n  // This function returns a random double in [0, 1) that contains\n  // randomness in every bit of the mantissa of the IEEE 754 value.\n\n  return function () {\n    // Closure to return a random double:\n    var n = arc4.g(chunks),\n        // Start with a numerator n < 2 ^ 48\n    d = startdenom,\n        //   and denominator d = 2 ^ 48.\n    x = 0; //   and no 'extra last byte'.\n\n    while (n < significance) {\n      // Fill up all significant digits by\n      n = (n + x) * width; //   shifting numerator and\n\n      d *= width; //   denominator and generating a\n\n      x = arc4.g(1); //   new least-significant-byte.\n    }\n\n    while (n >= overflow) {\n      // To avoid rounding up, before adding\n      n /= 2; //   last byte, shift everything\n\n      d /= 2; //   right using integer Math until\n\n      x >>>= 1; //   we have exactly the desired bits.\n    }\n\n    return (n + x) / d; // Form the number within [0, 1).\n  };\n};\n\nmodule.exports.resetGlobal = function () {\n  Math.random = oldRandom;\n}; //\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\n\n/** @constructor */\n\n\nfunction ARC4(key) {\n  var t,\n      keylen = key.length,\n      me = this,\n      i = 0,\n      j = me.i = me.j = 0,\n      s = me.S = []; // The empty key [] is treated as [0].\n\n  if (!keylen) {\n    key = [keylen++];\n  } // Set up S using the standard key scheduling algorithm.\n\n\n  while (i < width) {\n    s[i] = i++;\n  }\n\n  for (i = 0; i < width; i++) {\n    s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n    s[j] = t;\n  } // The \"g\" method returns the next (count) outputs as one number.\n\n\n  (me.g = function (count) {\n    // Using instance members instead of closure state nearly doubles speed.\n    var t,\n        r = 0,\n        i = me.i,\n        j = me.j,\n        s = me.S;\n\n    while (count--) {\n      t = s[i = mask & i + 1];\n      r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n    }\n\n    me.i = i;\n    me.j = j;\n    return r; // For robust unpredictability discard an initial batch of values.\n    // See http://www.rsa.com/rsalabs/node.asp?id=2009\n  })(width);\n} //\n// flatten()\n// Converts an object tree to nested arrays of strings.\n//\n\n\nfunction flatten(obj, depth) {\n  var result = [],\n      typ = (typeof obj)[0],\n      prop;\n\n  if (depth && typ == 'o') {\n    for (prop in obj) {\n      try {\n        result.push(flatten(obj[prop], depth - 1));\n      } catch (e) {}\n    }\n  }\n\n  return result.length ? result : typ == 's' ? obj : obj + '\\0';\n} //\n// mixkey()\n// Mixes a string seed into a key that is an array of integers, and\n// returns a shortened string seed that is equivalent to the result key.\n//\n\n\nfunction mixkey(seed, key) {\n  var stringseed = seed + '',\n      smear,\n      j = 0;\n\n  while (j < stringseed.length) {\n    key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n  }\n\n  return tostring(key);\n} //\n// autoseed()\n// Returns an object for autoseeding, using window.crypto if available.\n//\n\n/** @param {Uint8Array=} seed */\n\n\nfunction autoseed(seed) {\n  try {\n    GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));\n    return tostring(seed);\n  } catch (e) {\n    return [+new Date(), GLOBAL, GLOBAL.navigator && GLOBAL.navigator.plugins, GLOBAL.screen, tostring(pool)];\n  }\n} //\n// tostring()\n// Converts an array of charcodes to a string\n//\n\n\nfunction tostring(a) {\n  return String.fromCharCode.apply(0, a);\n} //\n// When seedrandom.js is loaded, we immediately mix a few bits\n// from the built-in RNG into the entropy pool.  Because we do\n// not want to intefere with determinstic PRNG state later,\n// seedrandom will not call Math.random on its own again after\n// initialization.\n//\n\n\nmixkey(Math.random(), pool);","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/seed-random/index.js"],"names":["width","chunks","digits","pool","GLOBAL","global","window","startdenom","Math","pow","significance","overflow","mask","oldRandom","random","module","exports","seed","options","use_entropy","entropy","key","shortseed","mixkey","flatten","tostring","arguments","autoseed","arc4","ARC4","S","n","g","d","x","resetGlobal","t","keylen","length","me","i","j","s","count","r","obj","depth","result","typ","prop","push","e","stringseed","smear","charCodeAt","crypto","getRandomValues","Uint8Array","Date","navigator","plugins","screen","a","String","fromCharCode","apply"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar width = 256;// each RC4 output is 0 <= x < 256\r\nvar chunks = 6;// at least six RC4 outputs for each double\r\nvar digits = 52;// there are 52 significant digits in a double\r\nvar pool = [];// pool: entropy pool starts empty\r\nvar GLOBAL = typeof global === 'undefined' ? window : global;\r\n\r\n//\r\n// The following constants are related to IEEE 754 limits.\r\n//\r\nvar startdenom = Math.pow(width, chunks),\r\n    significance = Math.pow(2, digits),\r\n    overflow = significance * 2,\r\n    mask = width - 1;\r\n\r\n\r\nvar oldRandom = Math.random;\r\n\r\n//\r\n// seedrandom()\r\n// This is the seedrandom function described above.\r\n//\r\nmodule.exports = function(seed, options) {\r\n  if (options && options.global === true) {\r\n    options.global = false;\r\n    Math.random = module.exports(seed, options);\r\n    options.global = true;\r\n    return Math.random;\r\n  }\r\n  var use_entropy = (options && options.entropy) || false;\r\n  var key = [];\r\n\r\n  // Flatten the seed string or build one from local entropy if needed.\r\n  var shortseed = mixkey(flatten(\r\n    use_entropy ? [seed, tostring(pool)] :\r\n    0 in arguments ? seed : autoseed(), 3), key);\r\n\r\n  // Use the seed to initialize an ARC4 generator.\r\n  var arc4 = new ARC4(key);\r\n\r\n  // Mix the randomness into accumulated entropy.\r\n  mixkey(tostring(arc4.S), pool);\r\n\r\n  // Override Math.random\r\n\r\n  // This function returns a random double in [0, 1) that contains\r\n  // randomness in every bit of the mantissa of the IEEE 754 value.\r\n\r\n  return function() {         // Closure to return a random double:\r\n    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48\r\n        d = startdenom,                 //   and denominator d = 2 ^ 48.\r\n        x = 0;                          //   and no 'extra last byte'.\r\n    while (n < significance) {          // Fill up all significant digits by\r\n      n = (n + x) * width;              //   shifting numerator and\r\n      d *= width;                       //   denominator and generating a\r\n      x = arc4.g(1);                    //   new least-significant-byte.\r\n    }\r\n    while (n >= overflow) {             // To avoid rounding up, before adding\r\n      n /= 2;                           //   last byte, shift everything\r\n      d /= 2;                           //   right using integer Math until\r\n      x >>>= 1;                         //   we have exactly the desired bits.\r\n    }\r\n    return (n + x) / d;                 // Form the number within [0, 1).\r\n  };\r\n};\r\n\r\nmodule.exports.resetGlobal = function () {\r\n  Math.random = oldRandom;\r\n};\r\n\r\n//\r\n// ARC4\r\n//\r\n// An ARC4 implementation.  The constructor takes a key in the form of\r\n// an array of at most (width) integers that should be 0 <= x < (width).\r\n//\r\n// The g(count) method returns a pseudorandom integer that concatenates\r\n// the next (count) outputs from ARC4.  Its return value is a number x\r\n// that is in the range 0 <= x < (width ^ count).\r\n//\r\n/** @constructor */\r\nfunction ARC4(key) {\r\n  var t, keylen = key.length,\r\n      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\r\n\r\n  // The empty key [] is treated as [0].\r\n  if (!keylen) { key = [keylen++]; }\r\n\r\n  // Set up S using the standard key scheduling algorithm.\r\n  while (i < width) {\r\n    s[i] = i++;\r\n  }\r\n  for (i = 0; i < width; i++) {\r\n    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];\r\n    s[j] = t;\r\n  }\r\n\r\n  // The \"g\" method returns the next (count) outputs as one number.\r\n  (me.g = function(count) {\r\n    // Using instance members instead of closure state nearly doubles speed.\r\n    var t, r = 0,\r\n        i = me.i, j = me.j, s = me.S;\r\n    while (count--) {\r\n      t = s[i = mask & (i + 1)];\r\n      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];\r\n    }\r\n    me.i = i; me.j = j;\r\n    return r;\r\n    // For robust unpredictability discard an initial batch of values.\r\n    // See http://www.rsa.com/rsalabs/node.asp?id=2009\r\n  })(width);\r\n}\r\n\r\n//\r\n// flatten()\r\n// Converts an object tree to nested arrays of strings.\r\n//\r\nfunction flatten(obj, depth) {\r\n  var result = [], typ = (typeof obj)[0], prop;\r\n  if (depth && typ == 'o') {\r\n    for (prop in obj) {\r\n      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\r\n    }\r\n  }\r\n  return (result.length ? result : typ == 's' ? obj : obj + '\\0');\r\n}\r\n\r\n//\r\n// mixkey()\r\n// Mixes a string seed into a key that is an array of integers, and\r\n// returns a shortened string seed that is equivalent to the result key.\r\n//\r\nfunction mixkey(seed, key) {\r\n  var stringseed = seed + '', smear, j = 0;\r\n  while (j < stringseed.length) {\r\n    key[mask & j] =\r\n      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));\r\n  }\r\n  return tostring(key);\r\n}\r\n\r\n//\r\n// autoseed()\r\n// Returns an object for autoseeding, using window.crypto if available.\r\n//\r\n/** @param {Uint8Array=} seed */\r\nfunction autoseed(seed) {\r\n  try {\r\n    GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));\r\n    return tostring(seed);\r\n  } catch (e) {\r\n    return [+new Date, GLOBAL, GLOBAL.navigator && GLOBAL.navigator.plugins,\r\n            GLOBAL.screen, tostring(pool)];\r\n  }\r\n}\r\n\r\n//\r\n// tostring()\r\n// Converts an array of charcodes to a string\r\n//\r\nfunction tostring(a) {\r\n  return String.fromCharCode.apply(0, a);\r\n}\r\n\r\n//\r\n// When seedrandom.js is loaded, we immediately mix a few bits\r\n// from the built-in RNG into the entropy pool.  Because we do\r\n// not want to intefere with determinstic PRNG state later,\r\n// seedrandom will not call Math.random on its own again after\r\n// initialization.\r\n//\r\nmixkey(Math.random(), pool);\r\n"]},"metadata":{},"sourceType":"script"}
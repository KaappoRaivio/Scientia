{"ast":null,"code":"import { csPermute } from './csPermute';\nimport { csPost } from './csPost';\nimport { csEtree } from './csEtree';\nimport { createCsAmd } from './csAmd';\nimport { createCsCounts } from './csCounts';\nimport { factory } from '../../../utils/factory';\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nexport var createCsSqr = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose;\n  var csAmd = createCsAmd({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csCounts = createCsCounts({\n    transpose: transpose\n  });\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? csPermute(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = csEtree(c, 1); // post order elimination tree\n\n      var post = csPost(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n\n    return s;\n  };\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n\n    return true;\n  }\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/function/algebra/sparse/csSqr.js"],"names":["csPermute","csPost","csEtree","createCsAmd","createCsCounts","factory","name","dependencies","createCsSqr","_ref","add","multiply","transpose","csAmd","csCounts","csSqr","order","a","qr","aptr","_ptr","asize","_size","n","k","s","q","c","parent","post","cp","_vcount","unz","lnz","aindex","_index","m","pinv","leftmost","w","next","head","tail","nque","i","p","p0","p1","m2","pa"],"mappings":"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","sourcesContent":["import { csPermute } from './csPermute';\nimport { csPost } from './csPost';\nimport { csEtree } from './csEtree';\nimport { createCsAmd } from './csAmd';\nimport { createCsCounts } from './csCounts';\nimport { factory } from '../../../utils/factory';\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nexport var createCsSqr = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose;\n  var csAmd = createCsAmd({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csCounts = createCsCounts({\n    transpose: transpose\n  });\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? csPermute(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = csEtree(c, 1); // post order elimination tree\n\n      var post = csPost(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n\n    return s;\n  };\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n\n    return true;\n  }\n});"]},"metadata":{},"sourceType":"module"}
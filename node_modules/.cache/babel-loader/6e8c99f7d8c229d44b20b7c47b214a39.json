{"ast":null,"code":"import { isNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');\n    };\n\n    Object.defineProperty(this, 'nodes', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = map(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix(map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    var s = '\\\\begin{bmatrix}';\n    this.items.forEach(function (node) {\n      if (node.items) {\n        s += node.items.map(function (childNode) {\n          return childNode.toTex(options);\n        }).join('&');\n      } else {\n        s += node.toTex(options);\n      } // new line\n\n\n      s += '\\\\\\\\';\n    });\n    s += '\\\\end{bmatrix}';\n    return s;\n  };\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/expression/node/ArrayNode.js"],"names":["isNode","map","factory","name","dependencies","createArrayNode","_ref","Node","ArrayNode","items","SyntaxError","Array","isArray","every","TypeError","deprecated","Error","Object","defineProperty","get","set","prototype","type","isArrayNode","_compile","math","argNames","evalItems","item","asMatrix","config","matrix","evalArrayNode","scope","args","context","evalItem","forEach","callback","i","length","node","_ifNode","clone","slice","_toString","options","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","s","childNode","toTex","isClass"],"mappings":"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","sourcesContent":["import { isNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { factory } from '../../utils/factory';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    } // TODO: deprecated since v3, remove some day\n\n\n    var deprecated = function deprecated() {\n      throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');\n    };\n\n    Object.defineProperty(this, 'nodes', {\n      get: deprecated,\n      set: deprecated\n    });\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = map(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix(map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    var s = '\\\\begin{bmatrix}';\n    this.items.forEach(function (node) {\n      if (node.items) {\n        s += node.items.map(function (childNode) {\n          return childNode.toTex(options);\n        }).join('&');\n      } else {\n        s += node.toTex(options);\n      } // new line\n\n\n      s += '\\\\\\\\';\n    });\n    s += '\\\\end{bmatrix}';\n    return s;\n  };\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
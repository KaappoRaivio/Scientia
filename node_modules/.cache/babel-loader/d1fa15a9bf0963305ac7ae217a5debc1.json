{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { factory } from '../utils/factory';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode } from '../utils/is';\nimport { deepMap } from '../utils/collection';\nimport { hasOwnProperty } from '../utils/object';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      numeric = _ref.numeric,\n      config = _ref.config,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      AssignmentNode = _ref.AssignmentNode,\n      BlockNode = _ref.BlockNode,\n      ConditionalNode = _ref.ConditionalNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionAssignmentNode = _ref.FunctionAssignmentNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      RangeNode = _ref.RangeNode,\n      RelationalNode = _ref.RelationalNode,\n      SymbolNode = _ref.SymbolNode;\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    \"in\": true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    \"true\": true,\n    \"false\": false,\n    \"null\": null,\n    undefined: undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over whitespaces\n    // space, tab, and newline when inside parameters\n\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n      next(state);\n    } // skip comment\n\n\n    if (currentCharacter(state) === '#') {\n      while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n        state.comment += currentCharacter(state);\n        next(state);\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // get number, can have a single dot\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression: expression,\n      extraNodes: extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(function (c) {\n        return c.fn;\n      }), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      \"in\": 'to' // alias of 'to'\n\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseMultiplyDivide(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parseUnary(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && isConstantNode(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parseUnary(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.expression.node.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n\n  return parse;\n});","map":{"version":3,"sources":["/home/kaappo/git/kments/node_modules/mathjs/es/expression/parse.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","factory","isAccessorNode","isConstantNode","isFunctionNode","isOperatorNode","isSymbolNode","deepMap","name","dependencies","createParse","_ref","typed","numeric","config","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","RangeNode","RelationalNode","SymbolNode","parse","string","expression","parseStart","ArrayMatrix","expressions","parseMultiple","stringObject","options","extraNodes","nodes","undefined","elem","TypeError","TOKENTYPE","NULL","DELIMITER","NUMBER","SYMBOL","UNKNOWN","DELIMITERS","NAMED_DELIMITERS","mod","to","and","xor","or","not","CONSTANTS","NUMERIC_CONSTANTS","initialState","comment","index","token","tokenType","nestingLevel","conditionalLevel","currentString","state","substr","currentCharacter","next","prevCharacter","charAt","nextCharacter","getToken","isWhitespace","c1","c2","c3","isDigitDot","isDigit","isDecimalMark","createSyntaxError","isAlpha","getTokenSkipNewline","openParams","closeParams","c","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","test","high","low","node","parseBlock","createError","blocks","visible","parseAssignment","push","args","value","valid","parseConditional","object","fn","forEach","arg","parseLogicalOr","prev","condition","trueExpr","falseExpr","parseLogicalXor","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","conditionals","operators","cond","map","parseConversion","parseRange","parseAddSubtract","parseMultiplyDivide","last","parseImplicitMultiplication","parseRule2","op","parseUnary","tokenStates","pop","parsePow","parseLeftHandOperators","parseCustomNodes","parseAccessors","CustomNode","parseSymbol","indexOf","parseDoubleQuotesString","types","dotNotation","str","parseDoubleQuotesStringToken","parseSingleQuotesString","JSON","parseSingleQuotesStringToken","parseMatrix","array","rows","cols","row","parseRow","items","r","parseObject","len","properties","parseNumber","numberStr","number","parseParentheses","parseEnd","col","message","error","SyntaxError"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { factory } from '../utils/factory';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode } from '../utils/is';\nimport { deepMap } from '../utils/collection';\nimport { hasOwnProperty } from '../utils/object';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      numeric = _ref.numeric,\n      config = _ref.config,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      AssignmentNode = _ref.AssignmentNode,\n      BlockNode = _ref.BlockNode,\n      ConditionalNode = _ref.ConditionalNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionAssignmentNode = _ref.FunctionAssignmentNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      RangeNode = _ref.RangeNode,\n      RelationalNode = _ref.RelationalNode,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    \"in\": true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    \"true\": true,\n    \"false\": false,\n    \"null\": null,\n    undefined: undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over whitespaces\n    // space, tab, and newline when inside parameters\n\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n      next(state);\n    } // skip comment\n\n\n    if (currentCharacter(state) === '#') {\n      while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n        state.comment += currentCharacter(state);\n        next(state);\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // get number, can have a single dot\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression: expression,\n      extraNodes: extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(function (c) {\n        return c.fn;\n      }), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      \"in\": 'to' // alias of 'to'\n\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseMultiplyDivide(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parseUnary(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && isConstantNode(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parseUnary(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.expression.node.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n\n  return parse;\n});"]},"metadata":{},"sourceType":"module"}
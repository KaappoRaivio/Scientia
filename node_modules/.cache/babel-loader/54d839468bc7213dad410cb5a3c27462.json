{"ast":null,"code":"import { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nimport { getPrecedence } from '../operators';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/expression/node/ConditionalNode.js"],"names":["isBigNumber","isComplex","isNode","isUnit","typeOf","factory","getPrecedence","name","dependencies","createConditionalNode","_ref","Node","ConditionalNode","condition","trueExpr","falseExpr","SyntaxError","TypeError","prototype","type","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","testCondition","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isZero","re","im","value","undefined","isClass"],"mappings":"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","sourcesContent":["import { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nimport { getPrecedence } from '../operators';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}
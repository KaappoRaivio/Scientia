{"ast":null,"code":"/**\n * Permutes a sparse matrix C = P * A * Q\n *\n * @param {SparseMatrix}  a         The Matrix A\n * @param {Array}   pinv            The row permutation vector\n * @param {Array}   q               The column permutation vector\n * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise\n *\n * @return {Matrix}                 C = P * A * Q, null on error\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csPermute(a, pinv, q, values) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size;\n  var adt = a._datatype; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // c arrays\n\n  var cvalues = values && a._values ? [] : null;\n  var cindex = []; // (aptr[n])\n\n  var cptr = []; // (n + 1)\n  // initialize vars\n\n  var nz = 0; // loop columns\n\n  for (var k = 0; k < n; k++) {\n    // column k of C is column q[k] of A\n    cptr[k] = nz; // apply column permutation\n\n    var j = q ? q[k] : k; // loop values in column j of A\n\n    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {\n      // row i of A is row pinv[i] of C\n      var r = pinv ? pinv[aindex[t]] : aindex[t]; // index\n\n      cindex[nz] = r; // check we need to populate values\n\n      if (cvalues) {\n        cvalues[nz] = avalues[t];\n      } // increment number of nonzero elements\n\n\n      nz++;\n    }\n  } // finalize the last column of C\n\n\n  cptr[n] = nz; // return C matrix\n\n  return a.createSparseMatrix({\n    values: cvalues,\n    index: cindex,\n    ptr: cptr,\n    size: [m, n],\n    datatype: adt\n  });\n}","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/sparse/csPermute.js"],"names":["csPermute","a","pinv","q","values","avalues","_values","aindex","_index","aptr","_ptr","asize","_size","adt","_datatype","m","n","cvalues","cindex","cptr","nz","k","j","t0","t1","t","r","createSparseMatrix","index","ptr","size","datatype"],"mappings":"AAAA;;;;;;;;;;;;AAYA,OAAO,SAASA,SAAT,CAAmBC,CAAnB,EAAsBC,IAAtB,EAA4BC,CAA5B,EAA+BC,MAA/B,EAAuC;AAC5C;AACA,MAAIC,OAAO,GAAGJ,CAAC,CAACK,OAAhB;AACA,MAAIC,MAAM,GAAGN,CAAC,CAACO,MAAf;AACA,MAAIC,IAAI,GAAGR,CAAC,CAACS,IAAb;AACA,MAAIC,KAAK,GAAGV,CAAC,CAACW,KAAd;AACA,MAAIC,GAAG,GAAGZ,CAAC,CAACa,SAAZ,CAN4C,CAMrB;;AAEvB,MAAIC,CAAC,GAAGJ,KAAK,CAAC,CAAD,CAAb;AACA,MAAIK,CAAC,GAAGL,KAAK,CAAC,CAAD,CAAb,CAT4C,CAS1B;;AAElB,MAAIM,OAAO,GAAGb,MAAM,IAAIH,CAAC,CAACK,OAAZ,GAAsB,EAAtB,GAA2B,IAAzC;AACA,MAAIY,MAAM,GAAG,EAAb,CAZ4C,CAY3B;;AAEjB,MAAIC,IAAI,GAAG,EAAX,CAd4C,CAc7B;AACf;;AAEA,MAAIC,EAAE,GAAG,CAAT,CAjB4C,CAiBhC;;AAEZ,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAApB,EAAuBK,CAAC,EAAxB,EAA4B;AAC1B;AACAF,IAAAA,IAAI,CAACE,CAAD,CAAJ,GAAUD,EAAV,CAF0B,CAEZ;;AAEd,QAAIE,CAAC,GAAGnB,CAAC,GAAGA,CAAC,CAACkB,CAAD,CAAJ,GAAUA,CAAnB,CAJ0B,CAIJ;;AAEtB,SAAK,IAAIE,EAAE,GAAGd,IAAI,CAACa,CAAD,CAAb,EAAkBE,EAAE,GAAGf,IAAI,CAACa,CAAC,GAAG,CAAL,CAA3B,EAAoCG,CAAC,GAAGF,EAA7C,EAAiDE,CAAC,GAAGD,EAArD,EAAyDC,CAAC,EAA1D,EAA8D;AAC5D;AACA,UAAIC,CAAC,GAAGxB,IAAI,GAAGA,IAAI,CAACK,MAAM,CAACkB,CAAD,CAAP,CAAP,GAAqBlB,MAAM,CAACkB,CAAD,CAAvC,CAF4D,CAEhB;;AAE5CP,MAAAA,MAAM,CAACE,EAAD,CAAN,GAAaM,CAAb,CAJ4D,CAI5C;;AAEhB,UAAIT,OAAJ,EAAa;AACXA,QAAAA,OAAO,CAACG,EAAD,CAAP,GAAcf,OAAO,CAACoB,CAAD,CAArB;AACD,OAR2D,CAQ1D;;;AAGFL,MAAAA,EAAE;AACH;AACF,GAtC2C,CAsC1C;;;AAGFD,EAAAA,IAAI,CAACH,CAAD,CAAJ,GAAUI,EAAV,CAzC4C,CAyC9B;;AAEd,SAAOnB,CAAC,CAAC0B,kBAAF,CAAqB;AAC1BvB,IAAAA,MAAM,EAAEa,OADkB;AAE1BW,IAAAA,KAAK,EAAEV,MAFmB;AAG1BW,IAAAA,GAAG,EAAEV,IAHqB;AAI1BW,IAAAA,IAAI,EAAE,CAACf,CAAD,EAAIC,CAAJ,CAJoB;AAK1Be,IAAAA,QAAQ,EAAElB;AALgB,GAArB,CAAP;AAOD","sourcesContent":["/**\n * Permutes a sparse matrix C = P * A * Q\n *\n * @param {SparseMatrix}  a         The Matrix A\n * @param {Array}   pinv            The row permutation vector\n * @param {Array}   q               The column permutation vector\n * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise\n *\n * @return {Matrix}                 C = P * A * Q, null on error\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csPermute(a, pinv, q, values) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size;\n  var adt = a._datatype; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // c arrays\n\n  var cvalues = values && a._values ? [] : null;\n  var cindex = []; // (aptr[n])\n\n  var cptr = []; // (n + 1)\n  // initialize vars\n\n  var nz = 0; // loop columns\n\n  for (var k = 0; k < n; k++) {\n    // column k of C is column q[k] of A\n    cptr[k] = nz; // apply column permutation\n\n    var j = q ? q[k] : k; // loop values in column j of A\n\n    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {\n      // row i of A is row pinv[i] of C\n      var r = pinv ? pinv[aindex[t]] : aindex[t]; // index\n\n      cindex[nz] = r; // check we need to populate values\n\n      if (cvalues) {\n        cvalues[nz] = avalues[t];\n      } // increment number of nonzero elements\n\n\n      nz++;\n    }\n  } // finalize the last column of C\n\n\n  cptr[n] = nz; // return C matrix\n\n  return a.createSparseMatrix({\n    values: cvalues,\n    index: cindex,\n    ptr: cptr,\n    size: [m, n],\n    datatype: adt\n  });\n}"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { isArray, isMatrix } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { createSolveValidation } from './utils/solveValidation';\nimport { csIpvec } from '../sparse/csIpvec';\nvar name = 'lusolve';\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\nexport var createLusolve = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      lup = _ref.lup,\n      slu = _ref.slu,\n      usolve = _ref.usolve,\n      lsolve = _ref.lsolve,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = createSolveValidation({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\n   *\n   * Syntax:\n   *\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\n   *\n   * Examples:\n   *\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n   *\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\n   *\n   *    const f = math.lup(m)\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\n   *\n   * See also:\n   *\n   *    lup, slu, lsolve, usolve\n   *\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\n   * @param {Matrix | Array} b               Column Vector\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\n   *\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\n   */\n\n  return typed(name, {\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      // convert a to matrix\n      a = matrix(a); // matrix lup decomposition\n\n      var d = lup(a); // solve\n\n      var x = _lusolve(d.L, d.U, d.p, null, b); // convert result to array\n\n\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {\n      // matrix lup decomposition\n      var d = lup(a); // solve\n\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {\n      // matrix lup decomposition\n      var d = lup(a); // solve\n\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {\n      // matrix lu decomposition\n      var d = slu(a, order, threshold); // solve\n\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {\n      // solve\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n\n  function _toMatrix(a) {\n    // check it is a matrix\n    if (isMatrix(a)) {\n      return a;\n    } // check array\n\n\n    if (isArray(a)) {\n      return matrix(a);\n    } // throw\n\n\n    throw new TypeError('Invalid Matrix LU decomposition');\n  }\n\n  function _lusolve(l, u, p, q, b) {\n    // verify L, U, P\n    l = _toMatrix(l);\n    u = _toMatrix(u); // validate matrix and vector\n\n    b = solveValidation(l, b, false); // apply row permutations if needed (b is a DenseMatrix)\n\n    if (p) {\n      b._data = csIpvec(p, b._data);\n    } // use forward substitution to resolve L * y = b\n\n\n    var y = lsolve(l, b); // use backward substitution to resolve U * x = y\n\n    var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)\n\n    if (q) {\n      x._data = csIpvec(q, x._data);\n    } // return solution\n\n\n    return x;\n  }\n});","map":{"version":3,"sources":["/home/kaappo/testit/canvas/node_modules/mathjs/es/function/algebra/solver/lusolve.js"],"names":["isArray","isMatrix","factory","createSolveValidation","csIpvec","name","dependencies","createLusolve","_ref","typed","matrix","lup","slu","usolve","lsolve","DenseMatrix","solveValidation","ArrayArrayMatrix","a","b","d","x","_lusolve","L","U","p","valueOf","DenseMatrixArrayMatrix","SparseMatrixArrayMatrix","SparseMatrixArrayMatrixNumberNumber","order","threshold","q","ObjectArrayMatrix","_toMatrix","TypeError","l","u","_data","y"],"mappings":"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","sourcesContent":["import { isArray, isMatrix } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { createSolveValidation } from './utils/solveValidation';\nimport { csIpvec } from '../sparse/csIpvec';\nvar name = 'lusolve';\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\nexport var createLusolve = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      lup = _ref.lup,\n      slu = _ref.slu,\n      usolve = _ref.usolve,\n      lsolve = _ref.lsolve,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = createSolveValidation({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\n   *\n   * Syntax:\n   *\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\n   *\n   * Examples:\n   *\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n   *\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\n   *\n   *    const f = math.lup(m)\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\n   *\n   * See also:\n   *\n   *    lup, slu, lsolve, usolve\n   *\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\n   * @param {Matrix | Array} b               Column Vector\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\n   *\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\n   */\n\n  return typed(name, {\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      // convert a to matrix\n      a = matrix(a); // matrix lup decomposition\n\n      var d = lup(a); // solve\n\n      var x = _lusolve(d.L, d.U, d.p, null, b); // convert result to array\n\n\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {\n      // matrix lup decomposition\n      var d = lup(a); // solve\n\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {\n      // matrix lup decomposition\n      var d = lup(a); // solve\n\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {\n      // matrix lu decomposition\n      var d = slu(a, order, threshold); // solve\n\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {\n      // solve\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n\n  function _toMatrix(a) {\n    // check it is a matrix\n    if (isMatrix(a)) {\n      return a;\n    } // check array\n\n\n    if (isArray(a)) {\n      return matrix(a);\n    } // throw\n\n\n    throw new TypeError('Invalid Matrix LU decomposition');\n  }\n\n  function _lusolve(l, u, p, q, b) {\n    // verify L, U, P\n    l = _toMatrix(l);\n    u = _toMatrix(u); // validate matrix and vector\n\n    b = solveValidation(l, b, false); // apply row permutations if needed (b is a DenseMatrix)\n\n    if (p) {\n      b._data = csIpvec(p, b._data);\n    } // use forward substitution to resolve L * y = b\n\n\n    var y = lsolve(l, b); // use backward substitution to resolve U * x = y\n\n    var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)\n\n    if (q) {\n      x._data = csIpvec(q, x._data);\n    } // return solution\n\n\n    return x;\n  }\n});"]},"metadata":{},"sourceType":"module"}